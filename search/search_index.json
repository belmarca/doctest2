{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gambit Scheme documentation This website contains documentation for Gambit Scheme. You can browse the user manual for an in-depth presentation of features, or navigate to the how-tos to see various examples, tutorials and snippets of how to work with Gambit Scheme. document.body.onload = () => main_vm.init('#ui');","title":"Gambit Scheme documentation"},{"location":"#gambit-scheme-documentation","text":"This website contains documentation for Gambit Scheme. You can browse the user manual for an in-depth presentation of features, or navigate to the how-tos to see various examples, tutorials and snippets of how to work with Gambit Scheme. document.body.onload = () => main_vm.init('#ui');","title":"Gambit Scheme documentation"},{"location":"howtos/","text":"","title":"Index"},{"location":"manual/","text":"Gambit This manual documents Gambit. It covers release v4.9.4.","title":"Gambit"},{"location":"manual/#gambit","text":"This manual documents Gambit. It covers release v4.9.4.","title":"Gambit"},{"location":"manual/built_in_data_types/","text":"Built-in data types This section covers Gambit Scheme's built-in data types.","title":"Built-in data types"},{"location":"manual/built_in_data_types/#built-in-data-types","text":"This section covers Gambit Scheme's built-in data types.","title":"Built-in data types"},{"location":"manual/built_in_data_types/booleans/","text":"Booleans This documentation needs work, cleanup or clarification.","title":"Booleans"},{"location":"manual/built_in_data_types/booleans/#booleans","text":"This documentation needs work, cleanup or clarification.","title":"Booleans"},{"location":"manual/built_in_data_types/characters_and_strings/","text":"Characters and strings Gambit supports the Unicode character encoding standard. Scheme characters can be any of the characters whose Unicode encoding is in the range 0 to #x10ffff (inclusive) but not in the range #xd800 to #xdfff . Source code can also contain any Unicode character, however to read such source code properly gsi and gsc must be told which character encoding to use for reading the source code (i.e. ISO-8859-1, UTF-8, UTF-16, etc). This can be done by specifying the runtime option -:file-settings=... or -:io-settings=... when gsi and gsc are started. Extensions to character procedures char->integer integer->char (char->integer char) ;; procedure (integer->char n) ;; procedure The procedure char->integer returns the Unicode encoding of the character char . The procedure integer->char returns the character whose Unicode encoding is the exact integer n . For example: > (char->integer #\\!) 33 > (integer->char 65) #\\A > (integer->char (char->integer #\\u1234)) #\\u1234 > (integer->char #xd800) *** ERROR IN (console)@4.1 -- (Argument 1) Out of range (integer->char 55296) char=? char<? char>? char<=? char>=? char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=? (char=? char1 ...) ;; procedure (char<? char1 ...) ;; procedure (char>? char1 ...) ;; procedure (char<=? char1 ...) ;; procedure (char>=? char1 ...) ;; procedure (char-ci=? char1 ...) ;; procedure (char-ci<? char1 ...) ;; procedure (char-ci>? char1 ...) ;; procedure (char-ci<=? char1 ...) ;; procedure (char-ci>=? char1 ...) ;; procedure These procedures take any number of arguments including no argument. This is useful to test if the elements of a list are sorted in a particular order. For example, testing that the list of characters lst is sorted in nondecreasing order can be done with the call (apply char<? lst) . Extensions to string procedures string=? string<? string>? string<=? string>=? string-ci=? string-ci<? string-ci>? string-ci<=? string-ci>=? (string=? string1 ...) ;; procedure (string<? string1 ...) ;; procedure (string>? string1 ...) ;; procedure (string<=? string1 ...) ;; procedure (string>=? string1 ...) ;; procedure (string-ci=? string1 ...) ;; procedure (string-ci<? string1 ...) ;; procedure (string-ci>? string1 ...) ;; procedure (string-ci<=? string1 ...) ;; procedure (string-ci>=? string1 ...) ;; procedure These procedures take any number of arguments including no argument. This is useful to test if the elements of a list are sorted in a particular order. For example, testing that the list of strings lst is sorted in nondecreasing order can be done with the call (apply string<? lst) .","title":"Characters and strings"},{"location":"manual/built_in_data_types/characters_and_strings/#characters-and-strings","text":"Gambit supports the Unicode character encoding standard. Scheme characters can be any of the characters whose Unicode encoding is in the range 0 to #x10ffff (inclusive) but not in the range #xd800 to #xdfff . Source code can also contain any Unicode character, however to read such source code properly gsi and gsc must be told which character encoding to use for reading the source code (i.e. ISO-8859-1, UTF-8, UTF-16, etc). This can be done by specifying the runtime option -:file-settings=... or -:io-settings=... when gsi and gsc are started.","title":"Characters and strings"},{"location":"manual/built_in_data_types/characters_and_strings/#extensions-to-character-procedures","text":"","title":"Extensions to character procedures"},{"location":"manual/built_in_data_types/characters_and_strings/#char-integer","text":"","title":"char-&gt;integer"},{"location":"manual/built_in_data_types/characters_and_strings/#integer-char","text":"(char->integer char) ;; procedure (integer->char n) ;; procedure The procedure char->integer returns the Unicode encoding of the character char . The procedure integer->char returns the character whose Unicode encoding is the exact integer n . For example: > (char->integer #\\!) 33 > (integer->char 65) #\\A > (integer->char (char->integer #\\u1234)) #\\u1234 > (integer->char #xd800) *** ERROR IN (console)@4.1 -- (Argument 1) Out of range (integer->char 55296)","title":"integer-&gt;char"},{"location":"manual/built_in_data_types/characters_and_strings/#char","text":"","title":"char=?"},{"location":"manual/built_in_data_types/characters_and_strings/#char_1","text":"","title":"char&lt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#char_2","text":"","title":"char&gt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#char_3","text":"","title":"char&lt;=?"},{"location":"manual/built_in_data_types/characters_and_strings/#char_4","text":"","title":"char&gt;=?"},{"location":"manual/built_in_data_types/characters_and_strings/#char-ci","text":"","title":"char-ci=?"},{"location":"manual/built_in_data_types/characters_and_strings/#char-ci_1","text":"","title":"char-ci&lt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#char-ci_2","text":"","title":"char-ci&gt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#char-ci_3","text":"","title":"char-ci&lt;=?"},{"location":"manual/built_in_data_types/characters_and_strings/#char-ci_4","text":"(char=? char1 ...) ;; procedure (char<? char1 ...) ;; procedure (char>? char1 ...) ;; procedure (char<=? char1 ...) ;; procedure (char>=? char1 ...) ;; procedure (char-ci=? char1 ...) ;; procedure (char-ci<? char1 ...) ;; procedure (char-ci>? char1 ...) ;; procedure (char-ci<=? char1 ...) ;; procedure (char-ci>=? char1 ...) ;; procedure These procedures take any number of arguments including no argument. This is useful to test if the elements of a list are sorted in a particular order. For example, testing that the list of characters lst is sorted in nondecreasing order can be done with the call (apply char<? lst) .","title":"char-ci&gt;=?"},{"location":"manual/built_in_data_types/characters_and_strings/#extensions-to-string-procedures","text":"","title":"Extensions to string procedures"},{"location":"manual/built_in_data_types/characters_and_strings/#string","text":"","title":"string=?"},{"location":"manual/built_in_data_types/characters_and_strings/#string_1","text":"","title":"string&lt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#string_2","text":"","title":"string&gt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#string_3","text":"","title":"string&lt;=?"},{"location":"manual/built_in_data_types/characters_and_strings/#string_4","text":"","title":"string&gt;=?"},{"location":"manual/built_in_data_types/characters_and_strings/#string-ci","text":"","title":"string-ci=?"},{"location":"manual/built_in_data_types/characters_and_strings/#string-ci_1","text":"","title":"string-ci&lt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#string-ci_2","text":"","title":"string-ci&gt;?"},{"location":"manual/built_in_data_types/characters_and_strings/#string-ci_3","text":"","title":"string-ci&lt;=?"},{"location":"manual/built_in_data_types/characters_and_strings/#string-ci_4","text":"(string=? string1 ...) ;; procedure (string<? string1 ...) ;; procedure (string>? string1 ...) ;; procedure (string<=? string1 ...) ;; procedure (string>=? string1 ...) ;; procedure (string-ci=? string1 ...) ;; procedure (string-ci<? string1 ...) ;; procedure (string-ci>? string1 ...) ;; procedure (string-ci<=? string1 ...) ;; procedure (string-ci>=? string1 ...) ;; procedure These procedures take any number of arguments including no argument. This is useful to test if the elements of a list are sorted in a particular order. For example, testing that the list of strings lst is sorted in nondecreasing order can be done with the call (apply string<? lst) .","title":"string-ci&gt;=?"},{"location":"manual/built_in_data_types/hashing_and_weak_references/","text":"Hashing and weak references Hashing object->serial-number serial-number->object (object->serial-number obj) ;; procedure (serial-number->object n [default]) ;; procedure All Scheme objects are uniquely identified with a serial number which is a nonnegative exact integer. The object->serial-number procedure returns the serial number of object obj . This serial number is only allocated the first time the object->serial-number procedure is called on that object. Objects which do not have an external textual representation that can be read by the read procedure, use an external textual representation that includes a serial number of the form #n . Consequently, the procedures write , pretty-print , etc will call the object->serial-number procedure to get the serial number, and this may cause the serial number to be allocated. The serial-number->object procedure takes an exact integer parameter n and returns the object whose serial number is n . If no object currently exists with that serial number, default is returned if it is specified, otherwise an unbound-serial-number-exception object is raised. The reader defines the following abbreviation for calling serial-number->object : the syntax #n , where n is a sequence of decimal digits and it is not followed by = or # , is equivalent to the list (serial-number->object n) . For example: > (define z (list (lambda (x) (* x x)) (lambda (y) (/ 1 y)))) > z (#<procedure #2> #<procedure #3>) > (#3 10) 1/10 > '(#3 10) ((serial-number->object 3) 10) > car #<procedure #4 car> > (#4 z) #<procedure #2> unbound-serial-number-exception? unbound-serial-number-exception-procedure unbound-serial-number-exception-arguments (unbound-serial-number-exception? obj) ;; procedure (unbound-serial-number-exception-procedure exc) ;; procedure (unbound-serial-number-exception-arguments exc) ;; procedure Unbound-serial-number-exception objects are raised by the procedure serial-number->object when no object currently exists with that serial number. The parameter exc must be an unbound-serial-number-exception object. The procedure unbound-serial-number-exception? returns #t when obj is a unbound-serial-number-exception object and #f otherwise. The procedure unbound-serial-number-exception-procedure returns the procedure that raised exc . The procedure unbound-serial-number-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define (handler exc) (if (unbound-serial-number-exception? exc) (list (unbound-serial-number-exception-procedure exc) (unbound-serial-number-exception-arguments exc)) 'not-unbound-serial-number-exception)) > (with-exception-catcher handler (lambda () (serial-number->object 1000))) (#<procedure #2 serial-number->object> (1000)) symbol-hash (symbol-hash symbol) ;; procedure The symbol-hash procedure returns the hash number of the symbol symbol . The hash number is a small exact integer (fixnum). When symbol is an interned symbol the value returned is the same as (string=?-hash (symbol->string symbol)) . For example: > (symbol-hash 'car) 444471047 keyword-hash (keyword-hash keyword) ;; procedure The keyword-hash procedure returns the hash number of the keyword keyword . The hash number is a small exact integer (fixnum). When keyword is an interned keyword the value returned is the same as (string=?-hash (keyword->string keyword)) . For example: > (keyword-hash car:) 444471047 string=?-hash (string=?-hash string) procedure The string=?-hash procedure returns the hash number of the string string . The hash number is a small exact integer (fixnum). For any two strings s1 and s2 , (string=? s1 s2) implies (= (string=?-hash s1) (string=?-hash s2)) . For example: > (string=?-hash \"car\") 444471047 string-ci=?-hash (string-ci=?-hash string) ;; procedure The string-ci=?-hash procedure returns the hash number of the string string . The hash number is a small exact integer (fixnum). For any two strings s1 and s2 , (string-ci=? s1 s2) implies (= (string-ci=?-hash s1) (string-ci=?-hash s2)) . For example: > (string-ci=?-hash \"CaR\") 444471047 eq?-hash (eq?-hash obj) procedure The eq?-hash procedure returns the hash number of the object obj . The hash number is a small exact integer (fixnum). For any two objects o1 and o2 , (eq? o1 o2) implies (= (eq?-hash o1) (eq?-hash o2)) . For example: > (eq?-hash #t) 536870910 eqv?-hash (eqv?-hash obj) ;; procedure The eqv?-hash procedure returns the hash number of the object obj . The hash number is a small exact integer (fixnum). For any two objects o1 and o2 , (eqv? o1 o2) implies (= (eqv?-hash o1) (eqv?-hash o2)) . For example: > (eqv?-hash 1.5) 496387656 equal?-hash (equal?-hash obj) ;; procedure The equal?-hash procedure returns the hash number of the object obj . The hash number is a small exact integer (fixnum). For any two objects o1 and o2 , (equal? o1 o2) implies (= (equal?-hash o1) (equal?-hash o2)) . For example: > (equal?-hash (list 1 2 3)) 442438567 Weak references The garbage collector is responsible for reclaiming objects that are no longer needed by the program. This is done by analyzing the reachability graph of all objects from the roots (i.e. the global variables, the runnable threads, permanently allocated objects such as procedures defined in a compiled file, nonexecutable wills, etc). If a root or a reachable object X contains a reference to an object Y then Y is reachable. As a general rule, unreachable objects are reclaimed by the garbage collector. There are two types of references: strong references and weak references. Most objects, including pairs, vectors, records and closures, contain strong references. An object X is strongly reachable if there is a path from the roots to X that traverses only strong references. Weak references only occur in wills and tables. There are two types of weak references: will-weak references and table-weak references. If all paths from the roots to an object Y traverse at least one table-weak reference, then Y will be reclaimed by the garbage collector. The will-weak references are used for finalization and are explained in the next section. Wills The following procedures implement the will data type. Will objects provide support for finalization. A will is an object that contains a will-weak reference to a testator object (the object attached to the will), and a strong reference to an action procedure which is a one parameter procedure which is called when the will is executed. make-will will? will-testator will-execute! (make-will testator action) ;; procedure (will? obj) ;; procedure (will-testator will) ;; procedure (will-execute! will) ;; procedure The make-will procedure creates a will object with the given testator object and action procedure. The will? procedure tests if obj is a will object. The will-testator procedure gets the testator object attached to the will . The will-execute! procedure executes will . A will becomes executable when its testator object is not strongly reachable (i.e. the testator object is either unreachable or only reachable using paths from the roots that traverse at least one weak reference). Some objects, including symbols, small exact integers (fixnums), booleans and characters, are considered to be always strongly reachable. When the runtime system detects that a will has become executable the current computation is interrupted, the will's testator is set to #f and the will's action procedure is called with the will's testator as the sole argument. Currently only the garbage collector detects when wills become executable but this may change in future versions of Gambit (for example the compiler could perform an analysis to infer will executability at compile time). The garbage collector builds a list of all executable wills. Shortly after a garbage collection, the action procedures of these wills will be called. The link from the will to the action procedure is severed when the action procedure is called. Note that the testator object will not be reclaimed during the garbage collection that determined executability of the will. It is only when an object is not reachable from the roots that it is reclaimed by the garbage collector. A remarkable feature of wills is that an action procedure can \"resurrect\" an object. An action procedure could for example assign the testator object to a global variable or create a new will with the same testator object. For example: > (define a (list 123)) > (set-cdr! a a) ; create a circular list > (define b (vector a)) > (define c #f) > (define w (let ((obj a)) (make-will obj (lambda (x) ; x will be eq? to obj (display \"executing action procedure\") (newline) (set! c x))))) > (will? w) #t > (car (will-testator w)) 123 > (##gc) > (set! a #f) > (##gc) > (set! b #f) > (##gc) executing action procedure > (will-testator w) #f > (car c) 123 Tables The following procedures implement the table data type. Tables are heterogenous structures whose elements are indexed by keys which are arbitrary objects. Tables are similar to association lists but are abstract and the access time for large tables is typically smaller. Each key contained in the table is bound to a value. The length of the table is the number of key/value bindings it contains. New key/value bindings can be added to a table, the value bound to a key can be changed, and existing key/value bindings can be removed. The references to the keys can either be all strong or all table-weak and the references to the values can either be all strong or all table-weak. The garbage collector removes key/value bindings from a table when 1) the key is a table-weak reference and the key is unreachable or only reachable using paths from the roots that traverse at least one table-weak reference, or 2) the value is a table-weak reference and the value is unreachable or only reachable using paths from the roots that traverse at least one table-weak reference. Key/value bindings that are removed by the garbage collector are reclaimed immediately. Although there are several possible ways of implementing tables, the current implementation uses hashing with open-addressing. This is space efficient and provides constant-time access. Hash tables are automatically resized to maintain the load within specified bounds. The load is the number of active entries (the length of the table) divided by the total number of entries in the hash table. Tables are parameterized with a key comparison procedure. By default the equal? procedure is used, but eq? , eqv? , string=? , string-ci=? , or a user defined procedure can also be used. To support arbitrary key comparison procedures, tables are also parameterized with a hashing procedure accepting a key as its single parameter and returning a fixnum result. The hashing procedure hash must be consistent with the key comparison procedure test , that is, for any two keys k1 and k2 in the table, (test k1 k2) implies (= (hash k1) (hash k2)) . A default hashing procedure consistent with the key comparison procedure is provided by the system. The default hashing procedure generally gives good performance when the key comparison procedure is eq? , eqv? , equal? , string=? , and string-ci=? . However, for user defined key comparison procedures, the default hashing procedure always returns 0. This degrades the performance of the table to a linear search. Tables can be compared for equality using the equal? procedure. Two tables X and Y are considered equal by equal? when they have the same weakness attributes, the same key comparison procedure, the same hashing procedure, the same length, and for all the keys k in X , (equal? (table-ref X k) (table-ref Y k)) . make-table (make-table [size: size] [init: init] [weak-keys: weak-keys] [weak-values: weak-values] [test: test] [hash: hash] [min-load: min-load] [max-load: max-load]) ;; procedure The procedure make-table returns a new table. The optional keyword parameters specify various parameters of the table. The size parameter is a nonnegative exact integer indicating the expected length of the table. The system uses size to choose an appropriate initial size of the hash table so that it does not need to be resized too often. The init parameter indicates a value that is associated to keys that are not in the table. When init is not specified, no value is associated to keys that are not in the table. The weak-keys and weak-values parameters are extended booleans indicating respectively whether the keys and values are table-weak references (true) or strong references (false). By default the keys and values are strong references. The test parameter indicates the key comparison procedure. The default key comparison procedure is equal? . The key comparison procedures eq? , eqv? , equal? , string=? , and string-ci=? are special because the system will use a reasonably good hash procedure when none is specified. The hash parameter indicates the hash procedure. This procedure must accept a single key parameter, return a fixnum, and be consistent with the key comparison procedure. When hash is not specified, a default hash procedure is used. The default hash procedure is reasonably good when the key comparison procedure is eq? , eqv? , equal? , string=? , or string-ci=? . The min-load and max-load parameters are real numbers that indicate the minimum and maximum load of the table respectively. The table is resized when adding or deleting a key/value binding would bring the table's load outside of this range. The min-load parameter must be no less than 0.05 and the max-load parameter must be no greater than 0.95 . Moreover the difference between min-load and max-load must be at least 0.20 . When min-load is not specified, the value 0.45 is used. When max-load is not specified, the value 0.90 is used. For example: > (define t (make-table)) > (table? t) #t > (table-length t) 0 > (table-set! t (list 1 2) 3) > (table-set! t (list 4 5) 6) > (table-ref t (list 1 2)) 3 > (table-length t) 2 table? (table? obj) ;; procedure The procedure table? returns #t when obj is a table and #f otherwise. For example: > (table? (make-table)) #t > (table? 123) #f table-length (table-length table) ;; procedure The procedure table-length returns the number of key/value bindings contained in the table table . For example: > (define t (make-table weak-keys: #t)) > (define x (list 1 2)) > (define y (list 3 4)) > (table-set! t x 111) > (table-set! t y 222) > (table-length t) 2 > (table-set! t x) > (table-length t) 1 > (##gc) > (table-length t) 1 > (set! y #f) > (##gc) > (table-length t) 0 (table-ref table key [default]) ;; procedure The procedure table-ref returns the value bound to the object key in the table table . When key is not bound and default is specified, default is returned. When default is not specified but an init parameter was specified when table was created, init is returned. Otherwise an unbound-key-exception object is raised. For example: > (define t1 (make-table init: 999)) > (table-set! t1 (list 1 2) 3) > (table-ref t1 (list 1 2)) 3 > (table-ref t1 (list 4 5)) 999 > (table-ref t1 (list 4 5) #f) #f > (define t2 (make-table)) > (table-ref t2 (list 4 5)) *** ERROR IN (console)@7.1 -- Unbound key (table-ref '#<table #2> '(4 5)) table-set! (table-set! table key [value]) ;; procedure The procedure table-set! binds the object key to value in the table table . When value is not specified, if table contains a binding for key then the binding is removed from table. The procedure table-set! returns an unspecified value. For example: > (define t (make-table)) > (table-set! t (list 1 2) 3) > (table-set! t (list 4 5) 6) > (table-set! t (list 4 5)) > (table-set! t (list 7 8)) > (table-ref t (list 1 2)) 3 > (table-ref t (list 4 5)) *** ERROR IN (console)@7.1 -- Unbound key (table-ref '#<table #2> '(4 5)) table-search (table-search proc table) ;; procedure The procedure table-search searches the table table for a key/value binding for which the two parameter procedure proc returns a non false result. For each key/value binding visited by table-search the procedure proc is called with the key as the first parameter and the value as the second parameter. The procedure table-search returns the first non false value returned by proc , or #f if proc returned #f for all key/value bindings in table . The order in which the key/value bindings are visited is unspecified and may vary from one call of table-search to the next. While a call to table-search is being performed on table , it is an error to call any of the following procedures on table : table-ref , table-set! , table-search , table-for-each , table-copy , table-merge , table-merge! , and table->list . It is also an error to compare with equal? (directly or indirectly with member , assoc , table-ref , etc.) an object that contains table . All these procedures may cause table to be reordered and resized. This restriction allows a more efficient iteration over the key/value bindings. For example: > (define square (make-table)) > (table-set! square 2 4) > (table-set! square 3 9) > (table-search (lambda (k v) (and (odd? k) v)) square) 9 table-for-each (table-for-each proc table) ;; procedure The procedure table-for-each calls the two parameter procedure proc for each key/value binding in the table table . The procedure proc is called with the key as the first parameter and the value as the second parameter. The procedure table-for-each returns an unspecified value. The order in which the key/value bindings are visited is unspecified and may vary from one call of table-for-each to the next. While a call to table-for-each is being performed on table , it is an error to call any of the following procedures on table : table-ref , table-set! , table-search , table-for-each , and table->list . It is also an error to compare with equal? (directly or indirectly with member , assoc , table-ref , etc.) an object that contains table . All these procedures may cause table to be reordered and resized. This restriction allows a more efficient iteration over the key/value bindings. For example: > (define square (make-table)) > (table-set! square 2 4) > (table-set! square 3 9) > (table-for-each (lambda (k v) (write (list k v)) (newline)) square) (2 4) (3 9) table->list (table->list table) ;; procedure The procedure table->list returns an association list containing the key/value bindings in the table table . Each key/value binding yields a pair whose car field is the key and whose cdr field is the value bound to that key . The order of the bindings in the list is unspecified. For example: > (define square (make-table)) > (table-set! square 2 4) > (table-set! square 3 9) > (table->list square) ((3 . 9) (2 . 4)) list->table (list->table list [size: size] [init: init] [weak-keys: weak-keys] [weak-values: weak-values] [test: test] [hash: hash] [min-load: min-load] [max-load: max-load]) ;; procedure The procedure list->table returns a new table containing the key/value bindings in the association list list . The optional keyword parameters specify various parameters of the table and have the same meaning as for the make-table procedure. Each element of list is a pair whose car field is a key and whose cdr field is the value bound to that key . If a key appears more than once in list (tested using the table's key comparison procedure) it is the first key/value binding in list that has precedence. For example: > (define t (list->table '((b . 2) (a . 1) (c . 3) (a . 4)))) > (table->list t) ((a . 1) (b . 2) (c . 3)) unbound-key-exception? unbound-key-exception-procedure unbound-key-exceptionarguments (unbound-key-exception? obj) ;; procedure (unbound-key-exception-procedure exc) ;; procedure (unbound-key-exception-arguments exc) ;; procedure Unbound-key-exception objects are raised by the procedure table-ref when the key does not have a binding in the table. The parameter exc must be an unbound-key-exception object. The procedure unbound-key-exception? returns #t when obj is a unbound-key-exception object and #f otherwise. The procedure unbound-key-exception-procedure returns the procedure that raised exc . The procedure unbound-key-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define t (make-table)) > (define (handler exc) (if (unbound-key-exception? exc) (list (unbound-key-exception-procedure exc) (unbound-key-exception-arguments exc)) 'not-unbound-key-exception)) > (with-exception-catcher handler (lambda () (table-ref t '(1 2)))) (#<procedure #2 table-ref> (#<table #3> (1 2))) table-copy (table-copy table) procedure The procedure table-copy returns a new table containing the same key/value bindings as table and the same table parameters (i.e. hash procedure, key comparison procedure, key and value weakness, etc). For example: > (define t (list->table '((b . 2) (a . 1) (c . 3)))) > (define x (table-copy t)) > (table-set! t 'b 99) > (table->list t) ((a . 1) (b . 99) (c . 3)) > (table->list x) ((a . 1) (b . 2) (c . 3)) table-merge! (table-merge! table1 table2 [table2-takes-precedence?]) ;; procedure The procedure table-merge! returns table1 after the key/value bindings contained in table2 have been added to it. When a key exists both in table1 and table2 , then the parameter table2-takes-precedence? indicates which binding will be kept (the one in table1 if table2-takes-precedence? is false, and the one in table2 otherwise). If table2-takes-precedence? is not specified the binding in table1 is kept. For example: > (define t1 (list->table '((a . 1) (b . 2) (c . 3)))) > (define t2 (list->table '((a . 4) (b . 5) (z . 6)))) > (table->list (table-merge! t1 t2)) ((a . 1) (b . 2) (c . 3) (z . 6)) > (define t1 (list->table '((a . 1) (b . 2) (c . 3)))) > (define t2 (list->table '((a . 4) (b . 5) (z . 6)))) > (table->list (table-merge! t1 t2 #t)) ((a . 4) (b . 5) (c . 3) (z . 6)) table-merge (table-merge table1 table2 [table2-takes-precedence?]) ;; procedure The procedure table-merge returns a copy of table1 (created with table-copy ) to which the key/value bindings contained in table2 have been added using table-merge! . When a key exists both in table1 and table2 , then the parameter table2-takes-precedence? indicates which binding will be kept (the one in table1 if table2-takes-precedence? is false, and the one in table2 otherwise). If table2-takes-precedence? is not specified the binding in table1 is kept. For example: > (define t1 (list->table '((a . 1) (b . 2) (c . 3)))) > (define t2 (list->table '((a . 4) (b . 5) (z . 6)))) > (table->list (table-merge t1 t2)) ((a . 1) (b . 2) (c . 3) (z . 6)) > (table->list (table-merge t1 t2 #t)) ((a . 4) (b . 5) (c . 3) (z . 6))","title":"Hashing and weak references"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#hashing-and-weak-references","text":"","title":"Hashing and weak references"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#hashing","text":"","title":"Hashing"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#object-serial-number","text":"","title":"object-&gt;serial-number"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#serial-number-object","text":"(object->serial-number obj) ;; procedure (serial-number->object n [default]) ;; procedure All Scheme objects are uniquely identified with a serial number which is a nonnegative exact integer. The object->serial-number procedure returns the serial number of object obj . This serial number is only allocated the first time the object->serial-number procedure is called on that object. Objects which do not have an external textual representation that can be read by the read procedure, use an external textual representation that includes a serial number of the form #n . Consequently, the procedures write , pretty-print , etc will call the object->serial-number procedure to get the serial number, and this may cause the serial number to be allocated. The serial-number->object procedure takes an exact integer parameter n and returns the object whose serial number is n . If no object currently exists with that serial number, default is returned if it is specified, otherwise an unbound-serial-number-exception object is raised. The reader defines the following abbreviation for calling serial-number->object : the syntax #n , where n is a sequence of decimal digits and it is not followed by = or # , is equivalent to the list (serial-number->object n) . For example: > (define z (list (lambda (x) (* x x)) (lambda (y) (/ 1 y)))) > z (#<procedure #2> #<procedure #3>) > (#3 10) 1/10 > '(#3 10) ((serial-number->object 3) 10) > car #<procedure #4 car> > (#4 z) #<procedure #2>","title":"serial-number-&gt;object"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#unbound-serial-number-exception","text":"","title":"unbound-serial-number-exception?"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#unbound-serial-number-exception-procedure","text":"","title":"unbound-serial-number-exception-procedure"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#unbound-serial-number-exception-arguments","text":"(unbound-serial-number-exception? obj) ;; procedure (unbound-serial-number-exception-procedure exc) ;; procedure (unbound-serial-number-exception-arguments exc) ;; procedure Unbound-serial-number-exception objects are raised by the procedure serial-number->object when no object currently exists with that serial number. The parameter exc must be an unbound-serial-number-exception object. The procedure unbound-serial-number-exception? returns #t when obj is a unbound-serial-number-exception object and #f otherwise. The procedure unbound-serial-number-exception-procedure returns the procedure that raised exc . The procedure unbound-serial-number-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define (handler exc) (if (unbound-serial-number-exception? exc) (list (unbound-serial-number-exception-procedure exc) (unbound-serial-number-exception-arguments exc)) 'not-unbound-serial-number-exception)) > (with-exception-catcher handler (lambda () (serial-number->object 1000))) (#<procedure #2 serial-number->object> (1000))","title":"unbound-serial-number-exception-arguments"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#symbol-hash","text":"(symbol-hash symbol) ;; procedure The symbol-hash procedure returns the hash number of the symbol symbol . The hash number is a small exact integer (fixnum). When symbol is an interned symbol the value returned is the same as (string=?-hash (symbol->string symbol)) . For example: > (symbol-hash 'car) 444471047","title":"symbol-hash"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#keyword-hash","text":"(keyword-hash keyword) ;; procedure The keyword-hash procedure returns the hash number of the keyword keyword . The hash number is a small exact integer (fixnum). When keyword is an interned keyword the value returned is the same as (string=?-hash (keyword->string keyword)) . For example: > (keyword-hash car:) 444471047","title":"keyword-hash"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#string-hash","text":"(string=?-hash string) procedure The string=?-hash procedure returns the hash number of the string string . The hash number is a small exact integer (fixnum). For any two strings s1 and s2 , (string=? s1 s2) implies (= (string=?-hash s1) (string=?-hash s2)) . For example: > (string=?-hash \"car\") 444471047","title":"string=?-hash"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#string-ci-hash","text":"(string-ci=?-hash string) ;; procedure The string-ci=?-hash procedure returns the hash number of the string string . The hash number is a small exact integer (fixnum). For any two strings s1 and s2 , (string-ci=? s1 s2) implies (= (string-ci=?-hash s1) (string-ci=?-hash s2)) . For example: > (string-ci=?-hash \"CaR\") 444471047","title":"string-ci=?-hash"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#eq-hash","text":"(eq?-hash obj) procedure The eq?-hash procedure returns the hash number of the object obj . The hash number is a small exact integer (fixnum). For any two objects o1 and o2 , (eq? o1 o2) implies (= (eq?-hash o1) (eq?-hash o2)) . For example: > (eq?-hash #t) 536870910","title":"eq?-hash"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#eqv-hash","text":"(eqv?-hash obj) ;; procedure The eqv?-hash procedure returns the hash number of the object obj . The hash number is a small exact integer (fixnum). For any two objects o1 and o2 , (eqv? o1 o2) implies (= (eqv?-hash o1) (eqv?-hash o2)) . For example: > (eqv?-hash 1.5) 496387656","title":"eqv?-hash"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#equal-hash","text":"(equal?-hash obj) ;; procedure The equal?-hash procedure returns the hash number of the object obj . The hash number is a small exact integer (fixnum). For any two objects o1 and o2 , (equal? o1 o2) implies (= (equal?-hash o1) (equal?-hash o2)) . For example: > (equal?-hash (list 1 2 3)) 442438567","title":"equal?-hash"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#weak-references","text":"The garbage collector is responsible for reclaiming objects that are no longer needed by the program. This is done by analyzing the reachability graph of all objects from the roots (i.e. the global variables, the runnable threads, permanently allocated objects such as procedures defined in a compiled file, nonexecutable wills, etc). If a root or a reachable object X contains a reference to an object Y then Y is reachable. As a general rule, unreachable objects are reclaimed by the garbage collector. There are two types of references: strong references and weak references. Most objects, including pairs, vectors, records and closures, contain strong references. An object X is strongly reachable if there is a path from the roots to X that traverses only strong references. Weak references only occur in wills and tables. There are two types of weak references: will-weak references and table-weak references. If all paths from the roots to an object Y traverse at least one table-weak reference, then Y will be reclaimed by the garbage collector. The will-weak references are used for finalization and are explained in the next section.","title":"Weak references"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#wills","text":"The following procedures implement the will data type. Will objects provide support for finalization. A will is an object that contains a will-weak reference to a testator object (the object attached to the will), and a strong reference to an action procedure which is a one parameter procedure which is called when the will is executed.","title":"Wills"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#make-will","text":"","title":"make-will"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#will","text":"","title":"will?"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#will-testator","text":"","title":"will-testator"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#will-execute","text":"(make-will testator action) ;; procedure (will? obj) ;; procedure (will-testator will) ;; procedure (will-execute! will) ;; procedure The make-will procedure creates a will object with the given testator object and action procedure. The will? procedure tests if obj is a will object. The will-testator procedure gets the testator object attached to the will . The will-execute! procedure executes will . A will becomes executable when its testator object is not strongly reachable (i.e. the testator object is either unreachable or only reachable using paths from the roots that traverse at least one weak reference). Some objects, including symbols, small exact integers (fixnums), booleans and characters, are considered to be always strongly reachable. When the runtime system detects that a will has become executable the current computation is interrupted, the will's testator is set to #f and the will's action procedure is called with the will's testator as the sole argument. Currently only the garbage collector detects when wills become executable but this may change in future versions of Gambit (for example the compiler could perform an analysis to infer will executability at compile time). The garbage collector builds a list of all executable wills. Shortly after a garbage collection, the action procedures of these wills will be called. The link from the will to the action procedure is severed when the action procedure is called. Note that the testator object will not be reclaimed during the garbage collection that determined executability of the will. It is only when an object is not reachable from the roots that it is reclaimed by the garbage collector. A remarkable feature of wills is that an action procedure can \"resurrect\" an object. An action procedure could for example assign the testator object to a global variable or create a new will with the same testator object. For example: > (define a (list 123)) > (set-cdr! a a) ; create a circular list > (define b (vector a)) > (define c #f) > (define w (let ((obj a)) (make-will obj (lambda (x) ; x will be eq? to obj (display \"executing action procedure\") (newline) (set! c x))))) > (will? w) #t > (car (will-testator w)) 123 > (##gc) > (set! a #f) > (##gc) > (set! b #f) > (##gc) executing action procedure > (will-testator w) #f > (car c) 123","title":"will-execute!"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#tables","text":"The following procedures implement the table data type. Tables are heterogenous structures whose elements are indexed by keys which are arbitrary objects. Tables are similar to association lists but are abstract and the access time for large tables is typically smaller. Each key contained in the table is bound to a value. The length of the table is the number of key/value bindings it contains. New key/value bindings can be added to a table, the value bound to a key can be changed, and existing key/value bindings can be removed. The references to the keys can either be all strong or all table-weak and the references to the values can either be all strong or all table-weak. The garbage collector removes key/value bindings from a table when 1) the key is a table-weak reference and the key is unreachable or only reachable using paths from the roots that traverse at least one table-weak reference, or 2) the value is a table-weak reference and the value is unreachable or only reachable using paths from the roots that traverse at least one table-weak reference. Key/value bindings that are removed by the garbage collector are reclaimed immediately. Although there are several possible ways of implementing tables, the current implementation uses hashing with open-addressing. This is space efficient and provides constant-time access. Hash tables are automatically resized to maintain the load within specified bounds. The load is the number of active entries (the length of the table) divided by the total number of entries in the hash table. Tables are parameterized with a key comparison procedure. By default the equal? procedure is used, but eq? , eqv? , string=? , string-ci=? , or a user defined procedure can also be used. To support arbitrary key comparison procedures, tables are also parameterized with a hashing procedure accepting a key as its single parameter and returning a fixnum result. The hashing procedure hash must be consistent with the key comparison procedure test , that is, for any two keys k1 and k2 in the table, (test k1 k2) implies (= (hash k1) (hash k2)) . A default hashing procedure consistent with the key comparison procedure is provided by the system. The default hashing procedure generally gives good performance when the key comparison procedure is eq? , eqv? , equal? , string=? , and string-ci=? . However, for user defined key comparison procedures, the default hashing procedure always returns 0. This degrades the performance of the table to a linear search. Tables can be compared for equality using the equal? procedure. Two tables X and Y are considered equal by equal? when they have the same weakness attributes, the same key comparison procedure, the same hashing procedure, the same length, and for all the keys k in X , (equal? (table-ref X k) (table-ref Y k)) .","title":"Tables"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#make-table","text":"(make-table [size: size] [init: init] [weak-keys: weak-keys] [weak-values: weak-values] [test: test] [hash: hash] [min-load: min-load] [max-load: max-load]) ;; procedure The procedure make-table returns a new table. The optional keyword parameters specify various parameters of the table. The size parameter is a nonnegative exact integer indicating the expected length of the table. The system uses size to choose an appropriate initial size of the hash table so that it does not need to be resized too often. The init parameter indicates a value that is associated to keys that are not in the table. When init is not specified, no value is associated to keys that are not in the table. The weak-keys and weak-values parameters are extended booleans indicating respectively whether the keys and values are table-weak references (true) or strong references (false). By default the keys and values are strong references. The test parameter indicates the key comparison procedure. The default key comparison procedure is equal? . The key comparison procedures eq? , eqv? , equal? , string=? , and string-ci=? are special because the system will use a reasonably good hash procedure when none is specified. The hash parameter indicates the hash procedure. This procedure must accept a single key parameter, return a fixnum, and be consistent with the key comparison procedure. When hash is not specified, a default hash procedure is used. The default hash procedure is reasonably good when the key comparison procedure is eq? , eqv? , equal? , string=? , or string-ci=? . The min-load and max-load parameters are real numbers that indicate the minimum and maximum load of the table respectively. The table is resized when adding or deleting a key/value binding would bring the table's load outside of this range. The min-load parameter must be no less than 0.05 and the max-load parameter must be no greater than 0.95 . Moreover the difference between min-load and max-load must be at least 0.20 . When min-load is not specified, the value 0.45 is used. When max-load is not specified, the value 0.90 is used. For example: > (define t (make-table)) > (table? t) #t > (table-length t) 0 > (table-set! t (list 1 2) 3) > (table-set! t (list 4 5) 6) > (table-ref t (list 1 2)) 3 > (table-length t) 2","title":"make-table"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table","text":"(table? obj) ;; procedure The procedure table? returns #t when obj is a table and #f otherwise. For example: > (table? (make-table)) #t > (table? 123) #f","title":"table?"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-length","text":"(table-length table) ;; procedure The procedure table-length returns the number of key/value bindings contained in the table table . For example: > (define t (make-table weak-keys: #t)) > (define x (list 1 2)) > (define y (list 3 4)) > (table-set! t x 111) > (table-set! t y 222) > (table-length t) 2 > (table-set! t x) > (table-length t) 1 > (##gc) > (table-length t) 1 > (set! y #f) > (##gc) > (table-length t) 0 (table-ref table key [default]) ;; procedure The procedure table-ref returns the value bound to the object key in the table table . When key is not bound and default is specified, default is returned. When default is not specified but an init parameter was specified when table was created, init is returned. Otherwise an unbound-key-exception object is raised. For example: > (define t1 (make-table init: 999)) > (table-set! t1 (list 1 2) 3) > (table-ref t1 (list 1 2)) 3 > (table-ref t1 (list 4 5)) 999 > (table-ref t1 (list 4 5) #f) #f > (define t2 (make-table)) > (table-ref t2 (list 4 5)) *** ERROR IN (console)@7.1 -- Unbound key (table-ref '#<table #2> '(4 5))","title":"table-length"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-set","text":"(table-set! table key [value]) ;; procedure The procedure table-set! binds the object key to value in the table table . When value is not specified, if table contains a binding for key then the binding is removed from table. The procedure table-set! returns an unspecified value. For example: > (define t (make-table)) > (table-set! t (list 1 2) 3) > (table-set! t (list 4 5) 6) > (table-set! t (list 4 5)) > (table-set! t (list 7 8)) > (table-ref t (list 1 2)) 3 > (table-ref t (list 4 5)) *** ERROR IN (console)@7.1 -- Unbound key (table-ref '#<table #2> '(4 5))","title":"table-set!"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-search","text":"(table-search proc table) ;; procedure The procedure table-search searches the table table for a key/value binding for which the two parameter procedure proc returns a non false result. For each key/value binding visited by table-search the procedure proc is called with the key as the first parameter and the value as the second parameter. The procedure table-search returns the first non false value returned by proc , or #f if proc returned #f for all key/value bindings in table . The order in which the key/value bindings are visited is unspecified and may vary from one call of table-search to the next. While a call to table-search is being performed on table , it is an error to call any of the following procedures on table : table-ref , table-set! , table-search , table-for-each , table-copy , table-merge , table-merge! , and table->list . It is also an error to compare with equal? (directly or indirectly with member , assoc , table-ref , etc.) an object that contains table . All these procedures may cause table to be reordered and resized. This restriction allows a more efficient iteration over the key/value bindings. For example: > (define square (make-table)) > (table-set! square 2 4) > (table-set! square 3 9) > (table-search (lambda (k v) (and (odd? k) v)) square) 9","title":"table-search"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-for-each","text":"(table-for-each proc table) ;; procedure The procedure table-for-each calls the two parameter procedure proc for each key/value binding in the table table . The procedure proc is called with the key as the first parameter and the value as the second parameter. The procedure table-for-each returns an unspecified value. The order in which the key/value bindings are visited is unspecified and may vary from one call of table-for-each to the next. While a call to table-for-each is being performed on table , it is an error to call any of the following procedures on table : table-ref , table-set! , table-search , table-for-each , and table->list . It is also an error to compare with equal? (directly or indirectly with member , assoc , table-ref , etc.) an object that contains table . All these procedures may cause table to be reordered and resized. This restriction allows a more efficient iteration over the key/value bindings. For example: > (define square (make-table)) > (table-set! square 2 4) > (table-set! square 3 9) > (table-for-each (lambda (k v) (write (list k v)) (newline)) square) (2 4) (3 9)","title":"table-for-each"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-list","text":"(table->list table) ;; procedure The procedure table->list returns an association list containing the key/value bindings in the table table . Each key/value binding yields a pair whose car field is the key and whose cdr field is the value bound to that key . The order of the bindings in the list is unspecified. For example: > (define square (make-table)) > (table-set! square 2 4) > (table-set! square 3 9) > (table->list square) ((3 . 9) (2 . 4))","title":"table-&gt;list"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#list-table","text":"(list->table list [size: size] [init: init] [weak-keys: weak-keys] [weak-values: weak-values] [test: test] [hash: hash] [min-load: min-load] [max-load: max-load]) ;; procedure The procedure list->table returns a new table containing the key/value bindings in the association list list . The optional keyword parameters specify various parameters of the table and have the same meaning as for the make-table procedure. Each element of list is a pair whose car field is a key and whose cdr field is the value bound to that key . If a key appears more than once in list (tested using the table's key comparison procedure) it is the first key/value binding in list that has precedence. For example: > (define t (list->table '((b . 2) (a . 1) (c . 3) (a . 4)))) > (table->list t) ((a . 1) (b . 2) (c . 3))","title":"list-&gt;table"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#unbound-key-exception","text":"","title":"unbound-key-exception?"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#unbound-key-exception-procedure","text":"","title":"unbound-key-exception-procedure"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#unbound-key-exceptionarguments","text":"(unbound-key-exception? obj) ;; procedure (unbound-key-exception-procedure exc) ;; procedure (unbound-key-exception-arguments exc) ;; procedure Unbound-key-exception objects are raised by the procedure table-ref when the key does not have a binding in the table. The parameter exc must be an unbound-key-exception object. The procedure unbound-key-exception? returns #t when obj is a unbound-key-exception object and #f otherwise. The procedure unbound-key-exception-procedure returns the procedure that raised exc . The procedure unbound-key-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define t (make-table)) > (define (handler exc) (if (unbound-key-exception? exc) (list (unbound-key-exception-procedure exc) (unbound-key-exception-arguments exc)) 'not-unbound-key-exception)) > (with-exception-catcher handler (lambda () (table-ref t '(1 2)))) (#<procedure #2 table-ref> (#<table #3> (1 2)))","title":"unbound-key-exceptionarguments"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-copy","text":"(table-copy table) procedure The procedure table-copy returns a new table containing the same key/value bindings as table and the same table parameters (i.e. hash procedure, key comparison procedure, key and value weakness, etc). For example: > (define t (list->table '((b . 2) (a . 1) (c . 3)))) > (define x (table-copy t)) > (table-set! t 'b 99) > (table->list t) ((a . 1) (b . 99) (c . 3)) > (table->list x) ((a . 1) (b . 2) (c . 3))","title":"table-copy"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-merge","text":"(table-merge! table1 table2 [table2-takes-precedence?]) ;; procedure The procedure table-merge! returns table1 after the key/value bindings contained in table2 have been added to it. When a key exists both in table1 and table2 , then the parameter table2-takes-precedence? indicates which binding will be kept (the one in table1 if table2-takes-precedence? is false, and the one in table2 otherwise). If table2-takes-precedence? is not specified the binding in table1 is kept. For example: > (define t1 (list->table '((a . 1) (b . 2) (c . 3)))) > (define t2 (list->table '((a . 4) (b . 5) (z . 6)))) > (table->list (table-merge! t1 t2)) ((a . 1) (b . 2) (c . 3) (z . 6)) > (define t1 (list->table '((a . 1) (b . 2) (c . 3)))) > (define t2 (list->table '((a . 4) (b . 5) (z . 6)))) > (table->list (table-merge! t1 t2 #t)) ((a . 4) (b . 5) (c . 3) (z . 6))","title":"table-merge!"},{"location":"manual/built_in_data_types/hashing_and_weak_references/#table-merge_1","text":"(table-merge table1 table2 [table2-takes-precedence?]) ;; procedure The procedure table-merge returns a copy of table1 (created with table-copy ) to which the key/value bindings contained in table2 have been added using table-merge! . When a key exists both in table1 and table2 , then the parameter table2-takes-precedence? indicates which binding will be kept (the one in table1 if table2-takes-precedence? is false, and the one in table2 otherwise). If table2-takes-precedence? is not specified the binding in table1 is kept. For example: > (define t1 (list->table '((a . 1) (b . 2) (c . 3)))) > (define t2 (list->table '((a . 4) (b . 5) (z . 6)))) > (table->list (table-merge t1 t2)) ((a . 1) (b . 2) (c . 3) (z . 6)) > (table->list (table-merge t1 t2 #t)) ((a . 4) (b . 5) (c . 3) (z . 6))","title":"table-merge"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/","text":"Homogeneous numeric vectors Homogeneous vectors are vectors containing raw numbers of the same type (signed or unsigned exact integers or inexact reals). There are 10 types of homogeneous vectors: s8vector : vector of exact integers in the range -2^7 to 2^7-1 u8vector : vector of exact integers in the range 0 to 2^8-1 s16vector : vector of exact integers in the range -2^15 to 2^15-1 u16vector : vector of exact integers in the range 0 to 2^16-1 s32vector : vector of exact integers in the range -2^31 to 2^31-1 u32vector : vector of exact integers in the range 0 to 2^32-1 s64vector : vector of exact integers in the range -2^63 to 2^63-1 u64vector : vector of exact integers in the range 0 to 2^64-1 f32vector : vector of 32 bit floating point numbers f64vector : vector of 64 bit floating point numbers The lexical syntax of homogeneous vectors is specified in Homogeneous vector syntax . The procedures available for homogeneous vectors, listed below, are the analog of the normal vector/string procedures for each of the homogeneous vector types. s8vector? (s8vector? obj) ;; procedure make-s8vector (make-s8vector k [fill]) ;; procedure s8vector (s8vector exact-int8 ...) ;; procedure s8vector-length (s8vector-length s8vector) ;; procedure s8vector-ref (s8vector-ref s8vector k) ;; procedure s8vector-set (s8vector-set s8vector k exact-int8) ;; procedure s8vector-set! (s8vector-set! s8vector k exact-int8) ;; procedure s8vector->list (s8vector->list s8vector) ;; procedure list->s8vector (list->s8vector list-of-exact-int8) ;; procedure s8vector-fill! (s8vector-fill! s8vector fill [start [end]]) ;; procedure subs8vector-fill! (subs8vector-fill! vector start end fill) ;; procedure s8vector-concatenate (s8vector-concatenate lst [separator]) ;; procedure s8vector-copy (s8vector-copy s8vector [start [end]]) ;; procedure s8vector-copy! (s8vector-copy! dest-s8vector dest-start s8vector [start [end]]) ;; procedure s8vector-append (s8vector-append s8vector ...) ;; procedure subs8vector (subs8vector s8vector start end) ;; procedure subs8vector-move! (subs8vector-move! src-s8vector src-start src-end dst-s8vector dst-start) ;; procedure s8vector-shrink! (s8vector-shrink! s8vector k) ;; procedure u8vector? (u8vector? obj) ;; procedure make-u8vector (make-u8vector k [fill]) ;; procedure u8vector (u8vector exact-int8 ...) ;; procedure u8vector-length (u8vector-length u8vector) ;; procedure u8vector-ref (u8vector-ref u8vector k) ;; procedure u8vector-set (u8vector-set u8vector k exact-int8) ;; procedure u8vector-set! (u8vector-set! u8vector k exact-int8) ;; procedure u8vector->list (u8vector->list u8vector) ;; procedure list->u8vector (list->u8vector list-of-exact-int8) ;; procedure u8vector-fill! (u8vector-fill! u8vector fill [start [end]]) ;; procedure subu8vector-fill! (subu8vector-fill! vector start end fill) ;; procedure u8vector-concatenate (u8vector-concatenate lst [separator]) ;; procedure u8vector-copy (u8vector-copy u8vector [start [end]]) ;; procedure u8vector-copy! (u8vector-copy! dest-u8vector dest-start u8vector [start [end]]) ;; procedure u8vector-append (u8vector-append u8vector ...) ;; procedure subu8vector (subu8vector u8vector start end) ;; procedure subu8vector-move! (subu8vector-move! src-u8vector src-start src-end dst-u8vector dst-start) ;; procedure u8vector-shrink! (u8vector-shrink! u8vector k) ;; procedure s16vector? (s16vector? obj) ;; procedure make-s16vector (make-s16vector k [fill]) ;; procedure s16vector (s16vector exact-int16 ...) ;; procedure s16vector-length (s16vector-length s16vector) ;; procedure s16vector-ref (s16vector-ref s16vector k) ;; procedure s16vector-set (s16vector-set s16vector k exact-int16) ;; procedure s16vector-set! (s16vector-set! s16vector k exact-int16) ;; procedure s16vector->list (s16vector->list s16vector) ;; procedure list->s16vector (list->s16vector list-of-exact-int16) ;; procedure s16vector-fill! (s16vector-fill! s16vector fill [start [end]]) ;; procedure subs16vector-fill! (subs16vector-fill! vector start end fill) ;; procedure s16vector-concatenate (s16vector-concatenate lst [separator]) ;; procedure s16vector-copy (s16vector-copy s16vector [start [end]]) ;; procedure s16vector-copy! (s16vector-copy! dest-s16vector dest-start s16vector [start [end]]) ;; procedure s16vector-append (s16vector-append s16vector ...) ;; procedure subs16vector (subs16vector s16vector start end) ;; procedure subs16vector-move! (subs16vector-move! src-s16vector src-start src-end dst-s16vector dst-start) ;; procedure s16vector-shrink! (s16vector-shrink! s16vector k) ;; procedure u16vector? (u16vector? obj) ;; procedure make-u16vector (make-u16vector k [fill]) ;; procedure u16vector (u16vector exact-int16 ...) ;; procedure u16vector-length (u16vector-length u16vector) ;; procedure u16vector-ref (u16vector-ref u16vector k) ;; procedure u16vector-set (u16vector-set u16vector k exact-int16) ;; procedure u16vector-set! (u16vector-set! u16vector k exact-int16) ;; procedure u16vector->list (u16vector->list u16vector) ;; procedure list->u16vector (list->u16vector list-of-exact-int16) ;; procedure u16vector-fill! (u16vector-fill! u16vector fill [start [end]]) ;; procedure subu16vector-fill! (subu16vector-fill! vector start end fill) ;; procedure u16vector-concatenate (u16vector-concatenate lst [separator]) ;; procedure u16vector-copy (u16vector-copy u16vector [start [end]]) ;; procedure u16vector-copy! (u16vector-copy! dest-u16vector dest-start u16vector [start [end]]) ;; procedure u16vector-append (u16vector-append u16vector ...) ;; procedure subu16vector (subu16vector u16vector start end) ;; procedure subu16vector-move! (subu16vector-move! src-u16vector src-start src-end dst-u16vector dst-start) ;; procedure u16vector-shrink! (u16vector-shrink! u16vector k) ;; procedure s32vector? (s32vector? obj) ;; procedure make-s32vector (make-s32vector k [fill]) ;; procedure s32vector (s32vector exact-int32 ...) ;; procedure s32vector-length (s32vector-length s32vector) ;; procedure s32vector-ref (s32vector-ref s32vector k) ;; procedure s32vector-set (s32vector-set s32vector k exact-int32) ;; procedure s32vector-set! (s32vector-set! s32vector k exact-int32) ;; procedure s32vector->list (s32vector->list s32vector) ;; procedure list->s32vector (list->s32vector list-of-exact-int32) ;; procedure s32vector-fill! (s32vector-fill! s32vector fill [start [end]]) ;; procedure subs32vector-fill! (subs32vector-fill! vector start end fill) ;; procedure s32vector-concatenate (s32vector-concatenate lst [separator]) ;; procedure s32vector-copy (s32vector-copy s32vector [start [end]]) ;; procedure s32vector-copy! (s32vector-copy! dest-s32vector dest-start s32vector [start [end]]) ;; procedure s32vector-append (s32vector-append s32vector ...) ;; procedure subs32vector (subs32vector s32vector start end) ;; procedure subs32vector-move! (subs32vector-move! src-s32vector src-start src-end dst-s32vector dst-start) ;; procedure s32vector-shrink! (s32vector-shrink! s32vector k) ;; procedure u32vector? (u32vector? obj) ;; procedure make-u32vector (make-u32vector k [fill]) ;; procedure u32vector (u32vector exact-int32 ...) ;; procedure u32vector-length (u32vector-length u32vector) ;; procedure u32vector-ref (u32vector-ref u32vector k) ;; procedure u32vector-set (u32vector-set u32vector k exact-int32) ;; procedure u32vector-set! (u32vector-set! u32vector k exact-int32) ;; procedure u32vector->list (u32vector->list u32vector) ;; procedure list->u32vector (list->u32vector list-of-exact-int32) ;; procedure u32vector-fill! (u32vector-fill! u32vector fill [start [end]]) ;; procedure subu32vector-fill! (subu32vector-fill! vector start end fill) ;; procedure u32vector-concatenate (u32vector-concatenate lst [separator]) ;; procedure u32vector-copy (u32vector-copy u32vector [start [end]]) ;; procedure u32vector-copy! (u32vector-copy! dest-u32vector dest-start u32vector [start [end]]) ;; procedure u32vector-append (u32vector-append u32vector ...) ;; procedure subu32vector (subu32vector u32vector start end) ;; procedure subu32vector-move! (subu32vector-move! src-u32vector src-start src-end dst-u32vector dst-start) ;; procedure u32vector-shrink! (u32vector-shrink! u32vector k) ;; procedure s64vector? (s64vector? obj) ;; procedure make-s64vector (make-s64vector k [fill]) ;; procedure s64vector (s64vector exact-int64 ...) ;; procedure s64vector-length (s64vector-length s64vector) ;; procedure s64vector-ref (s64vector-ref s64vector k) ;; procedure s64vector-set (s64vector-set s64vector k exact-int64) ;; procedure s64vector-set! (s64vector-set! s64vector k exact-int64) ;; procedure s64vector->list (s64vector->list s64vector) ;; procedure list->s64vector (list->s64vector list-of-exact-int64) ;; procedure s64vector-fill! (s64vector-fill! s64vector fill [start [end]]) ;; procedure subs64vector-fill! (subs64vector-fill! vector start end fill) ;; procedure s64vector-concatenate (s64vector-concatenate lst [separator]) ;; procedure s64vector-copy (s64vector-copy s64vector [start [end]]) ;; procedure s64vector-copy! (s64vector-copy! dest-s64vector dest-start s64vector [start [end]]) ;; procedure s64vector-append (s64vector-append s64vector ...) ;; procedure subs64vector (subs64vector s64vector start end) ;; procedure subs64vector-move! (subs64vector-move! src-s64vector src-start src-end dst-s64vector dst-start) ;; procedure s64vector-shrink! (s64vector-shrink! s64vector k) ;; procedure u64vector? (u64vector? obj) ;; procedure make-u64vector (make-u64vector k [fill]) ;; procedure u64vector (u64vector exact-int64 ...) ;; procedure u64vector-length (u64vector-length u64vector) ;; procedure u64vector-ref (u64vector-ref u64vector k) ;; procedure u64vector-set (u64vector-set u64vector k exact-int64) ;; procedure u64vector-set! (u64vector-set! u64vector k exact-int64) ;; procedure u64vector->list (u64vector->list u64vector) ;; procedure list->u64vector (list->u64vector list-of-exact-int64) ;; procedure u64vector-fill! (u64vector-fill! u64vector fill [start [end]]) ;; procedure subu64vector-fill! (subu64vector-fill! vector start end fill) ;; procedure u64vector-concatenate (u64vector-concatenate lst [separator]) ;; procedure u64vector-copy (u64vector-copy u64vector [start [end]]) ;; procedure u64vector-copy! (u64vector-copy! dest-u64vector dest-start u64vector [start [end]]) ;; procedure u64vector-append (u64vector-append u64vector ...) ;; procedure subu64vector (subu64vector u64vector start end) ;; procedure subu64vector-move! (subu64vector-move! src-u64vector src-start src-end dst-u64vector dst-start) ;; procedure u64vector-shrink! (u64vector-shrink! u64vector k) ;; procedure f32vector? (f32vector? obj) ;; procedure make-f32vector (make-f32vector k [fill]) ;; procedure f32vector (f32vector inexact-real ...) ;; procedure f32vector-length (f32vector-length f32vector) ;; procedure f32vector-ref (f32vector-ref f32vector k) ;; procedure f32vector-set (f32vector-set f32vector k inexact-real) ;; procedure f32vector-set! (f32vector-set! f32vector k inexact-real) ;; procedure f32vector->list (f32vector->list f32vector) ;; procedure list->f32vector (list->f32vector list-of-inexact-real) ;; procedure f32vector-fill! (f32vector-fill! f32vector fill [start [end]]) ;; procedure subf32vector-fill! (subf32vector-fill! vector start end fill) ;; procedure f32vector-concatenate (f32vector-concatenate lst [separator]) ;; procedure f32vector-copy (f32vector-copy f32vector [start [end]]) ;; procedure f32vector-copy! (f32vector-copy! dest-f32vector dest-start f32vector [start [end]]) ;; procedure f32vector-append (f32vector-append f32vector ...) ;; procedure subf32vector (subf32vector f32vector start end) ;; procedure subf32vector-move! (subf32vector-move! src-f32vector src-start src-end dst-f32vector dst-start) ;; procedure f32vector-shrink! (f32vector-shrink! f32vector k) ;; procedure f64vector? (f64vector? obj) ;; procedure make-f64vector (make-f64vector k [fill]) ;; procedure f64vector (f64vector inexact-real ...) ;; procedure f64vector-length (f64vector-length f64vector) ;; procedure f64vector-ref (f64vector-ref f64vector k) ;; procedure f64vector-set (f64vector-set f64vector k inexact-real) ;; procedure f64vector-set! (f64vector-set! f64vector k inexact-real) ;; procedure f64vector->list (f64vector->list f64vector) ;; procedure list->f64vector (list->f64vector list-of-inexact-real) ;; procedure f64vector-fill! (f64vector-fill! f64vector fill [start [end]]) ;; procedure subf64vector-fill! (subf64vector-fill! vector start end fill) ;; procedure f64vector-concatenate (f64vector-concatenate lst [separator]) ;; procedure f64vector-copy (f64vector-copy f64vector [start [end]]) ;; procedure f64vector-copy! (f64vector-copy! dest-f64vector dest-start f64vector [start [end]]) ;; procedure f64vector-append (f64vector-append f64vector ...) ;; procedure subf64vector (subf64vector f64vector start end) ;; procedure subf64vector-move! (subf64vector-move! src-f64vector src-start src-end dst-f64vector dst-start) ;; procedure f64vector-shrink! (f64vector-shrink! f64vector k) For example: > (define v (u8vector 10 255 13)) > (u8vector-set! v 2 99) > v #u8(10 255 99) > (u8vector-ref v 1) 255 > (u8vector->list v) (10 255 99) > (u8vector-shrink! v 2) > (v) #u8(10 255) object->u8vector u8vector->object (object->u8vector obj [encoder]) ;; procedure (u8vector->object u8vector [decoder]) ;; procedure The procedure object->u8vector returns a u8vector that contains the sequence of bytes that encodes the object obj . The procedure u8vector->object decodes the sequence of bytes contained in the u8vector u8vector , which was produced by the procedure object->u8vector , and reconstructs an object structurally equal to the original object. In other words the procedures object->u8vector and u8vector->object respectively perform serialization and deserialization of Scheme objects. Note that some objects are non-serializable (e.g. threads, wills, some types of ports, and any object containing a non-serializable object). The optional encoder and decoder parameters are single parameter procedures which default to the identity function. The encoder procedure is called during serialization. As the serializer walks through obj , it calls the encoder procedure on each sub-object X that is encountered. The encoder transforms the object X into an object Y that will be serialized instead of X . Similarly the decoder procedure is called during deserialization. When an object Y is encountered, the decoder procedure is called to transform it into the object X that is the result of deserialization. The encoder and decoder procedures are useful to customize the serialized representation of objects. In particular, it can be used to define the semantics of serializing objects, such as threads and ports, that would otherwise not be serializable. The decoder procedure is typically the inverse of the encoder procedure, i.e. (decoder (encoder X)) = X . For example: > (define (make-adder x) (lambda (y) (+ x y))) > (define f (make-adder 10)) > (define a (object->u8vector f)) > (define b (u8vector->object a)) > (u8vector-length a) 1639 > (f 5) 15 > (b 5) 15 > (pp b) (lambda (y) (+ x y))","title":"Homogeneous numeric vectors"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#homogeneous-numeric-vectors","text":"Homogeneous vectors are vectors containing raw numbers of the same type (signed or unsigned exact integers or inexact reals). There are 10 types of homogeneous vectors: s8vector : vector of exact integers in the range -2^7 to 2^7-1 u8vector : vector of exact integers in the range 0 to 2^8-1 s16vector : vector of exact integers in the range -2^15 to 2^15-1 u16vector : vector of exact integers in the range 0 to 2^16-1 s32vector : vector of exact integers in the range -2^31 to 2^31-1 u32vector : vector of exact integers in the range 0 to 2^32-1 s64vector : vector of exact integers in the range -2^63 to 2^63-1 u64vector : vector of exact integers in the range 0 to 2^64-1 f32vector : vector of 32 bit floating point numbers f64vector : vector of 64 bit floating point numbers The lexical syntax of homogeneous vectors is specified in Homogeneous vector syntax . The procedures available for homogeneous vectors, listed below, are the analog of the normal vector/string procedures for each of the homogeneous vector types.","title":"Homogeneous numeric vectors"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector","text":"(s8vector? obj) ;; procedure","title":"s8vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-s8vector","text":"(make-s8vector k [fill]) ;; procedure","title":"make-s8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector_1","text":"(s8vector exact-int8 ...) ;; procedure","title":"s8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-length","text":"(s8vector-length s8vector) ;; procedure","title":"s8vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-ref","text":"(s8vector-ref s8vector k) ;; procedure","title":"s8vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-set","text":"(s8vector-set s8vector k exact-int8) ;; procedure","title":"s8vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-set_1","text":"(s8vector-set! s8vector k exact-int8) ;; procedure","title":"s8vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-list","text":"(s8vector->list s8vector) ;; procedure","title":"s8vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-s8vector","text":"(list->s8vector list-of-exact-int8) ;; procedure","title":"list-&gt;s8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-fill","text":"(s8vector-fill! s8vector fill [start [end]]) ;; procedure","title":"s8vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs8vector-fill","text":"(subs8vector-fill! vector start end fill) ;; procedure","title":"subs8vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-concatenate","text":"(s8vector-concatenate lst [separator]) ;; procedure","title":"s8vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-copy","text":"(s8vector-copy s8vector [start [end]]) ;; procedure","title":"s8vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-copy_1","text":"(s8vector-copy! dest-s8vector dest-start s8vector [start [end]]) ;; procedure","title":"s8vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-append","text":"(s8vector-append s8vector ...) ;; procedure","title":"s8vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs8vector","text":"(subs8vector s8vector start end) ;; procedure","title":"subs8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs8vector-move","text":"(subs8vector-move! src-s8vector src-start src-end dst-s8vector dst-start) ;; procedure","title":"subs8vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s8vector-shrink","text":"(s8vector-shrink! s8vector k) ;; procedure","title":"s8vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector","text":"(u8vector? obj) ;; procedure","title":"u8vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-u8vector","text":"(make-u8vector k [fill]) ;; procedure","title":"make-u8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector_1","text":"(u8vector exact-int8 ...) ;; procedure","title":"u8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-length","text":"(u8vector-length u8vector) ;; procedure","title":"u8vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-ref","text":"(u8vector-ref u8vector k) ;; procedure","title":"u8vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-set","text":"(u8vector-set u8vector k exact-int8) ;; procedure","title":"u8vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-set_1","text":"(u8vector-set! u8vector k exact-int8) ;; procedure","title":"u8vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-list","text":"(u8vector->list u8vector) ;; procedure","title":"u8vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-u8vector","text":"(list->u8vector list-of-exact-int8) ;; procedure","title":"list-&gt;u8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-fill","text":"(u8vector-fill! u8vector fill [start [end]]) ;; procedure","title":"u8vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu8vector-fill","text":"(subu8vector-fill! vector start end fill) ;; procedure","title":"subu8vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-concatenate","text":"(u8vector-concatenate lst [separator]) ;; procedure","title":"u8vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-copy","text":"(u8vector-copy u8vector [start [end]]) ;; procedure","title":"u8vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-copy_1","text":"(u8vector-copy! dest-u8vector dest-start u8vector [start [end]]) ;; procedure","title":"u8vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-append","text":"(u8vector-append u8vector ...) ;; procedure","title":"u8vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu8vector","text":"(subu8vector u8vector start end) ;; procedure","title":"subu8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu8vector-move","text":"(subu8vector-move! src-u8vector src-start src-end dst-u8vector dst-start) ;; procedure","title":"subu8vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-shrink","text":"(u8vector-shrink! u8vector k) ;; procedure","title":"u8vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector","text":"(s16vector? obj) ;; procedure","title":"s16vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-s16vector","text":"(make-s16vector k [fill]) ;; procedure","title":"make-s16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector_1","text":"(s16vector exact-int16 ...) ;; procedure","title":"s16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-length","text":"(s16vector-length s16vector) ;; procedure","title":"s16vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-ref","text":"(s16vector-ref s16vector k) ;; procedure","title":"s16vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-set","text":"(s16vector-set s16vector k exact-int16) ;; procedure","title":"s16vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-set_1","text":"(s16vector-set! s16vector k exact-int16) ;; procedure","title":"s16vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-list","text":"(s16vector->list s16vector) ;; procedure","title":"s16vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-s16vector","text":"(list->s16vector list-of-exact-int16) ;; procedure","title":"list-&gt;s16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-fill","text":"(s16vector-fill! s16vector fill [start [end]]) ;; procedure","title":"s16vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs16vector-fill","text":"(subs16vector-fill! vector start end fill) ;; procedure","title":"subs16vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-concatenate","text":"(s16vector-concatenate lst [separator]) ;; procedure","title":"s16vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-copy","text":"(s16vector-copy s16vector [start [end]]) ;; procedure","title":"s16vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-copy_1","text":"(s16vector-copy! dest-s16vector dest-start s16vector [start [end]]) ;; procedure","title":"s16vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-append","text":"(s16vector-append s16vector ...) ;; procedure","title":"s16vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs16vector","text":"(subs16vector s16vector start end) ;; procedure","title":"subs16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs16vector-move","text":"(subs16vector-move! src-s16vector src-start src-end dst-s16vector dst-start) ;; procedure","title":"subs16vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s16vector-shrink","text":"(s16vector-shrink! s16vector k) ;; procedure","title":"s16vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector","text":"(u16vector? obj) ;; procedure","title":"u16vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-u16vector","text":"(make-u16vector k [fill]) ;; procedure","title":"make-u16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector_1","text":"(u16vector exact-int16 ...) ;; procedure","title":"u16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-length","text":"(u16vector-length u16vector) ;; procedure","title":"u16vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-ref","text":"(u16vector-ref u16vector k) ;; procedure","title":"u16vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-set","text":"(u16vector-set u16vector k exact-int16) ;; procedure","title":"u16vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-set_1","text":"(u16vector-set! u16vector k exact-int16) ;; procedure","title":"u16vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-list","text":"(u16vector->list u16vector) ;; procedure","title":"u16vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-u16vector","text":"(list->u16vector list-of-exact-int16) ;; procedure","title":"list-&gt;u16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-fill","text":"(u16vector-fill! u16vector fill [start [end]]) ;; procedure","title":"u16vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu16vector-fill","text":"(subu16vector-fill! vector start end fill) ;; procedure","title":"subu16vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-concatenate","text":"(u16vector-concatenate lst [separator]) ;; procedure","title":"u16vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-copy","text":"(u16vector-copy u16vector [start [end]]) ;; procedure","title":"u16vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-copy_1","text":"(u16vector-copy! dest-u16vector dest-start u16vector [start [end]]) ;; procedure","title":"u16vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-append","text":"(u16vector-append u16vector ...) ;; procedure","title":"u16vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu16vector","text":"(subu16vector u16vector start end) ;; procedure","title":"subu16vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu16vector-move","text":"(subu16vector-move! src-u16vector src-start src-end dst-u16vector dst-start) ;; procedure","title":"subu16vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u16vector-shrink","text":"(u16vector-shrink! u16vector k) ;; procedure","title":"u16vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector","text":"(s32vector? obj) ;; procedure","title":"s32vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-s32vector","text":"(make-s32vector k [fill]) ;; procedure","title":"make-s32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector_1","text":"(s32vector exact-int32 ...) ;; procedure","title":"s32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-length","text":"(s32vector-length s32vector) ;; procedure","title":"s32vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-ref","text":"(s32vector-ref s32vector k) ;; procedure","title":"s32vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-set","text":"(s32vector-set s32vector k exact-int32) ;; procedure","title":"s32vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-set_1","text":"(s32vector-set! s32vector k exact-int32) ;; procedure","title":"s32vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-list","text":"(s32vector->list s32vector) ;; procedure","title":"s32vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-s32vector","text":"(list->s32vector list-of-exact-int32) ;; procedure","title":"list-&gt;s32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-fill","text":"(s32vector-fill! s32vector fill [start [end]]) ;; procedure","title":"s32vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs32vector-fill","text":"(subs32vector-fill! vector start end fill) ;; procedure","title":"subs32vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-concatenate","text":"(s32vector-concatenate lst [separator]) ;; procedure","title":"s32vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-copy","text":"(s32vector-copy s32vector [start [end]]) ;; procedure","title":"s32vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-copy_1","text":"(s32vector-copy! dest-s32vector dest-start s32vector [start [end]]) ;; procedure","title":"s32vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-append","text":"(s32vector-append s32vector ...) ;; procedure","title":"s32vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs32vector","text":"(subs32vector s32vector start end) ;; procedure","title":"subs32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs32vector-move","text":"(subs32vector-move! src-s32vector src-start src-end dst-s32vector dst-start) ;; procedure","title":"subs32vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s32vector-shrink","text":"(s32vector-shrink! s32vector k) ;; procedure","title":"s32vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector","text":"(u32vector? obj) ;; procedure","title":"u32vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-u32vector","text":"(make-u32vector k [fill]) ;; procedure","title":"make-u32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector_1","text":"(u32vector exact-int32 ...) ;; procedure","title":"u32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-length","text":"(u32vector-length u32vector) ;; procedure","title":"u32vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-ref","text":"(u32vector-ref u32vector k) ;; procedure","title":"u32vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-set","text":"(u32vector-set u32vector k exact-int32) ;; procedure","title":"u32vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-set_1","text":"(u32vector-set! u32vector k exact-int32) ;; procedure","title":"u32vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-list","text":"(u32vector->list u32vector) ;; procedure","title":"u32vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-u32vector","text":"(list->u32vector list-of-exact-int32) ;; procedure","title":"list-&gt;u32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-fill","text":"(u32vector-fill! u32vector fill [start [end]]) ;; procedure","title":"u32vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu32vector-fill","text":"(subu32vector-fill! vector start end fill) ;; procedure","title":"subu32vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-concatenate","text":"(u32vector-concatenate lst [separator]) ;; procedure","title":"u32vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-copy","text":"(u32vector-copy u32vector [start [end]]) ;; procedure","title":"u32vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-copy_1","text":"(u32vector-copy! dest-u32vector dest-start u32vector [start [end]]) ;; procedure","title":"u32vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-append","text":"(u32vector-append u32vector ...) ;; procedure","title":"u32vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu32vector","text":"(subu32vector u32vector start end) ;; procedure","title":"subu32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu32vector-move","text":"(subu32vector-move! src-u32vector src-start src-end dst-u32vector dst-start) ;; procedure","title":"subu32vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u32vector-shrink","text":"(u32vector-shrink! u32vector k) ;; procedure","title":"u32vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector","text":"(s64vector? obj) ;; procedure","title":"s64vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-s64vector","text":"(make-s64vector k [fill]) ;; procedure","title":"make-s64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector_1","text":"(s64vector exact-int64 ...) ;; procedure","title":"s64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-length","text":"(s64vector-length s64vector) ;; procedure","title":"s64vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-ref","text":"(s64vector-ref s64vector k) ;; procedure","title":"s64vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-set","text":"(s64vector-set s64vector k exact-int64) ;; procedure","title":"s64vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-set_1","text":"(s64vector-set! s64vector k exact-int64) ;; procedure","title":"s64vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-list","text":"(s64vector->list s64vector) ;; procedure","title":"s64vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-s64vector","text":"(list->s64vector list-of-exact-int64) ;; procedure","title":"list-&gt;s64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-fill","text":"(s64vector-fill! s64vector fill [start [end]]) ;; procedure","title":"s64vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs64vector-fill","text":"(subs64vector-fill! vector start end fill) ;; procedure","title":"subs64vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-concatenate","text":"(s64vector-concatenate lst [separator]) ;; procedure","title":"s64vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-copy","text":"(s64vector-copy s64vector [start [end]]) ;; procedure","title":"s64vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-copy_1","text":"(s64vector-copy! dest-s64vector dest-start s64vector [start [end]]) ;; procedure","title":"s64vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-append","text":"(s64vector-append s64vector ...) ;; procedure","title":"s64vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs64vector","text":"(subs64vector s64vector start end) ;; procedure","title":"subs64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subs64vector-move","text":"(subs64vector-move! src-s64vector src-start src-end dst-s64vector dst-start) ;; procedure","title":"subs64vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#s64vector-shrink","text":"(s64vector-shrink! s64vector k) ;; procedure","title":"s64vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector","text":"(u64vector? obj) ;; procedure","title":"u64vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-u64vector","text":"(make-u64vector k [fill]) ;; procedure","title":"make-u64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector_1","text":"(u64vector exact-int64 ...) ;; procedure","title":"u64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-length","text":"(u64vector-length u64vector) ;; procedure","title":"u64vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-ref","text":"(u64vector-ref u64vector k) ;; procedure","title":"u64vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-set","text":"(u64vector-set u64vector k exact-int64) ;; procedure","title":"u64vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-set_1","text":"(u64vector-set! u64vector k exact-int64) ;; procedure","title":"u64vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-list","text":"(u64vector->list u64vector) ;; procedure","title":"u64vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-u64vector","text":"(list->u64vector list-of-exact-int64) ;; procedure","title":"list-&gt;u64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-fill","text":"(u64vector-fill! u64vector fill [start [end]]) ;; procedure","title":"u64vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu64vector-fill","text":"(subu64vector-fill! vector start end fill) ;; procedure","title":"subu64vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-concatenate","text":"(u64vector-concatenate lst [separator]) ;; procedure","title":"u64vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-copy","text":"(u64vector-copy u64vector [start [end]]) ;; procedure","title":"u64vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-copy_1","text":"(u64vector-copy! dest-u64vector dest-start u64vector [start [end]]) ;; procedure","title":"u64vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-append","text":"(u64vector-append u64vector ...) ;; procedure","title":"u64vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu64vector","text":"(subu64vector u64vector start end) ;; procedure","title":"subu64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subu64vector-move","text":"(subu64vector-move! src-u64vector src-start src-end dst-u64vector dst-start) ;; procedure","title":"subu64vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u64vector-shrink","text":"(u64vector-shrink! u64vector k) ;; procedure","title":"u64vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector","text":"(f32vector? obj) ;; procedure","title":"f32vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-f32vector","text":"(make-f32vector k [fill]) ;; procedure","title":"make-f32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector_1","text":"(f32vector inexact-real ...) ;; procedure","title":"f32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-length","text":"(f32vector-length f32vector) ;; procedure","title":"f32vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-ref","text":"(f32vector-ref f32vector k) ;; procedure","title":"f32vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-set","text":"(f32vector-set f32vector k inexact-real) ;; procedure","title":"f32vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-set_1","text":"(f32vector-set! f32vector k inexact-real) ;; procedure","title":"f32vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-list","text":"(f32vector->list f32vector) ;; procedure","title":"f32vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-f32vector","text":"(list->f32vector list-of-inexact-real) ;; procedure","title":"list-&gt;f32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-fill","text":"(f32vector-fill! f32vector fill [start [end]]) ;; procedure","title":"f32vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subf32vector-fill","text":"(subf32vector-fill! vector start end fill) ;; procedure","title":"subf32vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-concatenate","text":"(f32vector-concatenate lst [separator]) ;; procedure","title":"f32vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-copy","text":"(f32vector-copy f32vector [start [end]]) ;; procedure","title":"f32vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-copy_1","text":"(f32vector-copy! dest-f32vector dest-start f32vector [start [end]]) ;; procedure","title":"f32vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-append","text":"(f32vector-append f32vector ...) ;; procedure","title":"f32vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subf32vector","text":"(subf32vector f32vector start end) ;; procedure","title":"subf32vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subf32vector-move","text":"(subf32vector-move! src-f32vector src-start src-end dst-f32vector dst-start) ;; procedure","title":"subf32vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f32vector-shrink","text":"(f32vector-shrink! f32vector k) ;; procedure","title":"f32vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector","text":"(f64vector? obj) ;; procedure","title":"f64vector?"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#make-f64vector","text":"(make-f64vector k [fill]) ;; procedure","title":"make-f64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector_1","text":"(f64vector inexact-real ...) ;; procedure","title":"f64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-length","text":"(f64vector-length f64vector) ;; procedure","title":"f64vector-length"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-ref","text":"(f64vector-ref f64vector k) ;; procedure","title":"f64vector-ref"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-set","text":"(f64vector-set f64vector k inexact-real) ;; procedure","title":"f64vector-set"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-set_1","text":"(f64vector-set! f64vector k inexact-real) ;; procedure","title":"f64vector-set!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-list","text":"(f64vector->list f64vector) ;; procedure","title":"f64vector-&gt;list"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#list-f64vector","text":"(list->f64vector list-of-inexact-real) ;; procedure","title":"list-&gt;f64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-fill","text":"(f64vector-fill! f64vector fill [start [end]]) ;; procedure","title":"f64vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subf64vector-fill","text":"(subf64vector-fill! vector start end fill) ;; procedure","title":"subf64vector-fill!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-concatenate","text":"(f64vector-concatenate lst [separator]) ;; procedure","title":"f64vector-concatenate"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-copy","text":"(f64vector-copy f64vector [start [end]]) ;; procedure","title":"f64vector-copy"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-copy_1","text":"(f64vector-copy! dest-f64vector dest-start f64vector [start [end]]) ;; procedure","title":"f64vector-copy!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-append","text":"(f64vector-append f64vector ...) ;; procedure","title":"f64vector-append"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subf64vector","text":"(subf64vector f64vector start end) ;; procedure","title":"subf64vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#subf64vector-move","text":"(subf64vector-move! src-f64vector src-start src-end dst-f64vector dst-start) ;; procedure","title":"subf64vector-move!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#f64vector-shrink","text":"(f64vector-shrink! f64vector k) For example: > (define v (u8vector 10 255 13)) > (u8vector-set! v 2 99) > v #u8(10 255 99) > (u8vector-ref v 1) 255 > (u8vector->list v) (10 255 99) > (u8vector-shrink! v 2) > (v) #u8(10 255)","title":"f64vector-shrink!"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#object-u8vector","text":"","title":"object-&gt;u8vector"},{"location":"manual/built_in_data_types/homogeneous_numeric_vectors/#u8vector-object","text":"(object->u8vector obj [encoder]) ;; procedure (u8vector->object u8vector [decoder]) ;; procedure The procedure object->u8vector returns a u8vector that contains the sequence of bytes that encodes the object obj . The procedure u8vector->object decodes the sequence of bytes contained in the u8vector u8vector , which was produced by the procedure object->u8vector , and reconstructs an object structurally equal to the original object. In other words the procedures object->u8vector and u8vector->object respectively perform serialization and deserialization of Scheme objects. Note that some objects are non-serializable (e.g. threads, wills, some types of ports, and any object containing a non-serializable object). The optional encoder and decoder parameters are single parameter procedures which default to the identity function. The encoder procedure is called during serialization. As the serializer walks through obj , it calls the encoder procedure on each sub-object X that is encountered. The encoder transforms the object X into an object Y that will be serialized instead of X . Similarly the decoder procedure is called during deserialization. When an object Y is encountered, the decoder procedure is called to transform it into the object X that is the result of deserialization. The encoder and decoder procedures are useful to customize the serialized representation of objects. In particular, it can be used to define the semantics of serializing objects, such as threads and ports, that would otherwise not be serializable. The decoder procedure is typically the inverse of the encoder procedure, i.e. (decoder (encoder X)) = X . For example: > (define (make-adder x) (lambda (y) (+ x y))) > (define f (make-adder 10)) > (define a (object->u8vector f)) > (define b (u8vector->object a)) > (u8vector-length a) 1639 > (f 5) 15 > (b 5) 15 > (pp b) (lambda (y) (+ x y))","title":"u8vector-&gt;object"},{"location":"manual/built_in_data_types/numbers/","text":"Numbers Extensions to numeric procedures = < > <= >= (= z1 ...) ;; procedure (< x1 ...) ;; procedure (> x1 ...) ;; procedure (<= x1 ...) ;; procedure (>= x1 ...) ;; procedure These procedures take any number of arguments including no argument. This is useful to test if the elements of a list are sorted in a particular order. For example, testing that the list of numbers lst is sorted in nondecreasing order can be done with the call (apply < lst) . IEEE floating point arithmetic To better conform to IEEE floating point arithmetic the standard numeric tower is extended with these special inexact reals: +inf.0 : positive infinity -inf.0 : negative infinity +nan.0 : \"not a number\" -0. : negative zero ( 0. is the positive zero) The infinities and \"not a number\" are reals (i.e. (real? +inf.0) is #t ) but are not rational (i.e. (rational? +inf.0) is #f ). Both zeros are numerically equal (i.e. (= -0. 0.) is #t ) but are not equivalent (i.e. (eqv? -0. 0.) and (equal? -0. 0.) are #f ). All numerical comparisons with \"not a number\", including (= +nan.0 +nan.0) , are #f . Integer square root and nth root integer-sqrt (integer-sqrt n) ;; procedure This procedure returns the integer part of the square root of the nonnegative exact integer n . For example: > (integer-sqrt 123) 11 integer-nth-root (integer-nth-root n1 n2) ;; procedure This procedure returns the integer part of n1 raised to the power 1/n2 , where n1 is a nonnegative exact integer and n2 is a positive exact integer. For example: > (integer-nth-root 100 3) 4 Bitwise-operations on exact integers The procedures defined in this section are compatible with the withdrawn \"Integer Bitwise-operation Library SRFI\" ( SRFI 33 ). Note that some of the procedures specified in SRFI 33 are not provided. Most procedures in this section are specified in terms of the binary representation of exact integers. The two's complement representation is assumed where an integer is composed of an infinite number of bits. The upper section of an integer (the most significant bits) are either an infinite sequence of ones when the integer is negative, or they are an infinite sequence of zeros when the integer is nonnegative. arithmetic-shift (arithmetic-shift n1 n2) ;; procedure This procedure returns n1 shifted to the left by n2 bits, that is (floor (* n1 (expt 2 n2))) . Both n1 and n2 must be exact integers. For example: > (arithmetic-shift 1000 7) ; n1=...0000001111101000 128000 > (arithmetic-shift 1000 -6) ; n1=...0000001111101000 15 > (arithmetic-shift -23 -3) ; n1=...1111111111101001 -3 bitwise-merge (bitwise-merge n1 n2 n3) ;; procedure This procedure returns an exact integer whose bits combine the bits from n2 and n3 depending on n1 . The bit at index i of the result depends only on the bits at index i in n1 , n2 and n3 : it is equal to the bit in n2 when the bit in n1 is 0 and it is equal to the bit in n3 when the bit in n1 is 1. All arguments must be exact integers. For example: > (bitwise-merge -4 -11 10) ; ...11111100 ...11110101 ...00001010 9 > (bitwise-merge 12 -11 10) ; ...00001100 ...11110101 ...00001010 -7 bitwise-and (bitwise-and n ...) ;; procedure This procedure returns the bitwise \"and\" of the exact integers n ... . The value -1 is returned when there are no arguments. For example: > (bitwise-and 6 12) ; ...00000110 ...00001100 4 > (bitwise-and 6 -4) ; ...00000110 ...11111100 4 > (bitwise-and -6 -4) ; ...11111010 ...11111100 -8 > (bitwise-and) -1 bitwise-andc1 (bitwise-andc1 n1 n2) ;; procedure This procedure returns the bitwise \"and\" of the bitwise complement of the exact integer n1 and the exact integer n2 . For example: > (bitwise-andc1 11 26) ; ...00001011 ...00011010 16 > (bitwise-andc1 -12 26) ; ...11110100 ...00011010 10 bitwise-andc2 (bitwise-andc2 n1 n2) ;; procedure This procedure returns the bitwise \"and\" of the exact integer n1 and the bitwise complement of the exact integer n2 . For example: > (bitwise-andc2 11 26) ; ...00001011 ...00011010 1 > (bitwise-andc2 11 -27) ; ...00001011 ...11100101 10 bitwise-eqv (bitwise-eqv n ...) ;; procedure This procedure returns the bitwise complement of the bitwise \"exclusive-or\" of the exact integers n ... . The value -1 is returned when there are no arguments. For example: > (bitwise-eqv 6 12) ; ...00000110 ...00001100 -11 > (bitwise-eqv 6 -4) ; ...00000110 ...11111100 5 > (bitwise-eqv -6 -4) ; ...11111010 ...11111100 -7 > (bitwise-eqv) -1 bitwise-ior (bitwise-ior n ...) ;; procedure This procedure returns the bitwise \"inclusive-or\" of the exact integers n ... . The value 0 is returned when there are no arguments. For example: > (bitwise-ior 6 12) ; ...00000110 ...00001100 14 > (bitwise-ior 6 -4) ; ...00000110 ...11111100 -2 > (bitwise-ior -6 -4) ; ...11111010 ...11111100 -2 > (bitwise-ior) 0 bitwise-nand (bitwise-nand n1 n2) ;; procedure This procedure returns the bitwise complement of the bitwise \"and\" of the exact integer n1 and the exact integer n2 . For example: > (bitwise-nand 11 26) ; ...00001011 ...00011010 -11 > (bitwise-nand 11 -27) ; ...00001011 ...11100101 -2 bitwise-nor (bitwise-nor n1 n2) ;; procedure This procedure returns the bitwise complement of the bitwise \"inclusive-or\" of the exact integer n1 and the exact integer n2 . For example: > (bitwise-nor 11 26) ; ...00001011 ...00011010 -28 > (bitwise-nor 11 -27) ; ...00001011 ...11100101 16 bitwise-not (bitwise-not n) ;; procedure This procedure returns the bitwise complement of the exact integer n . For example: > (bitwise-not 3) ; ...00000011 -4 > (bitwise-not -1) ; ...11111111 0 bitwise-orc1 (bitwise-orc1 n1 n2) ;; procedure This procedure returns the bitwise \"inclusive-or\" of the bitwise complement of the exact integer n1 and the exact integer n2 . For example: > (bitwise-orc1 11 26) ; ...00001011 ...00011010 -2 > (bitwise-orc1 -12 26) ; ...11110100 ...00011010 27 bitwise-orc2 (bitwise-orc2 n1 n2) ;; procedure This procedure returns the bitwise \"inclusive-or\" of the exact integer n1 and the bitwise complement of the exact integer n2 . For example: > (bitwise-orc2 11 26) ; ...00001011 ...00011010 -17 > (bitwise-orc2 11 -27) ; ...00001011 ...11100101 27 bitwise-xor (bitwise-xor n ...) ;; procedure This procedure returns the bitwise \"exclusive-or\" of the exact integers n ... . The value 0 is returned when there are no arguments. For example: > (bitwise-xor 6 12) ; ...00000110 ...00001100 10 > (bitwise-xor 6 -4) ; ...00000110 ...11111100 -6 > (bitwise-xor -6 -4) ; ...11111010 ...11111100 6 > (bitwise-xor) 0 bit-count (bit-count n) ;; procedure This procedure returns the bit count of the exact integer n . If n is nonnegative, the bit count is the number of 1 bits in the two's complement representation of n . If n is negative, the bit count is the number of 0 bits in the two's complement representation of n . For example: > (bit-count 0) ; ...00000000 0 > (bit-count 1) ; ...00000001 1 > (bit-count 2) ; ...00000010 1 > (bit-count 3) ; ...00000011 2 > (bit-count 4) ; ...00000100 1 > (bit-count -23) ; ...11101001 3 integer-length (integer-length n) ;; procedure This procedure returns the bit length of the exact integer n . If n is a positive integer the bit length is one more than the index of the highest 1 bit (the least significant bit is at index 0). If n is a negative integer the bit length is one more than the index of the highest 0 bit. If n is zero, the bit length is 0. For example: > (integer-length 0) ; ...00000000 0 > (integer-length 1) ; ...00000001 1 > (integer-length 2) ; ...00000010 2 > (integer-length 3) ; ...00000011 2 > (integer-length 4) ; ...00000100 3 > (integer-length -23) ; ...11101001 5 bit-set? (bit-set? n1 n2) ;; procedure This procedure returns a boolean indicating if the bit at index n1 of n2 is set (i.e. equal to 1 ) or not. Both n1 and n2 must be exact integers, and n1 must be nonnegative. For example: > (map (lambda (i) (bit-set? i -23)) ; ...11101001 '(7 6 5 4 3 2 1 0)) (#t #t #t #f #t #f #f #t) any-bits-set? (any-bits-set? n1 n2) ;; procedure This procedure returns a boolean indicating if the bitwise and of n1 and n2 is different from zero or not. This procedure is implemented more efficiently than the naive definition: (define (any-bits-set? n1 n2) (not (zero? (bitwise-and n1 n2)))) For example: > (any-bits-set? 5 10) ; ...00000101 ...00001010 #f > (any-bits-set? -23 32) ; ...11101001 ...00100000 #t all-bits-set? (all-bits-set? n1 n2) ;; procedure This procedure returns a boolean indicating if the \"bitwise and\" of n1 and n2 is equal to n1 or not. This procedure is implemented more efficiently than the naive definition: (define (all-bits-set? n1 n2) (= n1 (bitwise-and n1 n2))) For example: > (all-bits-set? 1 3) ; ...00000001 ...00000011 #t > (all-bits-set? 7 3) ; ...00000111 ...00000011 #f first-set-bit (first-set-bit n) ;; procedure This procedure returns the bit index of the least significant bit of n equal to 1 (which is also the number of 0 bits that are below the least significant 1 bit). This procedure returns -1 when n is zero. For example: > (first-set-bit 24) ; ...00011000 3 > (first-set-bit 0) ; ...00000000 -1 extract-bit-field test-bit-field? clear-bit-field replace-bit-field copy-bit-field (extract-bit-field n1 n2 n3) ;; procedure (test-bit-field? n1 n2 n3) ;; procedure (clear-bit-field n1 n2 n3) ;; procedure (replace-bit-field n1 n2 n3 n4) ;; procedure (copy-bit-field n1 n2 n3 n4) ;; procedure These procedures operate on a bit-field which is n1 bits wide starting at bit index n2 . All arguments must be exact integers and n1 and n2 must be nonnegative. The procedure extract-bit-field returns the bit-field of n3 shifted to the right so that the least significant bit of the bit-field is the least significant bit of the result. The procedure test-bit-field? returns #t if any bit in the bit-field of n3 is equal to 1 , otherwise #f is returned. The procedure clear-bit-field returns n3 with all bits in the bit-field replaced with 0 . The procedure replace-bit-field returns n4 with the bit-field replaced with the least-significant n1 bits of n3 . The procedure copy-bit-field returns n4 with the bit-field replaced with the (same index and size) bit-field in n3 . For example: > (extract-bit-field 5 2 -37) ; ...11011011 22 > (test-bit-field? 5 2 -37) ; ...11011011 #t > (test-bit-field? 1 2 -37) ; ...11011011 #f > (clear-bit-field 5 2 -37) ; ...11011011 -125 > (replace-bit-field 5 2 -6 -37) ; ...11111010 ...11011011 -21 > (copy-bit-field 5 2 -6 -37) ; ...11111010 ...11011011 -5 Fixnum-specific operations This documentation needs work, cleanup or clarification. fixnum? (fixnum? obj) ;; procedure fx* (fx* n1 ...) ;; procedure fx+ (fx+ n1 ...) ;; procedure fx- (fx- n1 n2 ...) ;; procedure fx< (fx< n1 ...) ;; procedure fx<= (fx<= n1 ...) ;; procedure fx= (fx= n1 ...) ;; procedure fx> (fx> n1 ...) ;; procedure fx>= (fx>= n1 ...) ;; procedure fxabs (fxabs n) ;; procedure fxand (fxand n1 ...) ;; procedure fxandc1 (fxandc1 n1 n2) ;; procedure fxandc2 (fxandc2 n1 n2) ;; procedure fxarithmetic-shift (fxarithmetic-shift n1 n2) ;; procedure fxarithmetic-shift-left (fxarithmetic-shift-left n1 n2) ;; procedure fxarithmetic-shift-right (fxarithmetic-shift-right n1 n2) ;; procedure fxbit-count (fxbit-count n) ;; procedure fxbit-set? (fxbit-set? n1 n2) ;; procedure fxeqv (fxeqv n1 ...) ;; procedure fxeven? (fxeven? n) ;; procedure fxfirst-set-bit (fxfirst-set-bit n) ;; procedure fxif (fxif n1 n2 n3) ;; procedure fxior (fxior n1 ...) ;; procedure fxlength (fxlength n) ;; procedure fxmax (fxmax n1 n2 ...) ;; procedure fxmin (fxmin n1 n2 ...) ;; procedure fxmodulo (fxmodulo n1 n2) ;; procedure fxnegative? (fxnegative? n) ;; procedure fxnand (fxnand n1 n2) ;; procedure fxnor (fxnor n1 n2) ;; procedure fxnot (fxnot n) ;; procedure fxodd? (fxodd? n) ;; procedure fxorc1 (fxorc1 n1 n2) ;; procedure fxorc2 (fxorc2 n1 n2) ;; procedure fxpositive? (fxpositive? n) ;; procedure fxquotient (fxquotient n1 n2) ;; procedure fxremainder (fxremainder n1 n2) ;; procedure fxwrap* (fxwrap* n1 ...) ;; procedure fxwrap+ (fxwrap+ n1 ...) ;; procedure fxwrap- (fxwrap- n1 n2 ...) ;; procedure fxwrapabs (fxwrapabs n) ;; procedure fxwraparithmetic-shift (fxwraparithmetic-shift n1 n2) ;; procedure fxwraparithmetic-shift-left (fxwraparithmetic-shift-left n1 n2) ;; procedure fxwraplogical-shift-right (fxwraplogical-shift-right n1 n2) ;; procedure fxwrapquotient (fxwrapquotient n1 n2) ;; procedure fxxor (fxxor n1 ...) ;; procedure fxzero? (fxzero? n) ;; procedure fxsquare (fxsquare n) ;; procedure fxwrapsquare (fxwrapsquare n) ;; procedure fixnum-overflow-exception? (fixnum-overflow-exception? obj) ;; procedure fixnum-overflow-exception-procedure (fixnum-overflow-exception-procedure exc) ;; procedure fixnum-overflow-exception-arguments (fixnum-overflow-exception-arguments exc) ;; procedure Fixnum-overflow-exception objects are raised by some of the fixnum specific procedures when the result is larger than can fit in a fixnum. The parameter exc must be a fixnum-overflow-exception object. The procedure fixnum-overflow-exception? returns #t when obj is a fixnum-overflow-exception object and #f otherwise. The procedure fixnum-overflow-exception-procedure returns the procedure that raised exc . The procedure fixnum-overflow-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define (handler exc) (if (fixnum-overflow-exception? exc) (list (fixnum-overflow-exception-procedure exc) (fixnum-overflow-exception-arguments exc)) 'not-fixnum-overflow-exception)) > (with-exception-catcher handler (lambda () (fx* 100000 100000))) (#<procedure #2 fx*> (100000 100000)) Pseudo random numbers The procedures and variables defined in this section are compatible with the \"Sources of Random Bits SRFI\" ( SRFI 27 ). The implementation is based on Pierre L\u2019Ecuyer's MRG32k3a pseudo random number generator. At the heart of SRFI 27's interface is the random source type which encapsulates the state of a pseudo random number generator. The state of a random source object changes every time a pseudo random number is generated from this random source object. default-random-source (default-random-source) ;; variable The global variable default-random-source is bound to the random source object which is used by the random-integer , random-real , random-u8vector and random-f64vector procedures. random-integer (random-integer n) ;; procedure This procedure returns a pseudo random exact integer in the range 0 to n-1 . The random source object in the global variable default-random-source is used to generate this number. The parameter n must be a positive exact integer. For example: > (random-integer 100) 24 > (random-integer 100) 2 > (random-integer 10000000000000000000000000000000000000000) 6143360270902284438072426748425263488507 random-real (random-real) ;; procedure This procedure returns a pseudo random inexact real between, but not including, 0 and 1 . The random source object in the global variable default-random-source is used to generate this number. For example: > (random-real) .24230672079133753 > (random-real) .02317001922506932 random-u8vector (random-u8vector n) ;; procedure This procedure returns a u8vector of length n containing pseudo random exact integers in the range 0 to 255 . The random source object in the global variable default-random-source is used to generate these numbers. The parameter n must be a nonnegative exact integer. For example: > (random-u8vector 10) #u8(200 53 29 202 3 85 208 187 73 219) random-f64vector (random-f64vector n) ;; procedure This procedure returns a f64vector of length n containing pseudo random inexact reals between, but not including, 0 and 1. The random source object in the global variable default-random-source is used to generate these numbers. The parameter n must be a nonnegative exact integer. For example: > (random-f64vector 3) #f64(.7145854494613069 .47089632669147946 .5400124875182746) make-random-source (make-random-source) ;; procedure This procedure returns a new random source object initialized to a predetermined state (to initialize to a pseudo random state the procedure random-source-randomize! should be called). For example: > (define rs (make-random-source)) > ((random-source-make-integers rs) 10000000) 8583952 random-source? (random-source? obj) ;; procedure This procedure returns #t when obj is a random source object and #f otherwise. For example: > (random-source? default-random-source) #t > (random-source? 123) #f random-source-state-ref random-source-state-set! `scheme (random-source-state-ref random-source) procedure (random-source-state-set! random-source state) procedure The procedure random-source-state-ref extracts the state of the random source object random-source and returns a vector containing the state. The procedure random-source-state-set! restores the state of the random source object random-source to state which must be a vector returned from a call to the procedure random-source-state-ref . For example: ```scheme (define s (random-source-state-ref default-random-source)) (random-integer 10000000000000000000000000000000000000000) 7583880188903074396261960585615270693321 (random-source-state-set! default-random-source s) (random-integer 10000000000000000000000000000000000000000) 7583880188903074396261960585615270693321 ``` random-source-randomize! random-source-pseudo-randomize! scheme (random-source-randomize! random-source) ;; procedure (random-source-pseudo-randomize! random-source i j) ;; procedure These procedures change the state of the random source object random-source . The procedure random-source-randomize! sets the random source object to a state that depends on the current time (which for typical uses can be considered to randomly initialize the state). The procedure random-source-pseudo-randomize! sets the random source object to a state that is determined only by the current state and the nonnegative exact integers i and j . For both procedures the value returned is unspecified. For example: ```scheme (define s (random-source-state-ref default-random-source)) (random-source-pseudo-randomize! default-random-source 5 99) (random-integer 10000000000000000000000000000000000000000) 9816755163910623041601722050112674079767 (random-source-state-set! default-random-source s) (random-source-pseudo-randomize! default-random-source 5 99) (random-integer 10000000000000000000000000000000000000000) 9816755163910623041601722050112674079767 (random-source-pseudo-randomize! default-random-source 5 99) (random-integer 10000000000000000000000000000000000000000) 9816755163910623041601722050112674079767 (random-source-state-set! default-random-source s) (random-source-randomize! default-random-source) (random-integer 10000000000000000000000000000000000000000) 2271441220851914333384493143687768110622 (random-source-state-set! default-random-source s) (random-source-randomize! default-random-source) (random-integer 10000000000000000000000000000000000000000) 6247966138948323029033944059178072366895 ``` random-source-make-integers scheme (random-source-make-integers random-source) ;; procedure This procedure returns a procedure for generating pseudo random exact integers using the random source object random-source . The returned procedure accepts a single parameter n , a positive exact integer, and returns a pseudo random exact integer in the range 0 to n-1 . For example: ```scheme (define rs (make-random-source)) (define ri (random-source-make-integers rs)) (ri 10000000) 8583952 (ri 10000000) 2879793 ``` random-source-make-reals scheme (random-source-make-reals random-source [precision]) ;; procedure This procedure returns a procedure for generating pseudo random inexact reals using the random source object random-source . The returned procedure accepts no parameters and returns a pseudo random inexact real between, but not including, 0 and 1 . The optional parameter precision specifies an upper bound on the minimum amount by which two generated pseudo-random numbers can be separated. For example: ```scheme (define rs (make-random-source)) (define rr (random-source-make-reals rs)) (rr) .857402537562821 (rr) .2876463473845367 ``` random-source-make-u8vectors scheme (random-source-make-u8vectors random-source) ;; procedure This procedure returns a procedure for generating pseudo random u8vectors using the random source object random-source . The returned procedure accepts a single parameter n , a nonnegative exact integer, and returns a u8vector of length n containing pseudo random exact integers in the range 0 to 255 . For example: ```scheme (define rs (make-random-source)) (define rv (random-source-make-u8vectors rs)) (rv 10) u8(200 53 29 202 3 85 208 187 73 219) (rv 10) u8(113 8 182 120 138 103 53 192 40 176) ``` random-source-make-f64vectors scheme (random-source-make-f64vectors random-source [precision]) ;; procedure This procedure returns a procedure for generating pseudo random f64vectors using the random source object random-source . The returned procedure accepts a single parameter n , a nonnegative exact integer, and returns an f64vector of length n containing pseudo random inexact reals between, but not including, 0 and 1 . The optional parameter precision specifies an upper bound on the minimum amount by which two generated pseudo-random numbers can be separated. For example: ```scheme (define rv (random-source-make-f64vectors rs)) (rv 3) f64(.7342236104231586 .2876463473845367 .8574025375628211) (rv 3) f64(.013863292728449427 .33449296573515447 .8162050798467028) ```","title":"Numbers"},{"location":"manual/built_in_data_types/numbers/#numbers","text":"","title":"Numbers"},{"location":"manual/built_in_data_types/numbers/#extensions-to-numeric-procedures","text":"","title":"Extensions to numeric procedures"},{"location":"manual/built_in_data_types/numbers/#_1","text":"","title":"="},{"location":"manual/built_in_data_types/numbers/#_2","text":"","title":"&lt;"},{"location":"manual/built_in_data_types/numbers/#_3","text":"","title":"&gt;"},{"location":"manual/built_in_data_types/numbers/#_4","text":"","title":"&lt;="},{"location":"manual/built_in_data_types/numbers/#_5","text":"(= z1 ...) ;; procedure (< x1 ...) ;; procedure (> x1 ...) ;; procedure (<= x1 ...) ;; procedure (>= x1 ...) ;; procedure These procedures take any number of arguments including no argument. This is useful to test if the elements of a list are sorted in a particular order. For example, testing that the list of numbers lst is sorted in nondecreasing order can be done with the call (apply < lst) .","title":"&gt;="},{"location":"manual/built_in_data_types/numbers/#ieee-floating-point-arithmetic","text":"To better conform to IEEE floating point arithmetic the standard numeric tower is extended with these special inexact reals: +inf.0 : positive infinity -inf.0 : negative infinity +nan.0 : \"not a number\" -0. : negative zero ( 0. is the positive zero) The infinities and \"not a number\" are reals (i.e. (real? +inf.0) is #t ) but are not rational (i.e. (rational? +inf.0) is #f ). Both zeros are numerically equal (i.e. (= -0. 0.) is #t ) but are not equivalent (i.e. (eqv? -0. 0.) and (equal? -0. 0.) are #f ). All numerical comparisons with \"not a number\", including (= +nan.0 +nan.0) , are #f .","title":"IEEE floating point arithmetic"},{"location":"manual/built_in_data_types/numbers/#integer-square-root-and-nth-root","text":"","title":"Integer square root and nth root"},{"location":"manual/built_in_data_types/numbers/#integer-sqrt","text":"(integer-sqrt n) ;; procedure This procedure returns the integer part of the square root of the nonnegative exact integer n . For example: > (integer-sqrt 123) 11","title":"integer-sqrt"},{"location":"manual/built_in_data_types/numbers/#integer-nth-root","text":"(integer-nth-root n1 n2) ;; procedure This procedure returns the integer part of n1 raised to the power 1/n2 , where n1 is a nonnegative exact integer and n2 is a positive exact integer. For example: > (integer-nth-root 100 3) 4","title":"integer-nth-root"},{"location":"manual/built_in_data_types/numbers/#bitwise-operations-on-exact-integers","text":"The procedures defined in this section are compatible with the withdrawn \"Integer Bitwise-operation Library SRFI\" ( SRFI 33 ). Note that some of the procedures specified in SRFI 33 are not provided. Most procedures in this section are specified in terms of the binary representation of exact integers. The two's complement representation is assumed where an integer is composed of an infinite number of bits. The upper section of an integer (the most significant bits) are either an infinite sequence of ones when the integer is negative, or they are an infinite sequence of zeros when the integer is nonnegative.","title":"Bitwise-operations on exact integers"},{"location":"manual/built_in_data_types/numbers/#arithmetic-shift","text":"(arithmetic-shift n1 n2) ;; procedure This procedure returns n1 shifted to the left by n2 bits, that is (floor (* n1 (expt 2 n2))) . Both n1 and n2 must be exact integers. For example: > (arithmetic-shift 1000 7) ; n1=...0000001111101000 128000 > (arithmetic-shift 1000 -6) ; n1=...0000001111101000 15 > (arithmetic-shift -23 -3) ; n1=...1111111111101001 -3","title":"arithmetic-shift"},{"location":"manual/built_in_data_types/numbers/#bitwise-merge","text":"(bitwise-merge n1 n2 n3) ;; procedure This procedure returns an exact integer whose bits combine the bits from n2 and n3 depending on n1 . The bit at index i of the result depends only on the bits at index i in n1 , n2 and n3 : it is equal to the bit in n2 when the bit in n1 is 0 and it is equal to the bit in n3 when the bit in n1 is 1. All arguments must be exact integers. For example: > (bitwise-merge -4 -11 10) ; ...11111100 ...11110101 ...00001010 9 > (bitwise-merge 12 -11 10) ; ...00001100 ...11110101 ...00001010 -7","title":"bitwise-merge"},{"location":"manual/built_in_data_types/numbers/#bitwise-and","text":"(bitwise-and n ...) ;; procedure This procedure returns the bitwise \"and\" of the exact integers n ... . The value -1 is returned when there are no arguments. For example: > (bitwise-and 6 12) ; ...00000110 ...00001100 4 > (bitwise-and 6 -4) ; ...00000110 ...11111100 4 > (bitwise-and -6 -4) ; ...11111010 ...11111100 -8 > (bitwise-and) -1","title":"bitwise-and"},{"location":"manual/built_in_data_types/numbers/#bitwise-andc1","text":"(bitwise-andc1 n1 n2) ;; procedure This procedure returns the bitwise \"and\" of the bitwise complement of the exact integer n1 and the exact integer n2 . For example: > (bitwise-andc1 11 26) ; ...00001011 ...00011010 16 > (bitwise-andc1 -12 26) ; ...11110100 ...00011010 10","title":"bitwise-andc1"},{"location":"manual/built_in_data_types/numbers/#bitwise-andc2","text":"(bitwise-andc2 n1 n2) ;; procedure This procedure returns the bitwise \"and\" of the exact integer n1 and the bitwise complement of the exact integer n2 . For example: > (bitwise-andc2 11 26) ; ...00001011 ...00011010 1 > (bitwise-andc2 11 -27) ; ...00001011 ...11100101 10","title":"bitwise-andc2"},{"location":"manual/built_in_data_types/numbers/#bitwise-eqv","text":"(bitwise-eqv n ...) ;; procedure This procedure returns the bitwise complement of the bitwise \"exclusive-or\" of the exact integers n ... . The value -1 is returned when there are no arguments. For example: > (bitwise-eqv 6 12) ; ...00000110 ...00001100 -11 > (bitwise-eqv 6 -4) ; ...00000110 ...11111100 5 > (bitwise-eqv -6 -4) ; ...11111010 ...11111100 -7 > (bitwise-eqv) -1","title":"bitwise-eqv"},{"location":"manual/built_in_data_types/numbers/#bitwise-ior","text":"(bitwise-ior n ...) ;; procedure This procedure returns the bitwise \"inclusive-or\" of the exact integers n ... . The value 0 is returned when there are no arguments. For example: > (bitwise-ior 6 12) ; ...00000110 ...00001100 14 > (bitwise-ior 6 -4) ; ...00000110 ...11111100 -2 > (bitwise-ior -6 -4) ; ...11111010 ...11111100 -2 > (bitwise-ior) 0","title":"bitwise-ior"},{"location":"manual/built_in_data_types/numbers/#bitwise-nand","text":"(bitwise-nand n1 n2) ;; procedure This procedure returns the bitwise complement of the bitwise \"and\" of the exact integer n1 and the exact integer n2 . For example: > (bitwise-nand 11 26) ; ...00001011 ...00011010 -11 > (bitwise-nand 11 -27) ; ...00001011 ...11100101 -2","title":"bitwise-nand"},{"location":"manual/built_in_data_types/numbers/#bitwise-nor","text":"(bitwise-nor n1 n2) ;; procedure This procedure returns the bitwise complement of the bitwise \"inclusive-or\" of the exact integer n1 and the exact integer n2 . For example: > (bitwise-nor 11 26) ; ...00001011 ...00011010 -28 > (bitwise-nor 11 -27) ; ...00001011 ...11100101 16","title":"bitwise-nor"},{"location":"manual/built_in_data_types/numbers/#bitwise-not","text":"(bitwise-not n) ;; procedure This procedure returns the bitwise complement of the exact integer n . For example: > (bitwise-not 3) ; ...00000011 -4 > (bitwise-not -1) ; ...11111111 0","title":"bitwise-not"},{"location":"manual/built_in_data_types/numbers/#bitwise-orc1","text":"(bitwise-orc1 n1 n2) ;; procedure This procedure returns the bitwise \"inclusive-or\" of the bitwise complement of the exact integer n1 and the exact integer n2 . For example: > (bitwise-orc1 11 26) ; ...00001011 ...00011010 -2 > (bitwise-orc1 -12 26) ; ...11110100 ...00011010 27","title":"bitwise-orc1"},{"location":"manual/built_in_data_types/numbers/#bitwise-orc2","text":"(bitwise-orc2 n1 n2) ;; procedure This procedure returns the bitwise \"inclusive-or\" of the exact integer n1 and the bitwise complement of the exact integer n2 . For example: > (bitwise-orc2 11 26) ; ...00001011 ...00011010 -17 > (bitwise-orc2 11 -27) ; ...00001011 ...11100101 27","title":"bitwise-orc2"},{"location":"manual/built_in_data_types/numbers/#bitwise-xor","text":"(bitwise-xor n ...) ;; procedure This procedure returns the bitwise \"exclusive-or\" of the exact integers n ... . The value 0 is returned when there are no arguments. For example: > (bitwise-xor 6 12) ; ...00000110 ...00001100 10 > (bitwise-xor 6 -4) ; ...00000110 ...11111100 -6 > (bitwise-xor -6 -4) ; ...11111010 ...11111100 6 > (bitwise-xor) 0","title":"bitwise-xor"},{"location":"manual/built_in_data_types/numbers/#bit-count","text":"(bit-count n) ;; procedure This procedure returns the bit count of the exact integer n . If n is nonnegative, the bit count is the number of 1 bits in the two's complement representation of n . If n is negative, the bit count is the number of 0 bits in the two's complement representation of n . For example: > (bit-count 0) ; ...00000000 0 > (bit-count 1) ; ...00000001 1 > (bit-count 2) ; ...00000010 1 > (bit-count 3) ; ...00000011 2 > (bit-count 4) ; ...00000100 1 > (bit-count -23) ; ...11101001 3","title":"bit-count"},{"location":"manual/built_in_data_types/numbers/#integer-length","text":"(integer-length n) ;; procedure This procedure returns the bit length of the exact integer n . If n is a positive integer the bit length is one more than the index of the highest 1 bit (the least significant bit is at index 0). If n is a negative integer the bit length is one more than the index of the highest 0 bit. If n is zero, the bit length is 0. For example: > (integer-length 0) ; ...00000000 0 > (integer-length 1) ; ...00000001 1 > (integer-length 2) ; ...00000010 2 > (integer-length 3) ; ...00000011 2 > (integer-length 4) ; ...00000100 3 > (integer-length -23) ; ...11101001 5","title":"integer-length"},{"location":"manual/built_in_data_types/numbers/#bit-set","text":"(bit-set? n1 n2) ;; procedure This procedure returns a boolean indicating if the bit at index n1 of n2 is set (i.e. equal to 1 ) or not. Both n1 and n2 must be exact integers, and n1 must be nonnegative. For example: > (map (lambda (i) (bit-set? i -23)) ; ...11101001 '(7 6 5 4 3 2 1 0)) (#t #t #t #f #t #f #f #t)","title":"bit-set?"},{"location":"manual/built_in_data_types/numbers/#any-bits-set","text":"(any-bits-set? n1 n2) ;; procedure This procedure returns a boolean indicating if the bitwise and of n1 and n2 is different from zero or not. This procedure is implemented more efficiently than the naive definition: (define (any-bits-set? n1 n2) (not (zero? (bitwise-and n1 n2)))) For example: > (any-bits-set? 5 10) ; ...00000101 ...00001010 #f > (any-bits-set? -23 32) ; ...11101001 ...00100000 #t","title":"any-bits-set?"},{"location":"manual/built_in_data_types/numbers/#all-bits-set","text":"(all-bits-set? n1 n2) ;; procedure This procedure returns a boolean indicating if the \"bitwise and\" of n1 and n2 is equal to n1 or not. This procedure is implemented more efficiently than the naive definition: (define (all-bits-set? n1 n2) (= n1 (bitwise-and n1 n2))) For example: > (all-bits-set? 1 3) ; ...00000001 ...00000011 #t > (all-bits-set? 7 3) ; ...00000111 ...00000011 #f","title":"all-bits-set?"},{"location":"manual/built_in_data_types/numbers/#first-set-bit","text":"(first-set-bit n) ;; procedure This procedure returns the bit index of the least significant bit of n equal to 1 (which is also the number of 0 bits that are below the least significant 1 bit). This procedure returns -1 when n is zero. For example: > (first-set-bit 24) ; ...00011000 3 > (first-set-bit 0) ; ...00000000 -1","title":"first-set-bit"},{"location":"manual/built_in_data_types/numbers/#extract-bit-field","text":"","title":"extract-bit-field"},{"location":"manual/built_in_data_types/numbers/#test-bit-field","text":"","title":"test-bit-field?"},{"location":"manual/built_in_data_types/numbers/#clear-bit-field","text":"","title":"clear-bit-field"},{"location":"manual/built_in_data_types/numbers/#replace-bit-field","text":"","title":"replace-bit-field"},{"location":"manual/built_in_data_types/numbers/#copy-bit-field","text":"(extract-bit-field n1 n2 n3) ;; procedure (test-bit-field? n1 n2 n3) ;; procedure (clear-bit-field n1 n2 n3) ;; procedure (replace-bit-field n1 n2 n3 n4) ;; procedure (copy-bit-field n1 n2 n3 n4) ;; procedure These procedures operate on a bit-field which is n1 bits wide starting at bit index n2 . All arguments must be exact integers and n1 and n2 must be nonnegative. The procedure extract-bit-field returns the bit-field of n3 shifted to the right so that the least significant bit of the bit-field is the least significant bit of the result. The procedure test-bit-field? returns #t if any bit in the bit-field of n3 is equal to 1 , otherwise #f is returned. The procedure clear-bit-field returns n3 with all bits in the bit-field replaced with 0 . The procedure replace-bit-field returns n4 with the bit-field replaced with the least-significant n1 bits of n3 . The procedure copy-bit-field returns n4 with the bit-field replaced with the (same index and size) bit-field in n3 . For example: > (extract-bit-field 5 2 -37) ; ...11011011 22 > (test-bit-field? 5 2 -37) ; ...11011011 #t > (test-bit-field? 1 2 -37) ; ...11011011 #f > (clear-bit-field 5 2 -37) ; ...11011011 -125 > (replace-bit-field 5 2 -6 -37) ; ...11111010 ...11011011 -21 > (copy-bit-field 5 2 -6 -37) ; ...11111010 ...11011011 -5","title":"copy-bit-field"},{"location":"manual/built_in_data_types/numbers/#fixnum-specific-operations","text":"This documentation needs work, cleanup or clarification.","title":"Fixnum-specific operations"},{"location":"manual/built_in_data_types/numbers/#fixnum","text":"(fixnum? obj) ;; procedure","title":"fixnum?"},{"location":"manual/built_in_data_types/numbers/#fx","text":"(fx* n1 ...) ;; procedure","title":"fx*"},{"location":"manual/built_in_data_types/numbers/#fx_1","text":"(fx+ n1 ...) ;; procedure","title":"fx+"},{"location":"manual/built_in_data_types/numbers/#fx-","text":"(fx- n1 n2 ...) ;; procedure","title":"fx-"},{"location":"manual/built_in_data_types/numbers/#fx_2","text":"(fx< n1 ...) ;; procedure","title":"fx&lt;"},{"location":"manual/built_in_data_types/numbers/#fx_3","text":"(fx<= n1 ...) ;; procedure","title":"fx&lt;="},{"location":"manual/built_in_data_types/numbers/#fx_4","text":"(fx= n1 ...) ;; procedure","title":"fx="},{"location":"manual/built_in_data_types/numbers/#fx_5","text":"(fx> n1 ...) ;; procedure","title":"fx&gt;"},{"location":"manual/built_in_data_types/numbers/#fx_6","text":"(fx>= n1 ...) ;; procedure","title":"fx&gt;="},{"location":"manual/built_in_data_types/numbers/#fxabs","text":"(fxabs n) ;; procedure","title":"fxabs"},{"location":"manual/built_in_data_types/numbers/#fxand","text":"(fxand n1 ...) ;; procedure","title":"fxand"},{"location":"manual/built_in_data_types/numbers/#fxandc1","text":"(fxandc1 n1 n2) ;; procedure","title":"fxandc1"},{"location":"manual/built_in_data_types/numbers/#fxandc2","text":"(fxandc2 n1 n2) ;; procedure","title":"fxandc2"},{"location":"manual/built_in_data_types/numbers/#fxarithmetic-shift","text":"(fxarithmetic-shift n1 n2) ;; procedure","title":"fxarithmetic-shift"},{"location":"manual/built_in_data_types/numbers/#fxarithmetic-shift-left","text":"(fxarithmetic-shift-left n1 n2) ;; procedure","title":"fxarithmetic-shift-left"},{"location":"manual/built_in_data_types/numbers/#fxarithmetic-shift-right","text":"(fxarithmetic-shift-right n1 n2) ;; procedure","title":"fxarithmetic-shift-right"},{"location":"manual/built_in_data_types/numbers/#fxbit-count","text":"(fxbit-count n) ;; procedure","title":"fxbit-count"},{"location":"manual/built_in_data_types/numbers/#fxbit-set","text":"(fxbit-set? n1 n2) ;; procedure","title":"fxbit-set?"},{"location":"manual/built_in_data_types/numbers/#fxeqv","text":"(fxeqv n1 ...) ;; procedure","title":"fxeqv"},{"location":"manual/built_in_data_types/numbers/#fxeven","text":"(fxeven? n) ;; procedure","title":"fxeven?"},{"location":"manual/built_in_data_types/numbers/#fxfirst-set-bit","text":"(fxfirst-set-bit n) ;; procedure","title":"fxfirst-set-bit"},{"location":"manual/built_in_data_types/numbers/#fxif","text":"(fxif n1 n2 n3) ;; procedure","title":"fxif"},{"location":"manual/built_in_data_types/numbers/#fxior","text":"(fxior n1 ...) ;; procedure","title":"fxior"},{"location":"manual/built_in_data_types/numbers/#fxlength","text":"(fxlength n) ;; procedure","title":"fxlength"},{"location":"manual/built_in_data_types/numbers/#fxmax","text":"(fxmax n1 n2 ...) ;; procedure","title":"fxmax"},{"location":"manual/built_in_data_types/numbers/#fxmin","text":"(fxmin n1 n2 ...) ;; procedure","title":"fxmin"},{"location":"manual/built_in_data_types/numbers/#fxmodulo","text":"(fxmodulo n1 n2) ;; procedure","title":"fxmodulo"},{"location":"manual/built_in_data_types/numbers/#fxnegative","text":"(fxnegative? n) ;; procedure","title":"fxnegative?"},{"location":"manual/built_in_data_types/numbers/#fxnand","text":"(fxnand n1 n2) ;; procedure","title":"fxnand"},{"location":"manual/built_in_data_types/numbers/#fxnor","text":"(fxnor n1 n2) ;; procedure","title":"fxnor"},{"location":"manual/built_in_data_types/numbers/#fxnot","text":"(fxnot n) ;; procedure","title":"fxnot"},{"location":"manual/built_in_data_types/numbers/#fxodd","text":"(fxodd? n) ;; procedure","title":"fxodd?"},{"location":"manual/built_in_data_types/numbers/#fxorc1","text":"(fxorc1 n1 n2) ;; procedure","title":"fxorc1"},{"location":"manual/built_in_data_types/numbers/#fxorc2","text":"(fxorc2 n1 n2) ;; procedure","title":"fxorc2"},{"location":"manual/built_in_data_types/numbers/#fxpositive","text":"(fxpositive? n) ;; procedure","title":"fxpositive?"},{"location":"manual/built_in_data_types/numbers/#fxquotient","text":"(fxquotient n1 n2) ;; procedure","title":"fxquotient"},{"location":"manual/built_in_data_types/numbers/#fxremainder","text":"(fxremainder n1 n2) ;; procedure","title":"fxremainder"},{"location":"manual/built_in_data_types/numbers/#fxwrap","text":"(fxwrap* n1 ...) ;; procedure","title":"fxwrap*"},{"location":"manual/built_in_data_types/numbers/#fxwrap_1","text":"(fxwrap+ n1 ...) ;; procedure","title":"fxwrap+"},{"location":"manual/built_in_data_types/numbers/#fxwrap-","text":"(fxwrap- n1 n2 ...) ;; procedure","title":"fxwrap-"},{"location":"manual/built_in_data_types/numbers/#fxwrapabs","text":"(fxwrapabs n) ;; procedure","title":"fxwrapabs"},{"location":"manual/built_in_data_types/numbers/#fxwraparithmetic-shift","text":"(fxwraparithmetic-shift n1 n2) ;; procedure","title":"fxwraparithmetic-shift"},{"location":"manual/built_in_data_types/numbers/#fxwraparithmetic-shift-left","text":"(fxwraparithmetic-shift-left n1 n2) ;; procedure","title":"fxwraparithmetic-shift-left"},{"location":"manual/built_in_data_types/numbers/#fxwraplogical-shift-right","text":"(fxwraplogical-shift-right n1 n2) ;; procedure","title":"fxwraplogical-shift-right"},{"location":"manual/built_in_data_types/numbers/#fxwrapquotient","text":"(fxwrapquotient n1 n2) ;; procedure","title":"fxwrapquotient"},{"location":"manual/built_in_data_types/numbers/#fxxor","text":"(fxxor n1 ...) ;; procedure","title":"fxxor"},{"location":"manual/built_in_data_types/numbers/#fxzero","text":"(fxzero? n) ;; procedure","title":"fxzero?"},{"location":"manual/built_in_data_types/numbers/#fxsquare","text":"(fxsquare n) ;; procedure","title":"fxsquare"},{"location":"manual/built_in_data_types/numbers/#fxwrapsquare","text":"(fxwrapsquare n) ;; procedure","title":"fxwrapsquare"},{"location":"manual/built_in_data_types/numbers/#fixnum-overflow-exception","text":"(fixnum-overflow-exception? obj) ;; procedure","title":"fixnum-overflow-exception?"},{"location":"manual/built_in_data_types/numbers/#fixnum-overflow-exception-procedure","text":"(fixnum-overflow-exception-procedure exc) ;; procedure","title":"fixnum-overflow-exception-procedure"},{"location":"manual/built_in_data_types/numbers/#fixnum-overflow-exception-arguments","text":"(fixnum-overflow-exception-arguments exc) ;; procedure Fixnum-overflow-exception objects are raised by some of the fixnum specific procedures when the result is larger than can fit in a fixnum. The parameter exc must be a fixnum-overflow-exception object. The procedure fixnum-overflow-exception? returns #t when obj is a fixnum-overflow-exception object and #f otherwise. The procedure fixnum-overflow-exception-procedure returns the procedure that raised exc . The procedure fixnum-overflow-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define (handler exc) (if (fixnum-overflow-exception? exc) (list (fixnum-overflow-exception-procedure exc) (fixnum-overflow-exception-arguments exc)) 'not-fixnum-overflow-exception)) > (with-exception-catcher handler (lambda () (fx* 100000 100000))) (#<procedure #2 fx*> (100000 100000))","title":"fixnum-overflow-exception-arguments"},{"location":"manual/built_in_data_types/numbers/#pseudo-random-numbers","text":"The procedures and variables defined in this section are compatible with the \"Sources of Random Bits SRFI\" ( SRFI 27 ). The implementation is based on Pierre L\u2019Ecuyer's MRG32k3a pseudo random number generator. At the heart of SRFI 27's interface is the random source type which encapsulates the state of a pseudo random number generator. The state of a random source object changes every time a pseudo random number is generated from this random source object.","title":"Pseudo random numbers"},{"location":"manual/built_in_data_types/numbers/#default-random-source","text":"(default-random-source) ;; variable The global variable default-random-source is bound to the random source object which is used by the random-integer , random-real , random-u8vector and random-f64vector procedures.","title":"default-random-source"},{"location":"manual/built_in_data_types/numbers/#random-integer","text":"(random-integer n) ;; procedure This procedure returns a pseudo random exact integer in the range 0 to n-1 . The random source object in the global variable default-random-source is used to generate this number. The parameter n must be a positive exact integer. For example: > (random-integer 100) 24 > (random-integer 100) 2 > (random-integer 10000000000000000000000000000000000000000) 6143360270902284438072426748425263488507","title":"random-integer"},{"location":"manual/built_in_data_types/numbers/#random-real","text":"(random-real) ;; procedure This procedure returns a pseudo random inexact real between, but not including, 0 and 1 . The random source object in the global variable default-random-source is used to generate this number. For example: > (random-real) .24230672079133753 > (random-real) .02317001922506932","title":"random-real"},{"location":"manual/built_in_data_types/numbers/#random-u8vector","text":"(random-u8vector n) ;; procedure This procedure returns a u8vector of length n containing pseudo random exact integers in the range 0 to 255 . The random source object in the global variable default-random-source is used to generate these numbers. The parameter n must be a nonnegative exact integer. For example: > (random-u8vector 10) #u8(200 53 29 202 3 85 208 187 73 219)","title":"random-u8vector"},{"location":"manual/built_in_data_types/numbers/#random-f64vector","text":"(random-f64vector n) ;; procedure This procedure returns a f64vector of length n containing pseudo random inexact reals between, but not including, 0 and 1. The random source object in the global variable default-random-source is used to generate these numbers. The parameter n must be a nonnegative exact integer. For example: > (random-f64vector 3) #f64(.7145854494613069 .47089632669147946 .5400124875182746)","title":"random-f64vector"},{"location":"manual/built_in_data_types/numbers/#make-random-source","text":"(make-random-source) ;; procedure This procedure returns a new random source object initialized to a predetermined state (to initialize to a pseudo random state the procedure random-source-randomize! should be called). For example: > (define rs (make-random-source)) > ((random-source-make-integers rs) 10000000) 8583952","title":"make-random-source"},{"location":"manual/built_in_data_types/numbers/#random-source","text":"(random-source? obj) ;; procedure This procedure returns #t when obj is a random source object and #f otherwise. For example: > (random-source? default-random-source) #t > (random-source? 123) #f","title":"random-source?"},{"location":"manual/built_in_data_types/numbers/#random-source-state-ref","text":"","title":"random-source-state-ref"},{"location":"manual/built_in_data_types/numbers/#random-source-state-set","text":"`scheme (random-source-state-ref random-source) procedure (random-source-state-set! random-source state) procedure The procedure random-source-state-ref extracts the state of the random source object random-source and returns a vector containing the state. The procedure random-source-state-set! restores the state of the random source object random-source to state which must be a vector returned from a call to the procedure random-source-state-ref . For example: ```scheme (define s (random-source-state-ref default-random-source)) (random-integer 10000000000000000000000000000000000000000) 7583880188903074396261960585615270693321 (random-source-state-set! default-random-source s) (random-integer 10000000000000000000000000000000000000000) 7583880188903074396261960585615270693321 ```","title":"random-source-state-set!"},{"location":"manual/built_in_data_types/numbers/#random-source-randomize","text":"","title":"random-source-randomize!"},{"location":"manual/built_in_data_types/numbers/#random-source-pseudo-randomize","text":"scheme (random-source-randomize! random-source) ;; procedure (random-source-pseudo-randomize! random-source i j) ;; procedure These procedures change the state of the random source object random-source . The procedure random-source-randomize! sets the random source object to a state that depends on the current time (which for typical uses can be considered to randomly initialize the state). The procedure random-source-pseudo-randomize! sets the random source object to a state that is determined only by the current state and the nonnegative exact integers i and j . For both procedures the value returned is unspecified. For example: ```scheme (define s (random-source-state-ref default-random-source)) (random-source-pseudo-randomize! default-random-source 5 99) (random-integer 10000000000000000000000000000000000000000) 9816755163910623041601722050112674079767 (random-source-state-set! default-random-source s) (random-source-pseudo-randomize! default-random-source 5 99) (random-integer 10000000000000000000000000000000000000000) 9816755163910623041601722050112674079767 (random-source-pseudo-randomize! default-random-source 5 99) (random-integer 10000000000000000000000000000000000000000) 9816755163910623041601722050112674079767 (random-source-state-set! default-random-source s) (random-source-randomize! default-random-source) (random-integer 10000000000000000000000000000000000000000) 2271441220851914333384493143687768110622 (random-source-state-set! default-random-source s) (random-source-randomize! default-random-source) (random-integer 10000000000000000000000000000000000000000) 6247966138948323029033944059178072366895 ```","title":"random-source-pseudo-randomize!"},{"location":"manual/built_in_data_types/numbers/#random-source-make-integers","text":"scheme (random-source-make-integers random-source) ;; procedure This procedure returns a procedure for generating pseudo random exact integers using the random source object random-source . The returned procedure accepts a single parameter n , a positive exact integer, and returns a pseudo random exact integer in the range 0 to n-1 . For example: ```scheme (define rs (make-random-source)) (define ri (random-source-make-integers rs)) (ri 10000000) 8583952 (ri 10000000) 2879793 ```","title":"random-source-make-integers"},{"location":"manual/built_in_data_types/numbers/#random-source-make-reals","text":"scheme (random-source-make-reals random-source [precision]) ;; procedure This procedure returns a procedure for generating pseudo random inexact reals using the random source object random-source . The returned procedure accepts no parameters and returns a pseudo random inexact real between, but not including, 0 and 1 . The optional parameter precision specifies an upper bound on the minimum amount by which two generated pseudo-random numbers can be separated. For example: ```scheme (define rs (make-random-source)) (define rr (random-source-make-reals rs)) (rr) .857402537562821 (rr) .2876463473845367 ```","title":"random-source-make-reals"},{"location":"manual/built_in_data_types/numbers/#random-source-make-u8vectors","text":"scheme (random-source-make-u8vectors random-source) ;; procedure This procedure returns a procedure for generating pseudo random u8vectors using the random source object random-source . The returned procedure accepts a single parameter n , a nonnegative exact integer, and returns a u8vector of length n containing pseudo random exact integers in the range 0 to 255 . For example: ```scheme (define rs (make-random-source)) (define rv (random-source-make-u8vectors rs)) (rv 10)","title":"random-source-make-u8vectors"},{"location":"manual/built_in_data_types/numbers/#u8200-53-29-202-3-85-208-187-73-219","text":"(rv 10)","title":"u8(200 53 29 202 3 85 208 187 73 219)"},{"location":"manual/built_in_data_types/numbers/#u8113-8-182-120-138-103-53-192-40-176","text":"```","title":"u8(113 8 182 120 138 103 53 192 40 176)"},{"location":"manual/built_in_data_types/numbers/#random-source-make-f64vectors","text":"scheme (random-source-make-f64vectors random-source [precision]) ;; procedure This procedure returns a procedure for generating pseudo random f64vectors using the random source object random-source . The returned procedure accepts a single parameter n , a nonnegative exact integer, and returns an f64vector of length n containing pseudo random inexact reals between, but not including, 0 and 1 . The optional parameter precision specifies an upper bound on the minimum amount by which two generated pseudo-random numbers can be separated. For example: ```scheme (define rv (random-source-make-f64vectors rs)) (rv 3)","title":"random-source-make-f64vectors"},{"location":"manual/built_in_data_types/numbers/#f647342236104231586-2876463473845367-8574025375628211","text":"(rv 3)","title":"f64(.7342236104231586 .2876463473845367 .8574025375628211)"},{"location":"manual/built_in_data_types/numbers/#f64013863292728449427-33449296573515447-8162050798467028","text":"```","title":"f64(.013863292728449427 .33449296573515447 .8162050798467028)"},{"location":"manual/built_in_data_types/pairs_and_lists/","text":"Pairs and lists This documentation needs work, cleanup or clarification.","title":"Pairs and lists"},{"location":"manual/built_in_data_types/pairs_and_lists/#pairs-and-lists","text":"This documentation needs work, cleanup or clarification.","title":"Pairs and lists"},{"location":"manual/built_in_data_types/symbols_and_keywords/","text":"Symbols and keywords This documentation needs work, cleanup or clarification.","title":"Symbols and keywords"},{"location":"manual/built_in_data_types/symbols_and_keywords/#symbols-and-keywords","text":"This documentation needs work, cleanup or clarification.","title":"Symbols and keywords"},{"location":"manual/built_in_data_types/vectors/","text":"Vectors This documentation needs work, cleanup or clarification.","title":"Vectors"},{"location":"manual/built_in_data_types/vectors/#vectors","text":"This documentation needs work, cleanup or clarification.","title":"Vectors"},{"location":"manual/c_interface/","text":"C-interface","title":"C-interface"},{"location":"manual/c_interface/#c-interface","text":"","title":"C-interface"},{"location":"manual/copyright_and_license/","text":"Copyright and license The Gambit system release v4.9.4 is Copyright \u00a9 1994-2022 by Marc Feeley, all rights reserved. The Gambit system release v4.9.4 is licensed under two licenses: the Apache License, Version 2.0, and the GNU LESSER GENERAL PUBLIC LICENSE, Version 2.1. You have the option to choose which of these two licenses to abide by. The licenses are copied below. Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. GNU LESSER GENERAL PUBLIC LICENSE Version 2.1, February 1999 Copyright (C) 1991, 1999 Free Software Foundation, Inc. 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. [This is the first released version of the Lesser GPL. It also counts as the successor of the GNU Library Public License, version 2, hence the version number 2.1.] Preamble The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This license, the Lesser General Public License, applies to some specially designated software packages--typically libraries--of the Free Software Foundation and other authors who decide to use it. You can use it too, but we suggest you first think carefully about whether this license or the ordinary General Public License is the better strategy to use in any particular case, based on the explanations below. When we speak of free software, we are referring to freedom of use, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish); that you receive source code or can get it if you want it; that you can change the software and use pieces of it in new free programs; and that you are informed that you can do these things. To protect your rights, we need to make restrictions that forbid distributors to deny you these rights or to ask you to surrender these rights. These restrictions translate to certain responsibilities for you if you distribute copies of the library or if you modify it. For example, if you distribute copies of the library, whether gratis or for a fee, you must give the recipients all the rights that we gave you. You must make sure that they, too, receive or can get the source code. If you link other code with the library, you must provide complete object files to the recipients, so that they can relink them with the library after making changes to the library and recompiling it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the library, and (2) we offer you this license, which gives you legal permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that there is no warranty for the free library. Also, if the library is modified by someone else and passed on, the recipients should know that what they have is not the original version, so that the original author's reputation will not be affected by problems that might be introduced by others. Finally, software patents pose a constant threat to the existence of any free program. We wish to make sure that a company cannot effectively restrict the users of a free program by obtaining a restrictive license from a patent holder. Therefore, we insist that any patent license obtained for a version of the library must be consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the ordinary GNU General Public License. This license, the GNU Lesser General Public License, applies to certain designated libraries, and is quite different from the ordinary General Public License. We use this license for certain libraries in order to permit linking those libraries into non-free programs. When a program is linked with a library, whether statically or using a shared library, the combination of the two is legally speaking a combined work, a derivative of the original library. The ordinary General Public License therefore permits such linking only if the entire combination fits its criteria of freedom. The Lesser General Public License permits more lax criteria for linking other code with the library. We call this license the \"Lesser\" General Public License because it does Less to protect the user's freedom than the ordinary General Public License. It also provides other free software developers Less of an advantage over competing non-free programs. These disadvantages are the reason we use the ordinary General Public License for many libraries. However, the Lesser license provides advantages in certain special circumstances. For example, on rare occasions, there may be a special need to encourage the widest possible use of a certain library, so that it becomes a de-facto standard. To achieve this, non-free programs must be allowed to use the library. A more frequent case is that a free library does the same job as widely used non-free libraries. In this case, there is little to gain by limiting the free library to free software only, so we use the Lesser General Public License. In other cases, permission to use a particular library in non-free programs enables a greater number of people to use a large body of free software. For example, permission to use the GNU C Library in non-free programs enables many more people to use the whole GNU operating system, as well as its variant, the GNU/Linux operating system. Although the Lesser General Public License is Less protective of the users' freedom, it does ensure that the user of a program that is linked with the Library has the freedom and the wherewithal to run that program using a modified version of the Library. The precise terms and conditions for copying, distribution and modification follow. Pay close attention to the difference between a \"work based on the library\" and a \"work that uses the library\". The former contains code derived from the library, whereas the latter must be combined with the library in order to run. GNU LESSER GENERAL PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 0. This License Agreement applies to any software library or other program which contains a notice placed by the copyright holder or other authorized party saying it may be distributed under the terms of this Lesser General Public License (also called \"this License\"). Each licensee is addressed as \"you\". A \"library\" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables. The \"Library\", below, refers to any such software library or work which has been distributed under these terms. A \"work based on the Library\" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term \"modification\".) \"Source code\" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library. Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does. 1. You may copy and distribute verbatim copies of the Library's complete source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and distribute a copy of this License along with the Library. You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee. 2. You may modify your copy or copies of the Library or any portion of it, thus forming a work based on the Library, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions: a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices stating that you changed the files and the date of any change. c) You must cause the whole of the work to be licensed at no charge to all third parties under the terms of this License. d) If a facility in the modified Library refers to a function or a table of data to be supplied by an application program that uses the facility, other than as an argument passed when the facility is invoked, then you must make a good faith effort to ensure that, in the event an application does not supply such function or table, the facility still operates, and performs whatever part of its purpose remains meaningful. (For example, a function in a library to compute square roots has a purpose that is entirely well-defined independent of the application. Therefore, Subsection 2d requires that any application-supplied function or table used by this function must be optional: if the application does not supply it, the square root function must still compute square roots.) These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it. Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library. In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License. 3. You may opt to apply the terms of the ordinary GNU General Public License instead of this License to a given copy of the Library. To do this, you must alter all the notices that refer to this License, so that they refer to the ordinary GNU General Public License, version 2, instead of to this License. (If a newer version than version 2 of the ordinary GNU General Public License has appeared, then you can specify that version instead if you wish.) Do not make any other change in these notices. Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy. This option is useful when you wish to copy part of the code of the Library into a program that is not a library. 4. You may copy and distribute the Library (or a portion or derivative of it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange. If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code. 5. A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a \"work that uses the Library\". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License. However, linking a \"work that uses the Library\" with the Library creates an executable that is a derivative of the Library (because it contains portions of the Library), rather than a \"work that uses the library\". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables. When a \"work that uses the Library\" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law. If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.) Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself. 6. As an exception to the Sections above, you may also combine or link a \"work that uses the Library\" with the Library to produce a work containing portions of the Library, and distribute that work under terms of your choice, provided that the terms permit modification of the work for the customer's own use and reverse engineering for debugging such modifications. You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things: a) Accompany the work with the complete corresponding machine-readable source code for the Library including whatever changes were used in the work (which must be distributed under Sections 1 and 2 above); and, if the work is an executable linked with the Library, with the complete machine-readable \"work that uses the Library\", as object code and/or source code, so that the user can modify the Library and then relink to produce a modified executable containing the modified Library. (It is understood that the user who changes the contents of definitions files in the Library will not necessarily be able to recompile the application to use the modified definitions.) b) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (1) uses at run time a copy of the library already present on the user's computer system, rather than copying library functions into the executable, and (2) will operate properly with a modified version of the library, if the user installs one, as long as the modified version is interface-compatible with the version that the work was made with. c) Accompany the work with a written offer, valid for at least three years, to give the same user the materials specified in Subsection 6a, above, for a charge no more than the cost of performing this distribution. d) If distribution of the work is made by offering access to copy from a designated place, offer equivalent access to copy the above specified materials from the same place. e) Verify that the user has already received a copy of these materials or that you have already sent this user a copy. For an executable, the required form of the \"work that uses the Library\" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the materials to be distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable. It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute. 7. You may place library facilities that are a work based on the Library side-by-side in a single library together with other library facilities not covered by this License, and distribute such a combined library, provided that the separate distribution of the work based on the Library and of the other library facilities is otherwise permitted, and provided that you do these two things: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities. This must be distributed under the terms of the Sections above. b) Give prominent notice with the combined library of the fact that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. 8. You may not copy, modify, sublicense, link with, or distribute the Library except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, link with, or distribute the Library is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance. 9. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Library or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Library (or any work based on the Library), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Library or works based on it. 10. Each time you redistribute the Library (or any work based on the Library), the recipient automatically receives a license from the original licensor to copy, distribute, link with or modify the Library subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties with this License. 11. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Library at all. For example, if a patent license would not permit royalty-free redistribution of the Library by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Library. If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice. This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Library under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License. 13. The Free Software Foundation may publish revised and/or new versions of the Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and \"any later version\", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation. 14. If you wish to incorporate parts of the Library into other free programs whose distribution conditions are incompatible with these, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally. NO WARRANTY 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Libraries If you develop a new library, and you want it to be of the greatest possible use to the public, we recommend making it free software that everyone can redistribute and change. You can do so by permitting redistribution under these terms (or, alternatively, under the terms of the ordinary General Public License). To apply these terms, attach the following notices to the library. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the library's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA Also add information on how to contact you by electronic and paper mail. You should also get your employer (if you work as a programmer) or your school, if any, to sign a \"copyright disclaimer\" for the library, if necessary. Here is a sample; alter the names: Yoyodyne, Inc., hereby disclaims all copyright interest in the library `Frob' (a library for tweaking knobs) written by James Random Hacker. <signature of Ty Coon>, 1 April 1990 Ty Coon, President of Vice That's all there is to it!","title":"Copyright and license"},{"location":"manual/copyright_and_license/#copyright-and-license","text":"The Gambit system release v4.9.4 is Copyright \u00a9 1994-2022 by Marc Feeley, all rights reserved. The Gambit system release v4.9.4 is licensed under two licenses: the Apache License, Version 2.0, and the GNU LESSER GENERAL PUBLIC LICENSE, Version 2.1. You have the option to choose which of these two licenses to abide by. The licenses are copied below. Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. GNU LESSER GENERAL PUBLIC LICENSE Version 2.1, February 1999 Copyright (C) 1991, 1999 Free Software Foundation, Inc. 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. [This is the first released version of the Lesser GPL. It also counts as the successor of the GNU Library Public License, version 2, hence the version number 2.1.] Preamble The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This license, the Lesser General Public License, applies to some specially designated software packages--typically libraries--of the Free Software Foundation and other authors who decide to use it. You can use it too, but we suggest you first think carefully about whether this license or the ordinary General Public License is the better strategy to use in any particular case, based on the explanations below. When we speak of free software, we are referring to freedom of use, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish); that you receive source code or can get it if you want it; that you can change the software and use pieces of it in new free programs; and that you are informed that you can do these things. To protect your rights, we need to make restrictions that forbid distributors to deny you these rights or to ask you to surrender these rights. These restrictions translate to certain responsibilities for you if you distribute copies of the library or if you modify it. For example, if you distribute copies of the library, whether gratis or for a fee, you must give the recipients all the rights that we gave you. You must make sure that they, too, receive or can get the source code. If you link other code with the library, you must provide complete object files to the recipients, so that they can relink them with the library after making changes to the library and recompiling it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the library, and (2) we offer you this license, which gives you legal permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that there is no warranty for the free library. Also, if the library is modified by someone else and passed on, the recipients should know that what they have is not the original version, so that the original author's reputation will not be affected by problems that might be introduced by others. Finally, software patents pose a constant threat to the existence of any free program. We wish to make sure that a company cannot effectively restrict the users of a free program by obtaining a restrictive license from a patent holder. Therefore, we insist that any patent license obtained for a version of the library must be consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the ordinary GNU General Public License. This license, the GNU Lesser General Public License, applies to certain designated libraries, and is quite different from the ordinary General Public License. We use this license for certain libraries in order to permit linking those libraries into non-free programs. When a program is linked with a library, whether statically or using a shared library, the combination of the two is legally speaking a combined work, a derivative of the original library. The ordinary General Public License therefore permits such linking only if the entire combination fits its criteria of freedom. The Lesser General Public License permits more lax criteria for linking other code with the library. We call this license the \"Lesser\" General Public License because it does Less to protect the user's freedom than the ordinary General Public License. It also provides other free software developers Less of an advantage over competing non-free programs. These disadvantages are the reason we use the ordinary General Public License for many libraries. However, the Lesser license provides advantages in certain special circumstances. For example, on rare occasions, there may be a special need to encourage the widest possible use of a certain library, so that it becomes a de-facto standard. To achieve this, non-free programs must be allowed to use the library. A more frequent case is that a free library does the same job as widely used non-free libraries. In this case, there is little to gain by limiting the free library to free software only, so we use the Lesser General Public License. In other cases, permission to use a particular library in non-free programs enables a greater number of people to use a large body of free software. For example, permission to use the GNU C Library in non-free programs enables many more people to use the whole GNU operating system, as well as its variant, the GNU/Linux operating system. Although the Lesser General Public License is Less protective of the users' freedom, it does ensure that the user of a program that is linked with the Library has the freedom and the wherewithal to run that program using a modified version of the Library. The precise terms and conditions for copying, distribution and modification follow. Pay close attention to the difference between a \"work based on the library\" and a \"work that uses the library\". The former contains code derived from the library, whereas the latter must be combined with the library in order to run. GNU LESSER GENERAL PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 0. This License Agreement applies to any software library or other program which contains a notice placed by the copyright holder or other authorized party saying it may be distributed under the terms of this Lesser General Public License (also called \"this License\"). Each licensee is addressed as \"you\". A \"library\" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables. The \"Library\", below, refers to any such software library or work which has been distributed under these terms. A \"work based on the Library\" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term \"modification\".) \"Source code\" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library. Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does. 1. You may copy and distribute verbatim copies of the Library's complete source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and distribute a copy of this License along with the Library. You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee. 2. You may modify your copy or copies of the Library or any portion of it, thus forming a work based on the Library, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions: a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices stating that you changed the files and the date of any change. c) You must cause the whole of the work to be licensed at no charge to all third parties under the terms of this License. d) If a facility in the modified Library refers to a function or a table of data to be supplied by an application program that uses the facility, other than as an argument passed when the facility is invoked, then you must make a good faith effort to ensure that, in the event an application does not supply such function or table, the facility still operates, and performs whatever part of its purpose remains meaningful. (For example, a function in a library to compute square roots has a purpose that is entirely well-defined independent of the application. Therefore, Subsection 2d requires that any application-supplied function or table used by this function must be optional: if the application does not supply it, the square root function must still compute square roots.) These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it. Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library. In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License. 3. You may opt to apply the terms of the ordinary GNU General Public License instead of this License to a given copy of the Library. To do this, you must alter all the notices that refer to this License, so that they refer to the ordinary GNU General Public License, version 2, instead of to this License. (If a newer version than version 2 of the ordinary GNU General Public License has appeared, then you can specify that version instead if you wish.) Do not make any other change in these notices. Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy. This option is useful when you wish to copy part of the code of the Library into a program that is not a library. 4. You may copy and distribute the Library (or a portion or derivative of it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange. If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code. 5. A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a \"work that uses the Library\". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License. However, linking a \"work that uses the Library\" with the Library creates an executable that is a derivative of the Library (because it contains portions of the Library), rather than a \"work that uses the library\". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables. When a \"work that uses the Library\" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law. If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.) Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself. 6. As an exception to the Sections above, you may also combine or link a \"work that uses the Library\" with the Library to produce a work containing portions of the Library, and distribute that work under terms of your choice, provided that the terms permit modification of the work for the customer's own use and reverse engineering for debugging such modifications. You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things: a) Accompany the work with the complete corresponding machine-readable source code for the Library including whatever changes were used in the work (which must be distributed under Sections 1 and 2 above); and, if the work is an executable linked with the Library, with the complete machine-readable \"work that uses the Library\", as object code and/or source code, so that the user can modify the Library and then relink to produce a modified executable containing the modified Library. (It is understood that the user who changes the contents of definitions files in the Library will not necessarily be able to recompile the application to use the modified definitions.) b) Use a suitable shared library mechanism for linking with the Library. A suitable mechanism is one that (1) uses at run time a copy of the library already present on the user's computer system, rather than copying library functions into the executable, and (2) will operate properly with a modified version of the library, if the user installs one, as long as the modified version is interface-compatible with the version that the work was made with. c) Accompany the work with a written offer, valid for at least three years, to give the same user the materials specified in Subsection 6a, above, for a charge no more than the cost of performing this distribution. d) If distribution of the work is made by offering access to copy from a designated place, offer equivalent access to copy the above specified materials from the same place. e) Verify that the user has already received a copy of these materials or that you have already sent this user a copy. For an executable, the required form of the \"work that uses the Library\" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the materials to be distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable. It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute. 7. You may place library facilities that are a work based on the Library side-by-side in a single library together with other library facilities not covered by this License, and distribute such a combined library, provided that the separate distribution of the work based on the Library and of the other library facilities is otherwise permitted, and provided that you do these two things: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities. This must be distributed under the terms of the Sections above. b) Give prominent notice with the combined library of the fact that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. 8. You may not copy, modify, sublicense, link with, or distribute the Library except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, link with, or distribute the Library is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance. 9. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Library or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Library (or any work based on the Library), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Library or works based on it. 10. Each time you redistribute the Library (or any work based on the Library), the recipient automatically receives a license from the original licensor to copy, distribute, link with or modify the Library subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties with this License. 11. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Library at all. For example, if a patent license would not permit royalty-free redistribution of the Library by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Library. If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice. This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Library under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License. 13. The Free Software Foundation may publish revised and/or new versions of the Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and \"any later version\", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation. 14. If you wish to incorporate parts of the Library into other free programs whose distribution conditions are incompatible with these, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally. NO WARRANTY 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Libraries If you develop a new library, and you want it to be of the greatest possible use to the public, we recommend making it free software that everyone can redistribute and change. You can do so by permitting redistribution under these terms (or, alternatively, under the terms of the ordinary General Public License). To apply these terms, attach the following notices to the library. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the library's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA Also add information on how to contact you by electronic and paper mail. You should also get your employer (if you work as a programmer) or your school, if any, to sign a \"copyright disclaimer\" for the library, if necessary. Here is a sample; alter the names: Yoyodyne, Inc., hereby disclaims all copyright interest in the library `Frob' (a library for tweaking knobs) written by James Random Hacker. <signature of Ty Coon>, 1 April 1990 Ty Coon, President of Vice That's all there is to it!","title":"Copyright and license"},{"location":"manual/debugging/","text":"Debugging This section covers the Gambit Scheme debugging facilities.","title":"Debugging"},{"location":"manual/debugging/#debugging","text":"This section covers the Gambit Scheme debugging facilities.","title":"Debugging"},{"location":"manual/debugging/console_line_editing/","text":"Console line-editing The console implements a simple Scheme-friendly line-editing user-interface that is enabled by default. It offers parentheses balancing, a history of previous commands, symbol completion, and several emacs-compatible keyboard commands. The user's input is displayed in a bold font and the output produced by the system is in a plain font. The history of previous commands is saved in the file ~/.gambit_history . It is restored when a REPL is started. Symbol completion is triggered with the tab key. When the cursor is after a sequence of characters that can form a symbol, typing the tab key will search the symbol table for the first symbol (in alphabetical order) that begins with that sequence and insert that symbol. Typing the tab key in succession will cycle through all symbols with that prefix. When all possible symbols have been shown or there are no possible completions, the text reverts to the uncompleted symbol and the bell is rung. Here are the keyboard commands available (where the M- prefix means the escape key is typed and the C- prefix means the control key is pressed): C-d : Generate an end-of-file when the line is empty, otherwise delete character at cursor. delete or backspace : Delete character before cursor. M-C-d : Delete word forward and keep a copy of this text on the clipboard. M-delete : Delete word backward and keep a copy of this text on the clipboard. M-backspace : Delete S-expression backward and keep a copy of this text on the clipboard. C-a : Move cursor to beginning of line. C-e : Move cursor to end of line. C-b or left-arrow : Move cursor left one character. M-b : Move cursor left one word. M-C-b or M-left-arrow : Move cursor left one S-expression. C-f or right-arrow : Move cursor right one character. M-f : Move cursor right one word. M-C-f or M-right-arrow : Move cursor right one S-expression. C-p or M-p or up-arrow : Move to previous line in history. C-n or M-n or down-arrow : Move to next line in history. C-t : Transpose character at cursor with previous character. M-t : Transpose word after cursor with previous word. M-C-t : Transpose S-expression after cursor with previous S-expression. C-l : Clear console and redraw line being edited. C-nul : Set the mark to the cursor. C-w : Delete the text between the cursor and the mark and keep a copy of this text on the clipboard. C-k : Delete the text from the cursor to the end of the line and keep a copy of this text on the clipboard. C-y : Paste the text that is on the clipboard. F8 : Same as typing #||#,c; (REPL command to continue the computation). F9 : Same as typing #||#,-; (REPL command to move to newer frame). F10 : Same as typing #||#,+; (REPL command to move to older frame). F11 : Same as typing #||#,s; (REPL command to step the computation). F12 : Same as typing #||#,l; (REPL command to leap the computation). On macOS, depending on your configuration, you may have to press the fn key to access the function key F12 and the option key to access the other function keys. On Microsoft Windows the clipboard is the system clipboard. This allows text to be copied and pasted between the program and other applications. On other operating systems the clipboard is internal to the program (it is not integrated with the operating system).","title":"Console line-editing"},{"location":"manual/debugging/console_line_editing/#console-line-editing","text":"The console implements a simple Scheme-friendly line-editing user-interface that is enabled by default. It offers parentheses balancing, a history of previous commands, symbol completion, and several emacs-compatible keyboard commands. The user's input is displayed in a bold font and the output produced by the system is in a plain font. The history of previous commands is saved in the file ~/.gambit_history . It is restored when a REPL is started. Symbol completion is triggered with the tab key. When the cursor is after a sequence of characters that can form a symbol, typing the tab key will search the symbol table for the first symbol (in alphabetical order) that begins with that sequence and insert that symbol. Typing the tab key in succession will cycle through all symbols with that prefix. When all possible symbols have been shown or there are no possible completions, the text reverts to the uncompleted symbol and the bell is rung. Here are the keyboard commands available (where the M- prefix means the escape key is typed and the C- prefix means the control key is pressed): C-d : Generate an end-of-file when the line is empty, otherwise delete character at cursor. delete or backspace : Delete character before cursor. M-C-d : Delete word forward and keep a copy of this text on the clipboard. M-delete : Delete word backward and keep a copy of this text on the clipboard. M-backspace : Delete S-expression backward and keep a copy of this text on the clipboard. C-a : Move cursor to beginning of line. C-e : Move cursor to end of line. C-b or left-arrow : Move cursor left one character. M-b : Move cursor left one word. M-C-b or M-left-arrow : Move cursor left one S-expression. C-f or right-arrow : Move cursor right one character. M-f : Move cursor right one word. M-C-f or M-right-arrow : Move cursor right one S-expression. C-p or M-p or up-arrow : Move to previous line in history. C-n or M-n or down-arrow : Move to next line in history. C-t : Transpose character at cursor with previous character. M-t : Transpose word after cursor with previous word. M-C-t : Transpose S-expression after cursor with previous S-expression. C-l : Clear console and redraw line being edited. C-nul : Set the mark to the cursor. C-w : Delete the text between the cursor and the mark and keep a copy of this text on the clipboard. C-k : Delete the text from the cursor to the end of the line and keep a copy of this text on the clipboard. C-y : Paste the text that is on the clipboard. F8 : Same as typing #||#,c; (REPL command to continue the computation). F9 : Same as typing #||#,-; (REPL command to move to newer frame). F10 : Same as typing #||#,+; (REPL command to move to older frame). F11 : Same as typing #||#,s; (REPL command to step the computation). F12 : Same as typing #||#,l; (REPL command to leap the computation). On macOS, depending on your configuration, you may have to press the fn key to access the function key F12 and the option key to access the other function keys. On Microsoft Windows the clipboard is the system clipboard. This allows text to be copied and pasted between the program and other applications. On other operating systems the clipboard is internal to the program (it is not integrated with the operating system).","title":"Console line-editing"},{"location":"manual/debugging/debugging_commands/","text":"Debugging commands In addition to expressions, the REPL accepts the following special \"comma\" commands: ,? and ,help : Give a summary of the REPL commands. ,(h subject) : This command will show the section of the Gambit manual with the definition of the procedure or special form subject, which must be a symbol. For example ,(h time) will show the section documenting the time special form. Please see the help procedure for additional information. ,h : This command will show the section of the Gambit manual with the definition of the procedure which raised the exception for which this REPL was started. ,q : Terminate the process with exit status 0 . This is equivalent to calling (exit 0) . ,qt : Terminate the current thread (note that terminating the primordial thread terminates the process). ,t : Return to the outermost REPL, also known as the \"top-level REPL\". ,d : Leave the current REPL and resume the enclosing REPL. This command does nothing in the top-level REPL. ,(c expr) : Leave the current REPL and continue the computation that initiated the REPL with a specific value. This command can only be used to continue a computation that signaled an error. The expression expr is evaluated in the current context and the resulting value is returned as the value of the expression which signaled the error. For example, if the evaluation of the expression (* (/ x y) 2) signaled an error because y is zero, then in the nested REPL a ,(c (+ 4 y)) will resume the computation of (* (/ x y) 2) as though the value of (/ x y) was 4 . This command must be used carefully because the context where the error occured may rely on the result being of a particular type. For instance a ,(c #f) in the previous example will cause * to signal a type error (this problem is the most troublesome when debugging Scheme code that was compiled with type checking turned off so be careful). ,c : Leave the current REPL and continue the computation that initiated the REPL. This command can only be used to continue a computation that was stopped due to a user interrupt, breakpoint or a single-step. ,s : Leave the current REPL and continue the computation that initiated the REPL in single-stepping mode. The computation will perform an evaluation step (as defined by step-level-set! ) and then stop, causing a nested REPL to be entered. Just before the evaluation step is performed, a line is displayed (in the same format as trace ) which indicates the expression that is being evaluated. If the evaluation step produces a result, the result is also displayed on another line. A nested REPL is then entered after displaying a message which describes the next step of the computation. This command can only be used to continue a computation that was stopped due to a user interrupt, breakpoint or a single-step. ,l : This command is similar to ,s except that it \"leaps\" over procedure calls, that is procedure calls are treated like a single step. Single-stepping mode will resume when the procedure call returns, or if and when the execution of the called procedure encounters a breakpoint. ,N : Move to frame number N of the continuation. After changing the current frame, a one-line summary of the frame is displayed as if the ,y command was entered. ,N+ : Move forward by N frames in the chain of continuation frames (i.e. towards older continuation frames). After changing the current frame, a one-line summary of the frame is displayed as if the ,y command was entered. ,N- : Move backward by N frames in the chain of continuation frames (i.e. towards more recent continuation frames). After changing the current frame, a one-line summary of the frame is displayed as if the ,y command was entered. ,+ : Equivalent to ,1+ . ,- : Equivalent to ,1- . ,++ : Equivalent to ,N+ where N is the number of continuation frames displayed at the head of a backtrace. ,-- : Equivalent to ,N- where N is the number of continuation frames displayed at the head of a backtrace. ,y : Display a one-line summary of the current frame. The information is displayed in four fields. The first field is the frame number. The second field is the procedure that created the frame or (interaction) if the frame was created by an expression entered at the REPL. The remaining fields describe the subproblem associated with the frame, that is the expression whose value is being computed. The third field is the location of the subproblem's source code and the fourth field is a reproduction of the source code, possibly truncated to fit on the line. The last two fields may be missing if that information is not available. In particular, the third field is missing when the frame was created by a user call to the eval procedure or by a compiled procedure not compiled with the declaration debug-location , and the last field is missing when the frame was created by a compiled procedure not compiled with the declaration debug-source . ,b : Display a backtrace summarizing each frame in the chain of continuation frames starting with the current frame. For each frame, the same information as for the ,y command is displayed (except that location information is displayed in the format stream@line:column ). If there are more than 15 frames in the chain of continuation frames, some of the middle frames will be omitted. ,be : Like the ,b command but also display the environment. ,bed : Like the ,be command but also display the dynamic environment. ,(b expr) : Display the backtrace of expr's value, X , which is obtained by evaluating expr in the current frame. X must be a continuation or a thread. When X is a continuation, the frames in that continuation are displayed. When X is a thread, the backtrace of the current continuation of that thread is displayed. ,(be expr) : Like the ,(b expr) command but also display the environment. ,(bed expr) : Like the ,(be expr) command but also display the dynamic environment. ,i : Pretty print the procedure that created the current frame or (interaction) if the frame was created by an expression entered at the REPL. Compiled procedures will only be pretty printed when they are compiled with the declaration debug-source . ,e : Display the environment which is accessible from the current frame. The lexical environment is displayed, followed by the dynamic environment if the parameter object repl-display-dynamic-environment? is not #f . Global lexical variables are not displayed. Moreover the frame must have been created by interpreted code or code compiled with the declaration debug-environments . Due to space safety considerations and compiler optimizations, some of the lexical variable bindings may be missing. Lexical variable bindings are displayed using the format variable = expression (when variable is mutable) or variable == expression (when variable is immutable, which may happen in compiled code due to compiler optimization) and dynamically-bound parameter bindings are displayed using the format (parameter) = expression . Note that expression can be a self-evaluating expression ( number , string , boolean , character , ...), a quote d expression, a lambda expression or a global variable (the last two cases, which are only used when the value of the variable or parameter is a procedure, simplifies the debugging of higher-order procedures). A parameter can be a quote d expression or a global variable. Lexical bindings are displayed in inverse binding order (most deeply nested first) and shadowed variables are included in the list. ,ed : Like the ,e command but the dynamic environment is always displayed. ,(e expr) : Display the environment of expr's value, X , which is obtained by evaluating expr in the current frame. X must be a continuation, a thread, a procedure, or a nonnegative integer. When X is a continuation, the environment at that point in the code is displayed. When X is a thread, the environment of the current continuation of that thread is displayed. When X is a procedure, the lexical environment where X was created is combined with the current continuation and this combined environment is displayed. When X is an integer, the environment at frame number X of the continuation is displayed. ,(ed expr) : Like the ,(e expr) command but the dynamic environment is always displayed. ,st : Display the state of the threads in the current thread's thread group. A thread can be: uninitialized , initialized , active , and terminated (normally or abnormally). Active threads can be running , sleeping and waiting on a synchronization object ( mutex , condition variable or port ) possibly with a timeout. ,(st expr) : Display the state of a specific thread or thread group. The value of expr must be a thread or thread group . ,(v expr) : Start a new REPL visiting expr's value, X , which is obtained by evaluating expr in the current frame. X must be a continuation, a thread, a procedure, or a nonnegative integer. When X is a continuation, the new REPL's continuation is X and evaluations are done in the environment at that point in the code. When X is a thread, the thread is interrupted and the new REPL's continuation is the point where the thread was interrupted. When X is a procedure, the lexical environment where X was created is combined with the current continuation and evaluations are done in this combined environment. When X is an integer, the REPL is started in frame number X of the continuation.","title":"Debugging commands"},{"location":"manual/debugging/debugging_commands/#debugging-commands","text":"In addition to expressions, the REPL accepts the following special \"comma\" commands: ,? and ,help : Give a summary of the REPL commands. ,(h subject) : This command will show the section of the Gambit manual with the definition of the procedure or special form subject, which must be a symbol. For example ,(h time) will show the section documenting the time special form. Please see the help procedure for additional information. ,h : This command will show the section of the Gambit manual with the definition of the procedure which raised the exception for which this REPL was started. ,q : Terminate the process with exit status 0 . This is equivalent to calling (exit 0) . ,qt : Terminate the current thread (note that terminating the primordial thread terminates the process). ,t : Return to the outermost REPL, also known as the \"top-level REPL\". ,d : Leave the current REPL and resume the enclosing REPL. This command does nothing in the top-level REPL. ,(c expr) : Leave the current REPL and continue the computation that initiated the REPL with a specific value. This command can only be used to continue a computation that signaled an error. The expression expr is evaluated in the current context and the resulting value is returned as the value of the expression which signaled the error. For example, if the evaluation of the expression (* (/ x y) 2) signaled an error because y is zero, then in the nested REPL a ,(c (+ 4 y)) will resume the computation of (* (/ x y) 2) as though the value of (/ x y) was 4 . This command must be used carefully because the context where the error occured may rely on the result being of a particular type. For instance a ,(c #f) in the previous example will cause * to signal a type error (this problem is the most troublesome when debugging Scheme code that was compiled with type checking turned off so be careful). ,c : Leave the current REPL and continue the computation that initiated the REPL. This command can only be used to continue a computation that was stopped due to a user interrupt, breakpoint or a single-step. ,s : Leave the current REPL and continue the computation that initiated the REPL in single-stepping mode. The computation will perform an evaluation step (as defined by step-level-set! ) and then stop, causing a nested REPL to be entered. Just before the evaluation step is performed, a line is displayed (in the same format as trace ) which indicates the expression that is being evaluated. If the evaluation step produces a result, the result is also displayed on another line. A nested REPL is then entered after displaying a message which describes the next step of the computation. This command can only be used to continue a computation that was stopped due to a user interrupt, breakpoint or a single-step. ,l : This command is similar to ,s except that it \"leaps\" over procedure calls, that is procedure calls are treated like a single step. Single-stepping mode will resume when the procedure call returns, or if and when the execution of the called procedure encounters a breakpoint. ,N : Move to frame number N of the continuation. After changing the current frame, a one-line summary of the frame is displayed as if the ,y command was entered. ,N+ : Move forward by N frames in the chain of continuation frames (i.e. towards older continuation frames). After changing the current frame, a one-line summary of the frame is displayed as if the ,y command was entered. ,N- : Move backward by N frames in the chain of continuation frames (i.e. towards more recent continuation frames). After changing the current frame, a one-line summary of the frame is displayed as if the ,y command was entered. ,+ : Equivalent to ,1+ . ,- : Equivalent to ,1- . ,++ : Equivalent to ,N+ where N is the number of continuation frames displayed at the head of a backtrace. ,-- : Equivalent to ,N- where N is the number of continuation frames displayed at the head of a backtrace. ,y : Display a one-line summary of the current frame. The information is displayed in four fields. The first field is the frame number. The second field is the procedure that created the frame or (interaction) if the frame was created by an expression entered at the REPL. The remaining fields describe the subproblem associated with the frame, that is the expression whose value is being computed. The third field is the location of the subproblem's source code and the fourth field is a reproduction of the source code, possibly truncated to fit on the line. The last two fields may be missing if that information is not available. In particular, the third field is missing when the frame was created by a user call to the eval procedure or by a compiled procedure not compiled with the declaration debug-location , and the last field is missing when the frame was created by a compiled procedure not compiled with the declaration debug-source . ,b : Display a backtrace summarizing each frame in the chain of continuation frames starting with the current frame. For each frame, the same information as for the ,y command is displayed (except that location information is displayed in the format stream@line:column ). If there are more than 15 frames in the chain of continuation frames, some of the middle frames will be omitted. ,be : Like the ,b command but also display the environment. ,bed : Like the ,be command but also display the dynamic environment. ,(b expr) : Display the backtrace of expr's value, X , which is obtained by evaluating expr in the current frame. X must be a continuation or a thread. When X is a continuation, the frames in that continuation are displayed. When X is a thread, the backtrace of the current continuation of that thread is displayed. ,(be expr) : Like the ,(b expr) command but also display the environment. ,(bed expr) : Like the ,(be expr) command but also display the dynamic environment. ,i : Pretty print the procedure that created the current frame or (interaction) if the frame was created by an expression entered at the REPL. Compiled procedures will only be pretty printed when they are compiled with the declaration debug-source . ,e : Display the environment which is accessible from the current frame. The lexical environment is displayed, followed by the dynamic environment if the parameter object repl-display-dynamic-environment? is not #f . Global lexical variables are not displayed. Moreover the frame must have been created by interpreted code or code compiled with the declaration debug-environments . Due to space safety considerations and compiler optimizations, some of the lexical variable bindings may be missing. Lexical variable bindings are displayed using the format variable = expression (when variable is mutable) or variable == expression (when variable is immutable, which may happen in compiled code due to compiler optimization) and dynamically-bound parameter bindings are displayed using the format (parameter) = expression . Note that expression can be a self-evaluating expression ( number , string , boolean , character , ...), a quote d expression, a lambda expression or a global variable (the last two cases, which are only used when the value of the variable or parameter is a procedure, simplifies the debugging of higher-order procedures). A parameter can be a quote d expression or a global variable. Lexical bindings are displayed in inverse binding order (most deeply nested first) and shadowed variables are included in the list. ,ed : Like the ,e command but the dynamic environment is always displayed. ,(e expr) : Display the environment of expr's value, X , which is obtained by evaluating expr in the current frame. X must be a continuation, a thread, a procedure, or a nonnegative integer. When X is a continuation, the environment at that point in the code is displayed. When X is a thread, the environment of the current continuation of that thread is displayed. When X is a procedure, the lexical environment where X was created is combined with the current continuation and this combined environment is displayed. When X is an integer, the environment at frame number X of the continuation is displayed. ,(ed expr) : Like the ,(e expr) command but the dynamic environment is always displayed. ,st : Display the state of the threads in the current thread's thread group. A thread can be: uninitialized , initialized , active , and terminated (normally or abnormally). Active threads can be running , sleeping and waiting on a synchronization object ( mutex , condition variable or port ) possibly with a timeout. ,(st expr) : Display the state of a specific thread or thread group. The value of expr must be a thread or thread group . ,(v expr) : Start a new REPL visiting expr's value, X , which is obtained by evaluating expr in the current frame. X must be a continuation, a thread, a procedure, or a nonnegative integer. When X is a continuation, the new REPL's continuation is X and evaluations are done in the environment at that point in the code. When X is a thread, the thread is interrupted and the new REPL's continuation is the point where the thread was interrupted. When X is a procedure, the lexical environment where X was created is combined with the current continuation and evaluations are done in this combined environment. When X is an integer, the REPL is started in frame number X of the continuation.","title":"Debugging commands"},{"location":"manual/debugging/debugging_example/","text":"Debugging example Here is a sample interaction with gsi : $ gsi Gambit v4.9.4 > (define (invsqr x) (/ 1 (expt x 2))) > (define (mymap fn lst) (define (mm in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) (mm lst)) > (mymap invsqr '(5 2 hello 9 1)) *** ERROR IN invsqr, (console)@1.25 -- (Argument 1) NUMBER expected (expt 'hello 2) 1> ,i #<procedure #2 invsqr> = (lambda (x) (/ 1 (expt x 2))) 1> ,e x = 'hello 1> ,b 0 invsqr (console)@1:25 (expt x 2) 1 #<procedure #4> (console)@6:17 (fn (car in)) 2 #<procedure #4> (console)@6:31 (mm (cdr in)) 3 #<procedure #4> (console)@6:31 (mm (cdr in)) 4 (interaction) (console)@8:1 (mymap invsqr '(5 2 hel... 1> ,+ 1 #<procedure #4> (console)@6.17 (fn (car in)) 1\\1> (pp #4) (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) 1\\1> ,e in = '(hello 9 1) mm = (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) fn = invsqr lst = '(5 2 hello 9 1) 1\\1> ,(e mm) mm = (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) fn = invsqr lst = '(5 2 hello 9 1) 1\\1> fn #<procedure #2 invsqr> 1\\1> (pp fn) (lambda (x) (/ 1 (expt x 2))) 1\\1> ,+ 2 #<procedure #4> (console)@6.31 (mm (cdr in)) 1\\2> ,e in = '(2 hello 9 1) mm = (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) fn = invsqr lst = '(5 2 hello 9 1) 1\\2> ,(c (list 3 4 5)) (1/25 1/4 3 4 5) > ,q","title":"Debugging example"},{"location":"manual/debugging/debugging_example/#debugging-example","text":"Here is a sample interaction with gsi : $ gsi Gambit v4.9.4 > (define (invsqr x) (/ 1 (expt x 2))) > (define (mymap fn lst) (define (mm in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) (mm lst)) > (mymap invsqr '(5 2 hello 9 1)) *** ERROR IN invsqr, (console)@1.25 -- (Argument 1) NUMBER expected (expt 'hello 2) 1> ,i #<procedure #2 invsqr> = (lambda (x) (/ 1 (expt x 2))) 1> ,e x = 'hello 1> ,b 0 invsqr (console)@1:25 (expt x 2) 1 #<procedure #4> (console)@6:17 (fn (car in)) 2 #<procedure #4> (console)@6:31 (mm (cdr in)) 3 #<procedure #4> (console)@6:31 (mm (cdr in)) 4 (interaction) (console)@8:1 (mymap invsqr '(5 2 hel... 1> ,+ 1 #<procedure #4> (console)@6.17 (fn (car in)) 1\\1> (pp #4) (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) 1\\1> ,e in = '(hello 9 1) mm = (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) fn = invsqr lst = '(5 2 hello 9 1) 1\\1> ,(e mm) mm = (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) fn = invsqr lst = '(5 2 hello 9 1) 1\\1> fn #<procedure #2 invsqr> 1\\1> (pp fn) (lambda (x) (/ 1 (expt x 2))) 1\\1> ,+ 2 #<procedure #4> (console)@6.31 (mm (cdr in)) 1\\2> ,e in = '(2 hello 9 1) mm = (lambda (in) (if (null? in) '() (cons (fn (car in)) (mm (cdr in))))) fn = invsqr lst = '(5 2 hello 9 1) 1\\2> ,(c (list 3 4 5)) (1/25 1/4 3 4 5) > ,q","title":"Debugging example"},{"location":"manual/debugging/debugging_model/","text":"Debugging model The evaluation of an expression may stop before it is completed for the following reasons: An evaluation error has occured, such as attempting to divide by zero. The user has interrupted the evaluation (usually by typing <^C> ). A breakpoint has been reached or (step) was evaluated. Single-stepping mode is enabled. When an evaluation stops, a message is displayed indicating the reason and location where the evaluation was stopped. The location information includes, if known, the name of the procedure where the evaluation was stopped and the source code location in the format stream@line.column , where stream is either a string naming a file or a symbol within parentheses, such as (console) . A nested REPL is then initiated in the context of the point of execution where the evaluation was stopped. The nested REPL's continuation and evaluation environment are the same as the point where the evaluation was stopped. For example when evaluating the expression (let ((y (- 1 1))) (* (/ x y) 2)) , a \"divide by zero\" error is reported and the nested REPL's continuation is the one that takes the result and multiplies it by two. The REPL's lexical environment includes the lexical variable y . This allows the inspection of the evaluation context (i.e. the lexical and dynamic environments and continuation), which is particularly useful to determine the exact location and cause of an error. The prompt of nested REPLs includes the nesting level; 1> is the prompt at the first nesting level, 2> at the second nesting level, and so on. An end of file (usually <^D> ) will cause the current REPL to be terminated and the enclosing REPL (one nesting level less) to be resumed. At any time the user can examine the frames in the REPL's continuation, which is useful to determine which chain of procedure calls lead to an error. A backtrace that lists the chain of active continuation frames in the REPL's continuation can be obtained with the ,b command. The frames are numbered from 0 , that is frame 0 is the most recent frame of the continuation where execution stopped, frame 1 is the parent frame of frame 0 , and so on. It is also possible to move the REPL to a specific parent continuation (i.e. a specific frame of the continuation where execution stopped) with the ,N , ,N+ , ,N- , ,+ , ,- , ,++ , and ,-- commands. When the frame number of the frame being examined is not zero, it is shown in the prompt after the nesting level, for example 1\\5> is the prompt when the REPL nesting level is 1 and the frame number is 5 . Expressions entered at a nested REPL are evaluated in the environment (both lexical and dynamic) of the continuation frame currently being examined if that frame was created by interpreted Scheme code. If the frame was created by compiled Scheme code then expressions get evaluated in the global interaction environment. This feature may be used in interpreted code to fetch the value of a variable in the current frame or to change its value with set! . Note that some special forms ( define in particular) can only be evaluated in the global interaction environment.","title":"Debugging model"},{"location":"manual/debugging/debugging_model/#debugging-model","text":"The evaluation of an expression may stop before it is completed for the following reasons: An evaluation error has occured, such as attempting to divide by zero. The user has interrupted the evaluation (usually by typing <^C> ). A breakpoint has been reached or (step) was evaluated. Single-stepping mode is enabled. When an evaluation stops, a message is displayed indicating the reason and location where the evaluation was stopped. The location information includes, if known, the name of the procedure where the evaluation was stopped and the source code location in the format stream@line.column , where stream is either a string naming a file or a symbol within parentheses, such as (console) . A nested REPL is then initiated in the context of the point of execution where the evaluation was stopped. The nested REPL's continuation and evaluation environment are the same as the point where the evaluation was stopped. For example when evaluating the expression (let ((y (- 1 1))) (* (/ x y) 2)) , a \"divide by zero\" error is reported and the nested REPL's continuation is the one that takes the result and multiplies it by two. The REPL's lexical environment includes the lexical variable y . This allows the inspection of the evaluation context (i.e. the lexical and dynamic environments and continuation), which is particularly useful to determine the exact location and cause of an error. The prompt of nested REPLs includes the nesting level; 1> is the prompt at the first nesting level, 2> at the second nesting level, and so on. An end of file (usually <^D> ) will cause the current REPL to be terminated and the enclosing REPL (one nesting level less) to be resumed. At any time the user can examine the frames in the REPL's continuation, which is useful to determine which chain of procedure calls lead to an error. A backtrace that lists the chain of active continuation frames in the REPL's continuation can be obtained with the ,b command. The frames are numbered from 0 , that is frame 0 is the most recent frame of the continuation where execution stopped, frame 1 is the parent frame of frame 0 , and so on. It is also possible to move the REPL to a specific parent continuation (i.e. a specific frame of the continuation where execution stopped) with the ,N , ,N+ , ,N- , ,+ , ,- , ,++ , and ,-- commands. When the frame number of the frame being examined is not zero, it is shown in the prompt after the nesting level, for example 1\\5> is the prompt when the REPL nesting level is 1 and the frame number is 5 . Expressions entered at a nested REPL are evaluated in the environment (both lexical and dynamic) of the continuation frame currently being examined if that frame was created by interpreted Scheme code. If the frame was created by compiled Scheme code then expressions get evaluated in the global interaction environment. This feature may be used in interpreted code to fetch the value of a variable in the current frame or to change its value with set! . Note that some special forms ( define in particular) can only be evaluated in the global interaction environment.","title":"Debugging model"},{"location":"manual/debugging/emacs_interface/","text":"Emacs interface Gambit comes with the Emacs package gambit.el which provides a nice environment for running Gambit from within the Emacs editor. This package filters the standard output of the Gambit process and when it intercepts a location information (in the format stream@line.column where stream is either (stdin) when the expression was obtained from standard input, (console) when the expression was obtained from the console, or a string naming a file) it opens a window to highlight the corresponding expression. To use this package, make sure the file gambit.el is accessible from your load-path and that the following lines are in your .emacs file: (autoload 'gambit-inferior-mode \"gambit\" \"Hook Gambit mode into cmuscheme.\") (autoload 'gambit-mode \"gambit\" \"Hook Gambit mode into scheme.\") (add-hook 'inferior-scheme-mode-hook (function gambit-inferior-mode)) (add-hook 'scheme-mode-hook (function gambit-mode)) (setq scheme-program-name \"gsi -:debug=-\") Alternatively, if you don\u2019t mind always loading this package, you can simply add this line to your .emacs file: (require 'gambit) You can then start an inferior Gambit process by typing M-x run-scheme . The commands provided in cmuscheme mode will be available in the Gambit interaction buffer (i.e. *scheme* ) and in buffers attached to Scheme source files. Here is a list of the most useful commands (for a complete list type C-h m in the Gambit interaction buffer): C-x C-e : Evaluate the expression which is before the cursor (the expression will be copied to the Gambit interaction buffer). C-c C-z : Switch to Gambit interaction buffer. C-c C-l : Load a file (file attached to current buffer is default) using (load file). C-c C-k : Compile a file (file attached to current buffer is default) using (compile-file file) . The file gambit.el provides these additional commands: F8 or C-c c : Continue the computation (same as typing #||#,c; to the REPL). F9 or C-c ] : Move to newer frame (same as typing #||#,-; to the REPL). F10 or C-c [ : Move to older frame (same as typing #||#,+; to the REPL). F11 or C-c s : Step the computation (same as typing #||#,s; to the REPL). F12 or C-c l : Leap the computation (same as typing #||#,l; to the REPL). C-c _ : Removes the last window that was opened to highlight an expression. The two keystroke version of these commands can be shortened to M-c , M-[ , M-] , M-s , M-l , and M-_ respectively by adding this line to your .emacs file: (setq gambit-repl-command-prefix \"\\e\") This is more convenient to type than the two keystroke C-c based sequences but the purist may not like this because it does not follow normal Emacs conventions. Here is what a typical .emacs file will look like: (setq load-path ; add directory containing gambit.el (cons \"/usr/local/Gambit/share/emacs/site-lisp\" load-path)) (setq scheme-program-name \"/tmp/gsi -:debug=-\") ; if gsi not in executable path (setq gambit-highlight-color \"gray\") ; if you don't like the default (setq gambit-repl-command-prefix \"\\e\") ; if you want M-c, M-s, etc (require 'gambit)","title":"Emacs interface"},{"location":"manual/debugging/emacs_interface/#emacs-interface","text":"Gambit comes with the Emacs package gambit.el which provides a nice environment for running Gambit from within the Emacs editor. This package filters the standard output of the Gambit process and when it intercepts a location information (in the format stream@line.column where stream is either (stdin) when the expression was obtained from standard input, (console) when the expression was obtained from the console, or a string naming a file) it opens a window to highlight the corresponding expression. To use this package, make sure the file gambit.el is accessible from your load-path and that the following lines are in your .emacs file: (autoload 'gambit-inferior-mode \"gambit\" \"Hook Gambit mode into cmuscheme.\") (autoload 'gambit-mode \"gambit\" \"Hook Gambit mode into scheme.\") (add-hook 'inferior-scheme-mode-hook (function gambit-inferior-mode)) (add-hook 'scheme-mode-hook (function gambit-mode)) (setq scheme-program-name \"gsi -:debug=-\") Alternatively, if you don\u2019t mind always loading this package, you can simply add this line to your .emacs file: (require 'gambit) You can then start an inferior Gambit process by typing M-x run-scheme . The commands provided in cmuscheme mode will be available in the Gambit interaction buffer (i.e. *scheme* ) and in buffers attached to Scheme source files. Here is a list of the most useful commands (for a complete list type C-h m in the Gambit interaction buffer): C-x C-e : Evaluate the expression which is before the cursor (the expression will be copied to the Gambit interaction buffer). C-c C-z : Switch to Gambit interaction buffer. C-c C-l : Load a file (file attached to current buffer is default) using (load file). C-c C-k : Compile a file (file attached to current buffer is default) using (compile-file file) . The file gambit.el provides these additional commands: F8 or C-c c : Continue the computation (same as typing #||#,c; to the REPL). F9 or C-c ] : Move to newer frame (same as typing #||#,-; to the REPL). F10 or C-c [ : Move to older frame (same as typing #||#,+; to the REPL). F11 or C-c s : Step the computation (same as typing #||#,s; to the REPL). F12 or C-c l : Leap the computation (same as typing #||#,l; to the REPL). C-c _ : Removes the last window that was opened to highlight an expression. The two keystroke version of these commands can be shortened to M-c , M-[ , M-] , M-s , M-l , and M-_ respectively by adding this line to your .emacs file: (setq gambit-repl-command-prefix \"\\e\") This is more convenient to type than the two keystroke C-c based sequences but the purist may not like this because it does not follow normal Emacs conventions. Here is what a typical .emacs file will look like: (setq load-path ; add directory containing gambit.el (cons \"/usr/local/Gambit/share/emacs/site-lisp\" load-path)) (setq scheme-program-name \"/tmp/gsi -:debug=-\") ; if gsi not in executable path (setq gambit-highlight-color \"gray\") ; if you don't like the default (setq gambit-repl-command-prefix \"\\e\") ; if you want M-c, M-s, etc (require 'gambit)","title":"Emacs interface"},{"location":"manual/debugging/procedures/","text":"Procedures related to debugging help help-browser (help [subject]) ;; procedure (help-browser [new-value]) ;; procedure The help procedure displays the section of the Gambit manual with the definition of the procedure or special form subject, which must be a procedure or symbol. For example the call (help gensym) will show the section documenting the gensym procedure and the call (help 'time) will show the section documenting the time special form. When the subject is absent, the documentation of the help procedure is shown. The help procedure returns the void object. The parameter object help-browser is bound to a string naming the external program that is used by the help procedure to view the documentation. Initially it is bound to the empty string. In normal circumstances when help-browser is bound to an empty string the help procedure runs the script ~~bin/gambdoc.bat which searches for a suitable web browser to open the documentation in HTML format. Unless the system was built with the command configure --enable-help-browser=... , the text-only browser lynx (see http://lynx.isc.org/ ) will be used by default if it is available. We highly recommend that you install this browser if you are interested in viewing the documentation within the console in which the REPL is running. You can exit lynx conveniently by typing an end of file (usually <^D> ). For example: > (help-browser \"firefox\") ; use firefox instead of lynx > (help 'gensym) > (help gensym) ; OK because gensym is a procedure > (help 'time) > (help time) ; not OK because time is a special form *** ERROR IN (console)@5.7 -- Macro name can't be used as a variable: time > apropos (apropos [substring [port]]) ;; procedure The apropos procedure writes to the port port a report of all the global variables whose name contains substring , a string or symbol . If substring is not specified the report contains all the global variables. If it is not specified, port defaults to the interaction channel (i.e. the output will appear at the REPL). The apropos procedure returns the void object. The global variables are grouped into namespaces. The empty namespace, if it is relevant, is last. This reduces the likelihood it will scroll off the screen if there are several global variables in other namespaces, which are typically less interesting. Note that with the apropos procedure it is possible to reveal the existence of procedures of the runtime system and modules that are not intended to be called by user code. These procedures often avoid type checking their arguments or must be called in a specific context, so calling them incorrectly may crash the system. On the other hand it also allows discovering the existence of certain functionalities that may have gone unnoticed. For example: > (apropos \"cons\") \"##\" namespace: 10^-constants, cons, cons*, cons*-aux, console-port, constant-expression-value, constant-expression?, cprc-quasi-cons, deconstruct-call, define-type-construct-constant, degen-quasi-cons, gen-quasi-cons, quasi-cons, stdio/console-repl-channel, void-constant?, xcons empty namespace: cons, cons*, console-port, xcons > (import (srfi 69)) > (apropos \"table?\") \"##\" namespace: gc-hash-table?, mutable?, readtable?, table? \"srfi/69#\" namespace: hash-table? empty namespace: readtable?, table? > (apropos \"srfi/69#\") \"srfi/69#\" namespace: ||, alist->hash-table, hash, hash-by-identity, hash-table->alist, hash-table-copy, hash-table-delete!, hash-table-equivalence-function, hash-table-exists?, hash-table-fold, hash-table-hash-function, hash-table-keys, hash-table-merge!, hash-table-ref, hash-table-ref/default, hash-table-set!, hash-table-size, hash-table-update!, hash-table-update!/default, hash-table-values, hash-table-walk, hash-table?, make-hash-table, string-ci-hash, string-hash repl-result-history-ref repl-result-history-max-length-set! (repl-result-history-ref i) ;; procedure (repl-result-history-max-length-set! n) ;; procedure The REPL keeps a history of the last few results printed by the REPL. The call (repl-result-history-ref i) returns the i th previous result (the last for i=0 , the next to last for i=1 , etc). By default the REPL result history remembers up to 3 results. The maximal length of the history can be set to n between 0 and 10 by a call to (repl-result-history-max-length-set! n) . For convenience the reader defines an abbreviation for calling repl-result-history-ref . Tokens formed by a sequence of one or more hash signs, such as # , ## , etc, are expanded by the reader into the list (repl-result-history-ref i) , where i is the number of hash signs minus 1. In other words, # will return the last result printed by the REPL, ## will return the next to last, etc. For example: > (map (lambda (x) (* x x)) '(1 2 3)) (1 4 9) > (reverse #) (9 4 1) > (append # ##) (9 4 1 1 4 9) > 1 1 > 1 1 > (+ # ##) 2 > (+ # ##) 3 > (+ # ##) 5 > ##### *** ERROR IN (console)@9.1 -- (Argument 1) Out of range (repl-result-history-ref 3) 1> trace untrace (trace proc ...) ;; procedure (untrace proc ...) ;; procedure The trace procedure starts tracing calls to the specified procedures. When a traced procedure is called, a line containing the procedure and its arguments is displayed (using the procedure call expression syntax). The line is indented with a sequence of vertical bars which indicate the nesting depth of the procedure\u2019s continuation. After the vertical bars is a greater-than sign which indicates that the evaluation of the call is starting. When a traced procedure returns a result, it is displayed with the same indentation as the call but without the greater-than sign. This makes it easy to match calls and results (the result of a given call is the value at the same indentation as the greater-than sign). If a traced procedure P1 performs a tail call to a traced procedure P2 , then P2 will use the same indentation as P1 . This makes it easy to spot tail calls. The special handling for tail calls is needed to preserve the space complexity of the program (i.e. tail calls are implemented as required by Scheme even when they involve traced procedures). The untrace procedure stops tracing calls to the specified procedures. When no argument is passed to the trace procedure, the list of procedures currently being traced is returned. The void object is returned by the trace procedure when it is passed one or more arguments. When no argument is passed to the untrace procedure stops all tracing and returns the void object. A compiled procedure may be traced but only if it is bound to a global variable. For example: > (define (fact n) (if (< n 2) 1 (* n (fact (- n 1))))) > (trace fact) > (fact 5) | > (fact 5) | | > (fact 4) | | | > (fact 3) | | | | > (fact 2) | | | | | > (fact 1) | | | | | 1 | | | | 2 | | | 6 | | 24 | 120 120 > (trace -) *** WARNING -- Rebinding global variable \"-\" to an interpreted procedure > (define (fact-iter n r) (if (< n 2) r (fact-iter (- n 1) (* n r)))) > (trace fact-iter) > (fact-iter 5 1) | > (fact-iter 5 1) | | > (- 5 1) | | 4 | > (fact-iter 4 5) | | > (- 4 1) | | 3 | > (fact-iter 3 20) | | > (- 3 1) | | 2 | > (fact-iter 2 60) | | > (- 2 1) | | 1 | > (fact-iter 1 120) | 120 120 > (trace) (#<procedure #2 fact-iter> #<procedure #3 -> #<procedure #4 fact>) > (untrace) > (fact 5) 120 step step-level-set! (step) ;; procedure (step-level-set! level) ;; procedure The step procedure enables single-stepping mode. After the call to step the computation will stop just before the interpreter executes the next evaluation step (as defined by step-level-set! ). A nested REPL is then started. Note that because single-stepping is stopped by the REPL whenever the prompt is displayed it is pointless to enter (step) by itself. On the other hand entering (begin (step) expr) will evaluate expr in single-stepping mode. The procedure step-level-set! sets the stepping level which determines the granularity of the evaluation steps when single-stepping is enabled. The stepping level level must be an exact integer in the range 0 to 7 . At a level of 0 , the interpreter ignores single-stepping mode. At higher levels the interpreter stops the computation just before it performs the following operations, depending on the stepping level: procedure call delay special form and operations at lower levels lambda special form and operations at lower levels define special form and operations at lower levels set! special form and operations at lower levels variable reference and operations at lower levels constant reference and operations at lower levels The default stepping level is 7. For example: > (define (fact n) (if (< n 2) 1 (* n (fact (- n 1))))) > (step-level-set! 1) > (begin (step) (fact 5)) *** STOPPED IN (console)@3.15 1> ,s | > (fact 5) *** STOPPED IN fact, (console)@1.22 1> ,s | | > (< n 2) | | #f *** STOPPED IN fact, (console)@1.43 1> ,s | | > (- n 1) | | 4 *** STOPPED IN fact, (console)@1.37 1> ,s | | > (fact (- n 1)) *** STOPPED IN fact, (console)@1.22 1> ,s | | | > (< n 2) | | | #f *** STOPPED IN fact, (console)@1.43 1> ,s | | | > (- n 1) | | | 3 *** STOPPED IN fact, (console)@1.37 1> ,l | | | > (fact (- n 1)) *** STOPPED IN fact, (console)@1.22 1> ,l | | > (* n (fact (- n 1))) | | 24 *** STOPPED IN fact, (console)@1.32 1> ,l | > (* n (fact (- n 1))) | 120 120 break unbreak (break proc ...) ;; procedure (unbreak proc ...) ;; procedure The break procedure places a breakpoint on each of the specified procedures. When a procedure is called that has a breakpoint, the interpreter will enable single-stepping mode (as if step had been called). This typically causes the computation to stop soon inside the procedure if the stepping level is high enough. The unbreak procedure removes the breakpoints on the specified procedures. With no argument, break returns the list of procedures currently containing breakpoints. The void object is returned by break if it is passed one or more arguments. With no argument unbreak removes all the breakpoints and returns the void object. A breakpoint can be placed on a compiled procedure but only if it is bound to a global variable. For example: > (define (double x) (+ x x)) > (define (triple y) (- (double (double y)) y)) > (define (f z) (* (triple z) 10)) > (break double) > (break -) *** WARNING -- Rebinding global variable \"-\" to an interpreted procedure > (f 5) *** STOPPED IN double, (console)@1.21 1> ,b 0 double (console)@1:21 + 1 triple (console)@2:31 (double y) 2 f (console)@3:18 (triple z) 3 (interaction) (console)@6:1 (f 5) 1> ,e x = 5 1> ,c *** STOPPED IN double, (console)@1.21 1> ,c *** STOPPED IN f, (console)@3.29 1> ,c 150 > (break) (#<procedure #3 -> #<procedure #4 double>) > (unbreak) > (f 5) 150 generate-proper-tail-calls (generate-proper-tail-calls [new-value]) ;; procedure Deprecation warning This procedure is DEPRECATED and will be removed in a future version of Gambit. Use the proper-tail-calls declaration instead. The parameter object generate-proper-tail-calls is bound to a boolean value controlling how the interpreter handles tail calls. When it is bound to #f the interpreter will treat tail calls like nontail calls, that is a new continuation will be created for the call. This setting is useful for debugging, because when a primitive signals an error the location information will point to the call site of the primitive even if this primitive was called with a tail call. The initial value of this parameter object is #t , which means that a tail call will reuse the continuation of the calling function. This parameter object only affects code that is subsequently processed by load or eval , or entered at the REPL. For example: > (generate-proper-tail-calls) #t > (let loop ((i 1)) (if (< i 10) (loop (* i 2)) oops)) *** ERROR IN #<procedure #2>, (console)@2.47 -- Unbound variable: oops 1> ,b 0 #<procedure #2> (console)@2:47 oops 1 (interaction) (console)@2:1 ((letrec ((loop (lambda... 1> ,t > (generate-proper-tail-calls #f) > (let loop ((i 1)) (if (< i 10) (loop (* i 2)) oops)) *** ERROR IN #<procedure #3>, (console)@6.47 -- Unbound variable: oops 1> ,b 0 #<procedure #3> (console)@6:47 oops 1 #<procedure #3> (console)@6:32 (loop (* i 2)) 2 #<procedure #3> (console)@6:32 (loop (* i 2)) 3 #<procedure #3> (console)@6:32 (loop (* i 2)) 4 #<procedure #3> (console)@6:32 (loop (* i 2)) 5 (interaction) (console)@6:1 ((letrec ((loop (lambda... display-environment-set! (display-environment-set! display?) ;; procedure Deprecation warning This procedure is DEPRECATED and will be removed in a future version of Gambit. Use the parameter object repl-display-environment? instead. This procedure sets a flag that controls the automatic display of the environment by the REPL. If display? is true, the environment is displayed by the REPL before the prompt. The default setting is not to display the environment. repl-display-environment? (repl-display-environment? display?) ;; procedure The parameter object repl-display-environment? is bound to a boolean value that controls the automatic display of the environment by the REPL. If display? is true, the environment is displayed by the REPL before the prompt. This is particularly useful in single-stepping mode. The default setting is not to display the environment. display-dynamic-environment? (display-dynamic-environment? display?) ;; procedure The parameter object display-dynamic-environment? is bound to a boolean value that controls wether the dynamic environment is displayed when the environment is displayed. The default setting is not to display the dynamic environment. pretty-print (pretty-print obj [port]) procedure This procedure pretty-prints obj on the port port. If it is not specified, port defaults to the current output-port. For example: > (pretty-print (let* ((x '(1 2 3 4)) (y (list x x x))) (list y y y))) (((1 2 3 4) (1 2 3 4) (1 2 3 4)) ((1 2 3 4) (1 2 3 4) (1 2 3 4)) ((1 2 3 4) (1 2 3 4) (1 2 3 4))) pp (pp obj [port]) ;; procedure This procedure pretty-prints obj on the port port. When obj is a procedure created by the interpreter or a procedure created by code compiled with the declaration debug-source , the procedure's source code is displayed. If it is not specified, port defaults to the interaction channel (i.e. the output will appear at the REPL). For example: > (define (f g) (+ (time (g 100)) (time (g 1000)))) > (pp f) (lambda (g) (+ (##time (lambda () (g 100)) '(g 100)) (##time (lambda () (g 1000)) '(g 1000)))) gc-report-set! (gc-report-set! report?) ;; procedure This procedure controls the generation of reports during garbage collections. If the argument is true, a brief report of memory usage is generated after every garbage collection. It contains: the time taken for this garbage collection, the amount of memory allocated in megabytes since the program was started, the size of the heap in megabytes, the heap memory in megabytes occupied by live data, the proportion of the heap occupied by live data, and the number of bytes occupied by movable and nonmovable objects.","title":"Procedures related to debugging"},{"location":"manual/debugging/procedures/#procedures-related-to-debugging","text":"","title":"Procedures related to debugging"},{"location":"manual/debugging/procedures/#help","text":"","title":"help"},{"location":"manual/debugging/procedures/#help-browser","text":"(help [subject]) ;; procedure (help-browser [new-value]) ;; procedure The help procedure displays the section of the Gambit manual with the definition of the procedure or special form subject, which must be a procedure or symbol. For example the call (help gensym) will show the section documenting the gensym procedure and the call (help 'time) will show the section documenting the time special form. When the subject is absent, the documentation of the help procedure is shown. The help procedure returns the void object. The parameter object help-browser is bound to a string naming the external program that is used by the help procedure to view the documentation. Initially it is bound to the empty string. In normal circumstances when help-browser is bound to an empty string the help procedure runs the script ~~bin/gambdoc.bat which searches for a suitable web browser to open the documentation in HTML format. Unless the system was built with the command configure --enable-help-browser=... , the text-only browser lynx (see http://lynx.isc.org/ ) will be used by default if it is available. We highly recommend that you install this browser if you are interested in viewing the documentation within the console in which the REPL is running. You can exit lynx conveniently by typing an end of file (usually <^D> ). For example: > (help-browser \"firefox\") ; use firefox instead of lynx > (help 'gensym) > (help gensym) ; OK because gensym is a procedure > (help 'time) > (help time) ; not OK because time is a special form *** ERROR IN (console)@5.7 -- Macro name can't be used as a variable: time >","title":"help-browser"},{"location":"manual/debugging/procedures/#apropos","text":"(apropos [substring [port]]) ;; procedure The apropos procedure writes to the port port a report of all the global variables whose name contains substring , a string or symbol . If substring is not specified the report contains all the global variables. If it is not specified, port defaults to the interaction channel (i.e. the output will appear at the REPL). The apropos procedure returns the void object. The global variables are grouped into namespaces. The empty namespace, if it is relevant, is last. This reduces the likelihood it will scroll off the screen if there are several global variables in other namespaces, which are typically less interesting. Note that with the apropos procedure it is possible to reveal the existence of procedures of the runtime system and modules that are not intended to be called by user code. These procedures often avoid type checking their arguments or must be called in a specific context, so calling them incorrectly may crash the system. On the other hand it also allows discovering the existence of certain functionalities that may have gone unnoticed. For example: > (apropos \"cons\") \"##\" namespace: 10^-constants, cons, cons*, cons*-aux, console-port, constant-expression-value, constant-expression?, cprc-quasi-cons, deconstruct-call, define-type-construct-constant, degen-quasi-cons, gen-quasi-cons, quasi-cons, stdio/console-repl-channel, void-constant?, xcons empty namespace: cons, cons*, console-port, xcons > (import (srfi 69)) > (apropos \"table?\") \"##\" namespace: gc-hash-table?, mutable?, readtable?, table? \"srfi/69#\" namespace: hash-table? empty namespace: readtable?, table? > (apropos \"srfi/69#\") \"srfi/69#\" namespace: ||, alist->hash-table, hash, hash-by-identity, hash-table->alist, hash-table-copy, hash-table-delete!, hash-table-equivalence-function, hash-table-exists?, hash-table-fold, hash-table-hash-function, hash-table-keys, hash-table-merge!, hash-table-ref, hash-table-ref/default, hash-table-set!, hash-table-size, hash-table-update!, hash-table-update!/default, hash-table-values, hash-table-walk, hash-table?, make-hash-table, string-ci-hash, string-hash","title":"apropos"},{"location":"manual/debugging/procedures/#repl-result-history-ref","text":"","title":"repl-result-history-ref"},{"location":"manual/debugging/procedures/#repl-result-history-max-length-set","text":"(repl-result-history-ref i) ;; procedure (repl-result-history-max-length-set! n) ;; procedure The REPL keeps a history of the last few results printed by the REPL. The call (repl-result-history-ref i) returns the i th previous result (the last for i=0 , the next to last for i=1 , etc). By default the REPL result history remembers up to 3 results. The maximal length of the history can be set to n between 0 and 10 by a call to (repl-result-history-max-length-set! n) . For convenience the reader defines an abbreviation for calling repl-result-history-ref . Tokens formed by a sequence of one or more hash signs, such as # , ## , etc, are expanded by the reader into the list (repl-result-history-ref i) , where i is the number of hash signs minus 1. In other words, # will return the last result printed by the REPL, ## will return the next to last, etc. For example: > (map (lambda (x) (* x x)) '(1 2 3)) (1 4 9) > (reverse #) (9 4 1) > (append # ##) (9 4 1 1 4 9) > 1 1 > 1 1 > (+ # ##) 2 > (+ # ##) 3 > (+ # ##) 5 > ##### *** ERROR IN (console)@9.1 -- (Argument 1) Out of range (repl-result-history-ref 3) 1>","title":"repl-result-history-max-length-set!"},{"location":"manual/debugging/procedures/#trace","text":"","title":"trace"},{"location":"manual/debugging/procedures/#untrace","text":"(trace proc ...) ;; procedure (untrace proc ...) ;; procedure The trace procedure starts tracing calls to the specified procedures. When a traced procedure is called, a line containing the procedure and its arguments is displayed (using the procedure call expression syntax). The line is indented with a sequence of vertical bars which indicate the nesting depth of the procedure\u2019s continuation. After the vertical bars is a greater-than sign which indicates that the evaluation of the call is starting. When a traced procedure returns a result, it is displayed with the same indentation as the call but without the greater-than sign. This makes it easy to match calls and results (the result of a given call is the value at the same indentation as the greater-than sign). If a traced procedure P1 performs a tail call to a traced procedure P2 , then P2 will use the same indentation as P1 . This makes it easy to spot tail calls. The special handling for tail calls is needed to preserve the space complexity of the program (i.e. tail calls are implemented as required by Scheme even when they involve traced procedures). The untrace procedure stops tracing calls to the specified procedures. When no argument is passed to the trace procedure, the list of procedures currently being traced is returned. The void object is returned by the trace procedure when it is passed one or more arguments. When no argument is passed to the untrace procedure stops all tracing and returns the void object. A compiled procedure may be traced but only if it is bound to a global variable. For example: > (define (fact n) (if (< n 2) 1 (* n (fact (- n 1))))) > (trace fact) > (fact 5) | > (fact 5) | | > (fact 4) | | | > (fact 3) | | | | > (fact 2) | | | | | > (fact 1) | | | | | 1 | | | | 2 | | | 6 | | 24 | 120 120 > (trace -) *** WARNING -- Rebinding global variable \"-\" to an interpreted procedure > (define (fact-iter n r) (if (< n 2) r (fact-iter (- n 1) (* n r)))) > (trace fact-iter) > (fact-iter 5 1) | > (fact-iter 5 1) | | > (- 5 1) | | 4 | > (fact-iter 4 5) | | > (- 4 1) | | 3 | > (fact-iter 3 20) | | > (- 3 1) | | 2 | > (fact-iter 2 60) | | > (- 2 1) | | 1 | > (fact-iter 1 120) | 120 120 > (trace) (#<procedure #2 fact-iter> #<procedure #3 -> #<procedure #4 fact>) > (untrace) > (fact 5) 120","title":"untrace"},{"location":"manual/debugging/procedures/#step","text":"","title":"step"},{"location":"manual/debugging/procedures/#step-level-set","text":"(step) ;; procedure (step-level-set! level) ;; procedure The step procedure enables single-stepping mode. After the call to step the computation will stop just before the interpreter executes the next evaluation step (as defined by step-level-set! ). A nested REPL is then started. Note that because single-stepping is stopped by the REPL whenever the prompt is displayed it is pointless to enter (step) by itself. On the other hand entering (begin (step) expr) will evaluate expr in single-stepping mode. The procedure step-level-set! sets the stepping level which determines the granularity of the evaluation steps when single-stepping is enabled. The stepping level level must be an exact integer in the range 0 to 7 . At a level of 0 , the interpreter ignores single-stepping mode. At higher levels the interpreter stops the computation just before it performs the following operations, depending on the stepping level: procedure call delay special form and operations at lower levels lambda special form and operations at lower levels define special form and operations at lower levels set! special form and operations at lower levels variable reference and operations at lower levels constant reference and operations at lower levels The default stepping level is 7. For example: > (define (fact n) (if (< n 2) 1 (* n (fact (- n 1))))) > (step-level-set! 1) > (begin (step) (fact 5)) *** STOPPED IN (console)@3.15 1> ,s | > (fact 5) *** STOPPED IN fact, (console)@1.22 1> ,s | | > (< n 2) | | #f *** STOPPED IN fact, (console)@1.43 1> ,s | | > (- n 1) | | 4 *** STOPPED IN fact, (console)@1.37 1> ,s | | > (fact (- n 1)) *** STOPPED IN fact, (console)@1.22 1> ,s | | | > (< n 2) | | | #f *** STOPPED IN fact, (console)@1.43 1> ,s | | | > (- n 1) | | | 3 *** STOPPED IN fact, (console)@1.37 1> ,l | | | > (fact (- n 1)) *** STOPPED IN fact, (console)@1.22 1> ,l | | > (* n (fact (- n 1))) | | 24 *** STOPPED IN fact, (console)@1.32 1> ,l | > (* n (fact (- n 1))) | 120 120","title":"step-level-set!"},{"location":"manual/debugging/procedures/#break","text":"","title":"break"},{"location":"manual/debugging/procedures/#unbreak","text":"(break proc ...) ;; procedure (unbreak proc ...) ;; procedure The break procedure places a breakpoint on each of the specified procedures. When a procedure is called that has a breakpoint, the interpreter will enable single-stepping mode (as if step had been called). This typically causes the computation to stop soon inside the procedure if the stepping level is high enough. The unbreak procedure removes the breakpoints on the specified procedures. With no argument, break returns the list of procedures currently containing breakpoints. The void object is returned by break if it is passed one or more arguments. With no argument unbreak removes all the breakpoints and returns the void object. A breakpoint can be placed on a compiled procedure but only if it is bound to a global variable. For example: > (define (double x) (+ x x)) > (define (triple y) (- (double (double y)) y)) > (define (f z) (* (triple z) 10)) > (break double) > (break -) *** WARNING -- Rebinding global variable \"-\" to an interpreted procedure > (f 5) *** STOPPED IN double, (console)@1.21 1> ,b 0 double (console)@1:21 + 1 triple (console)@2:31 (double y) 2 f (console)@3:18 (triple z) 3 (interaction) (console)@6:1 (f 5) 1> ,e x = 5 1> ,c *** STOPPED IN double, (console)@1.21 1> ,c *** STOPPED IN f, (console)@3.29 1> ,c 150 > (break) (#<procedure #3 -> #<procedure #4 double>) > (unbreak) > (f 5) 150","title":"unbreak"},{"location":"manual/debugging/procedures/#generate-proper-tail-calls","text":"(generate-proper-tail-calls [new-value]) ;; procedure Deprecation warning This procedure is DEPRECATED and will be removed in a future version of Gambit. Use the proper-tail-calls declaration instead. The parameter object generate-proper-tail-calls is bound to a boolean value controlling how the interpreter handles tail calls. When it is bound to #f the interpreter will treat tail calls like nontail calls, that is a new continuation will be created for the call. This setting is useful for debugging, because when a primitive signals an error the location information will point to the call site of the primitive even if this primitive was called with a tail call. The initial value of this parameter object is #t , which means that a tail call will reuse the continuation of the calling function. This parameter object only affects code that is subsequently processed by load or eval , or entered at the REPL. For example: > (generate-proper-tail-calls) #t > (let loop ((i 1)) (if (< i 10) (loop (* i 2)) oops)) *** ERROR IN #<procedure #2>, (console)@2.47 -- Unbound variable: oops 1> ,b 0 #<procedure #2> (console)@2:47 oops 1 (interaction) (console)@2:1 ((letrec ((loop (lambda... 1> ,t > (generate-proper-tail-calls #f) > (let loop ((i 1)) (if (< i 10) (loop (* i 2)) oops)) *** ERROR IN #<procedure #3>, (console)@6.47 -- Unbound variable: oops 1> ,b 0 #<procedure #3> (console)@6:47 oops 1 #<procedure #3> (console)@6:32 (loop (* i 2)) 2 #<procedure #3> (console)@6:32 (loop (* i 2)) 3 #<procedure #3> (console)@6:32 (loop (* i 2)) 4 #<procedure #3> (console)@6:32 (loop (* i 2)) 5 (interaction) (console)@6:1 ((letrec ((loop (lambda...","title":"generate-proper-tail-calls"},{"location":"manual/debugging/procedures/#display-environment-set","text":"(display-environment-set! display?) ;; procedure Deprecation warning This procedure is DEPRECATED and will be removed in a future version of Gambit. Use the parameter object repl-display-environment? instead. This procedure sets a flag that controls the automatic display of the environment by the REPL. If display? is true, the environment is displayed by the REPL before the prompt. The default setting is not to display the environment.","title":"display-environment-set!"},{"location":"manual/debugging/procedures/#repl-display-environment","text":"(repl-display-environment? display?) ;; procedure The parameter object repl-display-environment? is bound to a boolean value that controls the automatic display of the environment by the REPL. If display? is true, the environment is displayed by the REPL before the prompt. This is particularly useful in single-stepping mode. The default setting is not to display the environment.","title":"repl-display-environment?"},{"location":"manual/debugging/procedures/#display-dynamic-environment","text":"(display-dynamic-environment? display?) ;; procedure The parameter object display-dynamic-environment? is bound to a boolean value that controls wether the dynamic environment is displayed when the environment is displayed. The default setting is not to display the dynamic environment.","title":"display-dynamic-environment?"},{"location":"manual/debugging/procedures/#pretty-print","text":"(pretty-print obj [port]) procedure This procedure pretty-prints obj on the port port. If it is not specified, port defaults to the current output-port. For example: > (pretty-print (let* ((x '(1 2 3 4)) (y (list x x x))) (list y y y))) (((1 2 3 4) (1 2 3 4) (1 2 3 4)) ((1 2 3 4) (1 2 3 4) (1 2 3 4)) ((1 2 3 4) (1 2 3 4) (1 2 3 4)))","title":"pretty-print"},{"location":"manual/debugging/procedures/#pp","text":"(pp obj [port]) ;; procedure This procedure pretty-prints obj on the port port. When obj is a procedure created by the interpreter or a procedure created by code compiled with the declaration debug-source , the procedure's source code is displayed. If it is not specified, port defaults to the interaction channel (i.e. the output will appear at the REPL). For example: > (define (f g) (+ (time (g 100)) (time (g 1000)))) > (pp f) (lambda (g) (+ (##time (lambda () (g 100)) '(g 100)) (##time (lambda () (g 1000)) '(g 1000))))","title":"pp"},{"location":"manual/debugging/procedures/#gc-report-set","text":"(gc-report-set! report?) ;; procedure This procedure controls the generation of reports during garbage collections. If the argument is true, a brief report of memory usage is generated after every garbage collection. It contains: the time taken for this garbage collection, the amount of memory allocated in megabytes since the program was started, the size of the heap in megabytes, the heap memory in megabytes occupied by live data, the proportion of the heap occupied by live data, and the number of bytes occupied by movable and nonmovable objects.","title":"gc-report-set!"},{"location":"manual/dynamic_environment/","text":"Dynamic environment The dynamic environment is the structure which allows the system to find the value returned by the standard procedures current-input-port and current-output-port . The standard procedures with-input-from-file and with-output-to-file extend the dynamic environment to produce a new dynamic environment which is in effect for the dynamic extent of the call to the thunk passed as their last argument. These procedures are essentially special purpose dynamic binding operations on hidden dynamic variables (one for current-input-port and one for current-output-port ). Gambit generalizes this dynamic binding mechanism to allow the user to introduce new dynamic variables, called parameter objects, and dynamically bind them. The parameter objects implemented by Gambit are compatible with the specification of the \"Parameter objects SRFI\" ( SRFI 39 ). One important issue is the relationship between the dynamic environments of the parent and child threads when a thread is created. Each thread has its own dynamic environment that is accessed when looking up the value bound to a parameter object by that thread. When a thread\u2019s dynamic environment is extended it does not affect the dynamic environment of other threads. When a thread is created it is given a dynamic environment whose bindings are inherited from the parent thread. In this inherited dynamic environment the parameter objects are bound to the same cells as the parent's dynamic environment (in other words an assignment of a new value to a parameter object is visible in the other thread). Another important issue is the interaction between the dynamic-wind procedure and dynamic environments. When a thread creates a continuation, the thread's dynamic environment and the dynamic-wind stack are saved within the continuation (an alternate but equivalent point of view is that the dynamic-wind stack is part of the dynamic environment). When this continuation is invoked the required dynamic-wind before and after thunks are called and the saved dynamic environment is reinstated as the dynamic environment of the current thread. During the call to each required dynamic-wind before and after thunk, the dynamic environment and the dynamic-wind stack in effect when the corresponding dynamic-wind was executed are reinstated. Note that this specification precisely defines the semantics of calling call-with-current-continuation or invoking a continuation within a before or after thunk. The semantics are well defined even when a continuation created by another thread is invoked. Below is an example exercising the subtleties of this semantics. (with-output-to-file \"foo\" (lambda () (let ((k (call-with-current-continuation (lambda (exit) (with-output-to-file \"bar\" (lambda () (dynamic-wind (lambda () (write '(b1)) (force-output)) (lambda () (let ((x (call-with-current-continuation (lambda (cont) (exit cont))))) (write '(t1)) (force-output) x)) (lambda () (write '(a1)) (force-output))))))))) (if k (dynamic-wind (lambda () (write '(b2)) (force-output)) (lambda () (with-output-to-file \"baz\" (lambda () (write '(t2)) (force-output) ; go back inside (with-output-to-file \"bar\" ...) (k #f)))) (lambda () (write '(a2)) (force-output))))))) The following actions will occur when this code is executed: (b1)(a1) is written to \"bar\", (b2) is then written to \"foo\", (t2) is then written to \"baz\", (a2) is then written to \"foo\", and finally (b1)(t1)(a1) is written to \"bar\". make-parameter (make-parameter obj [set-filter [get-filter]]) ;; procedure The dynamic environment is composed of two parts: the local dynamic environment and the global dynamic environment. There is a single global dynamic environment, and it is used to lookup parameter objects that can\u2019t be found in the local dynamic environment. The make-parameter procedure returns a new parameter object. The set-filter argument is a one argument \"set\" conversion procedure. The get-filter argument is a one argument \"get\" conversion procedure. If they are not specified the conversion procedures default to the identity function. The global dynamic environment is updated to associate the parameter object to a new cell. The initial content of the cell is the result of applying the \"set\" conversion procedure to obj . A parameter object is a procedure which accepts zero or one argument. The cell bound to a particular parameter object in the dynamic environment is accessed by calling the parameter object. When no argument is passed, the value returned is the result of applying the \"get\" conversion procedure to the content of the cell. When one argument is passed the content of the cell is updated with the result of applying the parameter object's \"set\" conversion procedure to the argument. Note that the conversion procedures can be used for guaranteeing the type of the parameter object's binding and/or to perform some conversion of the value. For example: > (define radix (make-parameter 10)) > (radix) 10 > (radix 2) > (radix) 2 > (define prompt (make-parameter 123 (lambda (x) (if (string? x) x (object->string x))))) > (prompt) \"123\" > (prompt \"$\") > (prompt) \"$\" > (define p (make-parameter 100 (lambda (val) ;; set filter (pp (list val: val)) (list 0 val)) (lambda (state) ;; get filter (pp (list state: state)) (set-car! state (+ 1 (car state))) (+ (car state) (cadr state))))) (val: 100) > (p) (state: (0 100)) 101 > (p) (state: (1 100)) 102 > (p) (state: (2 100)) 103 > (p 555) (val: 555) > (p) (state: (0 555)) 556 > (p) (state: (1 555)) 557 > (define write-shared (make-parameter #f (lambda (x) (if (boolean? x) x (error \"only booleans are accepted by write-shared\"))))) > (write-shared 123) *** ERROR IN ##make-parameter -- only booleans are accepted by write-shared parameterize (parameterize ((procedure value) ...) body) ;; special form The parameterize form, evaluates all procedure and value expressions in an unspecified order. All the procedure expressions must evaluate to procedures, either parameter objects or procedures accepting zero and one argument. Then, for each procedure p and in an unspecified order: If p is a parameter object a new cell is created, initialized, and bound to the parameter object in the local dynamic environment. The value contained in the cell is the result of applying the parameter object's \"set\" conversion procedure to value . The resulting dynamic environment is then used for processing the remaining bindings (or the evaluation of body if there are no other bindings). Otherwise p will be used according to the following protocol: we say that the call (p) \"gets p 's value\" and that the call (p x) \"sets p 's value to x\". First, the parameterize form gets p 's value and saves it in a local variable. It then sets p 's value to value. It then processes the remaining bindings (or evaluates body if there are no other bindings). Then it sets p 's value to the saved value. These steps are performed in a dynamic-wind so that it is possible to use continuations to jump into and out of the body (i.e. the dynamic-wind 's before thunk sets p 's value to value and the after thunk sets p 's value to the saved value). The result(s) of the parameterize form are the result(s) of the body . Note Using procedures instead of parameter objects may lead to unexpected results in multithreaded programs because the before and after thunks of the dynamic-wind are not called when control switches between threads. For example: > (define radix (make-parameter 2)) > (define prompt (make-parameter 123 (lambda (x) (if (string? x) x (object->string x))))) > (radix) 2 > (parameterize ((radix 16)) (radix)) 16 > (radix) 2 > (define (f n) (number->string n (radix))) > (f 10) \"1010\" > (parameterize ((radix 8)) (f 10)) \"12\" > (parameterize ((radix 8) (prompt (f 10))) (prompt)) \"1010\" > (define p (let ((x 1)) (lambda args (if (null? args) x (set! x (car args)))))) > (let* ((a (p)) (b (parameterize ((p 2)) (list (p)))) (c (p))) (list a b c)) (1 (2) 1)","title":"Dynamic environment"},{"location":"manual/dynamic_environment/#dynamic-environment","text":"The dynamic environment is the structure which allows the system to find the value returned by the standard procedures current-input-port and current-output-port . The standard procedures with-input-from-file and with-output-to-file extend the dynamic environment to produce a new dynamic environment which is in effect for the dynamic extent of the call to the thunk passed as their last argument. These procedures are essentially special purpose dynamic binding operations on hidden dynamic variables (one for current-input-port and one for current-output-port ). Gambit generalizes this dynamic binding mechanism to allow the user to introduce new dynamic variables, called parameter objects, and dynamically bind them. The parameter objects implemented by Gambit are compatible with the specification of the \"Parameter objects SRFI\" ( SRFI 39 ). One important issue is the relationship between the dynamic environments of the parent and child threads when a thread is created. Each thread has its own dynamic environment that is accessed when looking up the value bound to a parameter object by that thread. When a thread\u2019s dynamic environment is extended it does not affect the dynamic environment of other threads. When a thread is created it is given a dynamic environment whose bindings are inherited from the parent thread. In this inherited dynamic environment the parameter objects are bound to the same cells as the parent's dynamic environment (in other words an assignment of a new value to a parameter object is visible in the other thread). Another important issue is the interaction between the dynamic-wind procedure and dynamic environments. When a thread creates a continuation, the thread's dynamic environment and the dynamic-wind stack are saved within the continuation (an alternate but equivalent point of view is that the dynamic-wind stack is part of the dynamic environment). When this continuation is invoked the required dynamic-wind before and after thunks are called and the saved dynamic environment is reinstated as the dynamic environment of the current thread. During the call to each required dynamic-wind before and after thunk, the dynamic environment and the dynamic-wind stack in effect when the corresponding dynamic-wind was executed are reinstated. Note that this specification precisely defines the semantics of calling call-with-current-continuation or invoking a continuation within a before or after thunk. The semantics are well defined even when a continuation created by another thread is invoked. Below is an example exercising the subtleties of this semantics. (with-output-to-file \"foo\" (lambda () (let ((k (call-with-current-continuation (lambda (exit) (with-output-to-file \"bar\" (lambda () (dynamic-wind (lambda () (write '(b1)) (force-output)) (lambda () (let ((x (call-with-current-continuation (lambda (cont) (exit cont))))) (write '(t1)) (force-output) x)) (lambda () (write '(a1)) (force-output))))))))) (if k (dynamic-wind (lambda () (write '(b2)) (force-output)) (lambda () (with-output-to-file \"baz\" (lambda () (write '(t2)) (force-output) ; go back inside (with-output-to-file \"bar\" ...) (k #f)))) (lambda () (write '(a2)) (force-output))))))) The following actions will occur when this code is executed: (b1)(a1) is written to \"bar\", (b2) is then written to \"foo\", (t2) is then written to \"baz\", (a2) is then written to \"foo\", and finally (b1)(t1)(a1) is written to \"bar\".","title":"Dynamic environment"},{"location":"manual/dynamic_environment/#make-parameter","text":"(make-parameter obj [set-filter [get-filter]]) ;; procedure The dynamic environment is composed of two parts: the local dynamic environment and the global dynamic environment. There is a single global dynamic environment, and it is used to lookup parameter objects that can\u2019t be found in the local dynamic environment. The make-parameter procedure returns a new parameter object. The set-filter argument is a one argument \"set\" conversion procedure. The get-filter argument is a one argument \"get\" conversion procedure. If they are not specified the conversion procedures default to the identity function. The global dynamic environment is updated to associate the parameter object to a new cell. The initial content of the cell is the result of applying the \"set\" conversion procedure to obj . A parameter object is a procedure which accepts zero or one argument. The cell bound to a particular parameter object in the dynamic environment is accessed by calling the parameter object. When no argument is passed, the value returned is the result of applying the \"get\" conversion procedure to the content of the cell. When one argument is passed the content of the cell is updated with the result of applying the parameter object's \"set\" conversion procedure to the argument. Note that the conversion procedures can be used for guaranteeing the type of the parameter object's binding and/or to perform some conversion of the value. For example: > (define radix (make-parameter 10)) > (radix) 10 > (radix 2) > (radix) 2 > (define prompt (make-parameter 123 (lambda (x) (if (string? x) x (object->string x))))) > (prompt) \"123\" > (prompt \"$\") > (prompt) \"$\" > (define p (make-parameter 100 (lambda (val) ;; set filter (pp (list val: val)) (list 0 val)) (lambda (state) ;; get filter (pp (list state: state)) (set-car! state (+ 1 (car state))) (+ (car state) (cadr state))))) (val: 100) > (p) (state: (0 100)) 101 > (p) (state: (1 100)) 102 > (p) (state: (2 100)) 103 > (p 555) (val: 555) > (p) (state: (0 555)) 556 > (p) (state: (1 555)) 557 > (define write-shared (make-parameter #f (lambda (x) (if (boolean? x) x (error \"only booleans are accepted by write-shared\"))))) > (write-shared 123) *** ERROR IN ##make-parameter -- only booleans are accepted by write-shared","title":"make-parameter"},{"location":"manual/dynamic_environment/#parameterize","text":"(parameterize ((procedure value) ...) body) ;; special form The parameterize form, evaluates all procedure and value expressions in an unspecified order. All the procedure expressions must evaluate to procedures, either parameter objects or procedures accepting zero and one argument. Then, for each procedure p and in an unspecified order: If p is a parameter object a new cell is created, initialized, and bound to the parameter object in the local dynamic environment. The value contained in the cell is the result of applying the parameter object's \"set\" conversion procedure to value . The resulting dynamic environment is then used for processing the remaining bindings (or the evaluation of body if there are no other bindings). Otherwise p will be used according to the following protocol: we say that the call (p) \"gets p 's value\" and that the call (p x) \"sets p 's value to x\". First, the parameterize form gets p 's value and saves it in a local variable. It then sets p 's value to value. It then processes the remaining bindings (or evaluates body if there are no other bindings). Then it sets p 's value to the saved value. These steps are performed in a dynamic-wind so that it is possible to use continuations to jump into and out of the body (i.e. the dynamic-wind 's before thunk sets p 's value to value and the after thunk sets p 's value to the saved value). The result(s) of the parameterize form are the result(s) of the body . Note Using procedures instead of parameter objects may lead to unexpected results in multithreaded programs because the before and after thunks of the dynamic-wind are not called when control switches between threads. For example: > (define radix (make-parameter 2)) > (define prompt (make-parameter 123 (lambda (x) (if (string? x) x (object->string x))))) > (radix) 2 > (parameterize ((radix 16)) (radix)) 16 > (radix) 2 > (define (f n) (number->string n (radix))) > (f 10) \"1010\" > (parameterize ((radix 8)) (f 10)) \"12\" > (parameterize ((radix 8) (prompt (f 10))) (prompt)) \"1010\" > (define p (let ((x 1)) (lambda args (if (null? args) x (set! x (car args)))))) > (let* ((a (p)) (b (parameterize ((p 2)) (list (p)))) (c (p))) (list a b c)) (1 (2) 1)","title":"parameterize"},{"location":"manual/exceptions/","text":"Exceptions","title":"Exceptions"},{"location":"manual/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"manual/gsc/","text":"The Gambit Scheme Compiler gsc [-:runtimeoption,\u2026] [-i] [-f] [-h] [-help] [-v] [-target target] [-prelude expressions] [-postlude expressions] [-dynamic] [-exe] [-obj] [-nb-gvm-regs n] [-nb-arg-regs n] [-compactness level] [-cc compiler] [-cc-options options] [-ld-options-prelude options] [-ld-options options] [-pkg-config pkg-config-args] [-pkg-config-path pkg-config-path] [-warnings] [-verbose] [-report] [-expansion] [-gvm] [-cfg] [-dg] [-debug] [-debug-location] [-debug-source] [-debug-environments] [-track-scheme] [-o output] [-c] [-keep-temp] [-link] [-flat] [-l base] [-module-ref module-ref] [-linker-name linker-name] [[-] [-e expressions] [-preload] [-nopreload] [search-directory-or-module-or-file]]\u2026 The -h and -help options print brief usage information on standard output and exit. The -v option prints the system version string, system time stamp, operating system type, and configure script options on standard output and exits. The -i option can be used to force gsc to process the command line like the interpreter. The only difference with the interpreter is that the compilation related procedures listed in this chapter are also available (i.e. compile-file , compile-file-to-target , etc).","title":"The Gambit Scheme Compiler"},{"location":"manual/gsc/#the-gambit-scheme-compiler","text":"gsc [-:runtimeoption,\u2026] [-i] [-f] [-h] [-help] [-v] [-target target] [-prelude expressions] [-postlude expressions] [-dynamic] [-exe] [-obj] [-nb-gvm-regs n] [-nb-arg-regs n] [-compactness level] [-cc compiler] [-cc-options options] [-ld-options-prelude options] [-ld-options options] [-pkg-config pkg-config-args] [-pkg-config-path pkg-config-path] [-warnings] [-verbose] [-report] [-expansion] [-gvm] [-cfg] [-dg] [-debug] [-debug-location] [-debug-source] [-debug-environments] [-track-scheme] [-o output] [-c] [-keep-temp] [-link] [-flat] [-l base] [-module-ref module-ref] [-linker-name linker-name] [[-] [-e expressions] [-preload] [-nopreload] [search-directory-or-module-or-file]]\u2026 The -h and -help options print brief usage information on standard output and exit. The -v option prints the system version string, system time stamp, operating system type, and configure script options on standard output and exits. The -i option can be used to force gsc to process the command line like the interpreter. The only difference with the interpreter is that the compilation related procedures listed in this chapter are also available (i.e. compile-file , compile-file-to-target , etc).","title":"The Gambit Scheme Compiler"},{"location":"manual/gsc/batch_mode/","text":"Batch mode In batch mode gsc accepts on the command line 3 types of non-options which are processed from left to right: search directories, modules, and files. Search directories are added to the list of module search order directories. Every command line argument that is the name of a module that is found in the list of module search order directories will cause that module to be compiled. Similarly, file names (with either no extension, or a C file extension, or some other extension) on the command line will cause that file to be compiled. The compilation is done for the target language specified with the -target target option. target is either js, for JavaScript, or C, which is the default if no target language is specified. The recognized C file extensions are .c , .C , .cc , .cp , .cpp , .CPP , .cxx , .c++ , .m , .M , and .mm . The extension can be omitted from a file name when the Scheme file has a .scm , .sld or .six extension. When the extension of the Scheme file is .six the content of the file will be parsed using the Scheme infix syntax extension (see Scheme infix syntax extension ). Otherwise, gsc will parse the Scheme file using the normal Scheme prefix syntax. Files with a C file extension must have been previously produced by gsc with the C target and the -c option, and are used by the C target Gambit linker. For each Scheme file the compiler creates a file of target code, either file.c or file.js for the C and js targets respectively. The file's name is the same as the Scheme file, but the extension is changed to .c or .js as appropriate. By default the file is created in the same directory as the Scheme file. This default can be overridden with the compiler's -o option. The files of target code produced by the compiler serve two purposes. They will be processed by a C compiler or JavaScript VM, and they also contain information to be read by Gambit\u2019s linker to generate a link file. The link file is a file of target code that collects various linking information for a group of modules, such as the set of all symbols and global variables used by the modules. The linker is only invoked when the -link or -exe options appear on the command line. Compiler options must be specified before the first file name and after the -: runtime option (see section Runtime options ). If present, the -i , -f , and -v compiler options must come first. The available options are: -i : Force interpreter mode. -f :Do not examine the initialization file. -h / -help : Print brief usage information on standard output and exit. -v : Print the system version string, system time stamp, operating system type, and configure script options on standard output and exit. -target target : Select the target language. -prelude expressions : Add expressions to the top of the source code being compiled. -postlude expressions : Add expressions to the bottom of the source code being compiled. -cc compiler : Select specific C compiler. -cc-options options : Add options to the command that invokes the C compiler. -ld-options-prelude options : Add options to the command that invokes the C linker. -ld-options options : Add options to the command that invokes the C linker. -pkg-config pkg-config-args : Use the pkg-config program to determine options for the C compiler and C linker. -pkg-config-path pkg-config-path : Add a path to the PKG_CONFIG_PATH environment variable. -warnings : Display warnings. -verbose : Display a trace of the compiler's activity. -report : Display a global variable usage report. -expansion : Display the source code after expansion. -gvm : Generate a listing of the GVM code. -cfg : Generate a control flow graph of the GVM code. -dg : Generate a dependency graph. -debug : Include all debugging information in the code generated. -debug-location : Include source code location debugging information in the code generated. -debug-source : Include the source code debugging information in the code generated. -debug-environments : Include environment debugging information in the code generated. -track-scheme : Generate #line directives referring back to the Scheme code. -o output : Set name of output file or directory where output file(s) are written. -dynamic : Compile Scheme source files to dynamically loadable object files (this is the default). -exe : Compile Scheme source files to an executable program (machine code or script). -obj : Compile Scheme source files to object files by invoking the C compiler. -keep-temp : Keep any intermediate files that are generated. -c : Compile Scheme source files to target code without generating a link file. -link : Compile Scheme source files to target code and generate a link file. -flat : Generate a flat link file instead of the default incremental link file. -l base : Specify the link file of the base library to use for the link. -module-ref module-ref : Specify the reference of the generated module. -linker-name linker-name : Specify the name of the low-level initialization function exported by the module. -preload : Turn on preload linker bit. -nopreload : Turn off preload linker bit. Start REPL interaction. -e expressions : Evaluate expressions in the interaction environment. -nb-gvm-regs n : Specify the number of available Gambit virtual machine registers. -nb-arg-regs n : Specify the number of procedure call parameters passed in Gambit virtual machine registers. -compactness level : Specify the compactness of the generated code. The -i option forces the compiler to process the remaining command line arguments like the interpreter. The -target option selects the target language of the compilation. It is either js for JavaScript, or C for C (which is the default). The -prelude option adds the specified expressions to the top of the source code being compiled. It can appear multiple times. The main use of this option is to supply declarations on the command line. For example the following invocation of the compiler will compile the file bench.scm in unsafe mode: $ gsc -prelude \"(declare (not safe))\" bench.scm The -postlude option adds the specified expressions to the bottom of the source code being compiled. It can appear multiple times. The main use of this option is to supply the expression that will start the execution of the program. For example: $ gsc -postlude \"(start-bench)\" bench.scm The -cc option is only meaningful when the C target is selected. The -cc option selects the specified C compiler for compiling the generated C code. When this option is used, the default C compiler options that were determined to be needed by the configure script are nullified because they are very likely to be invalid for the specified C compiler. Any options needed for this C compiler should be specified explicitly using the -cc-options , -ld-options-prelude , and -ld-options options. For example: $ gsc -cc clang -cc-options \"-O0 -bundle\" bench.scm # clang on macOS $ gsc -cc tcc -cc-options -shared bench.scm # tcc on linux The -cc-options option is only meaningful when the C target is selected and a dynamically loadable object file is being generated (neither the -c or -link options are used). It can appear multiple times. The -cc-options option adds the specified options to the command that invokes the C compiler. The main use of this option is to specify the include path, some symbols to define or undefine, the optimization level, or any C compiler option that is different from the default. For example: $ gsc -cc-options \"-U___SINGLE_HOST -O2 -I../include\" bench.scm The -ld-options-prelude and -ld-options options are only meaningful when the C target is selected and a dynamically loadable object file is being generated (neither the -c or -link options are used). They can appear multiple times. The -ld-options-prelude and -ld-options options add the specified options to the command that invokes the C linker (the options in ld-options-prelude are passed to the C linker before the input file and the options in ld-options are passed after). The main use of this option is to specify additional object files or libraries that need to be linked, or any C linker option that is different from the default (such as the library search path and flags to select between static and dynamic linking). For example: $ gsc -ld-options \"-L/usr/X11R6/lib -lX11 -dynamic\" app.scm The -pkg-config is only meaningful when the C target is selected. The -pkg-config option will cause the pkg-config program to be invoked to determine the options to add to the command that invokes the C compiler and C linker. It can appear multiple times. The pkg-config program is passed the arguments in the string pkg-config-args in addition to either --cflags or --libs . It is typical for pkg-config-args to be the name of a system library, such as \"sqlite3\" , but other pkg-config options can be specified, such as \"--static sqlite3\" . The -pkg-config-path option adds a path to the PKG_CONFIG_PATH environment variable for use by the pkg-config program to find .pc files. For example: $ gsc -pkg-config \"x11\" -pkg-config-path \"/usr/share/pkgconfig\" app.scm The -warnings option displays on standard output all warnings that the compiler may have. The -verbose option displays on standard output a trace of the compiler's activity. The -report option displays on standard output a global variable usage report. Each global variable used in the program is listed with 4 flags that indicate whether the global variable is defined, referenced, mutated and called. The -expansion option displays on standard output the source code after expansion and inlining by the front end. The -gvm option generates a listing of the intermediate code for the \u201cGambit Virtual Machine\u201d (GVM) of each Scheme file on file.gvm . The -cfg option generates a visual representation of the control flow graph of the intermediate code for the \u201cGambit Virtual Machine\u201d (GVM) of each Scheme file on file.cfg . The file is suitable for processing with the dot program. For example, to generate the PDF file file.cfg.pdf from file.cfg the following command can be used: $ dot -O -Tpdf file.cfg The -dg option generates a visual representation of the dependency graph of each Scheme file on file.dg . The file is suitable for processing with the dot program. For example, to generate the PDF file file.dg.pdf from file.dg the following command can be used: $ dot -O -Tpdf file.dg The -debug option causes all kinds of debugging information to be saved in the code generated. See the documentation of the debug declaration for details. The -debug-location option causes source code location debugging information to be saved in the code generated. See the documentation of the debug-location declaration for details. The -debug-source option causes source code debugging information to be saved in the code generated. See the documentation of the debug-source declaration for details. The -debug-environments option causes environment debugging information to be saved in the code generated. See the documentation of the debug-environments declaration for details. The -track-scheme option is only meaningful when the C target is selected. The -track-scheme option causes the generation of #line directives that refer back to the Scheme source code. This allows the use of a C debugger or profiler to debug Scheme code. The -o option sets the filename of the output file, or the directory in which the output file(s) generated by the compiler are written. If the -link or -exe options appear on the command line, the Gambit linker is invoked to generate the link file from the set of files specified on the command line or produced by the Gambit compiler. By default the link file is named after the last file on the compiler's command line. If the last file stripped of it's extension is last then the link file is last_.c for the C target and last_.js for the js target. When the -c option is specified, the Scheme source files are compiled to target files without invoking the linker, which is useful for separate compilation of modules. When the -exe option is specified, the generated target files and link file are combined to produce an executable program whose name defaults to last on Unix, and last.exe or last.bat on Windows depending on whether a machine code executable or script is produced. When the C target is selected and the -obj option is specified, the generated C files are compiled using the C compiler to produce object files ( .o or .obj extensions). If neither the -link , -c , -exe , or -obj options appear on the command line, the Scheme source files are compiled to dynamically loadable object files ( .on extension). The -keep-temp option will prevent the deletion of any intermediate files that are generated. Note that in this case the intermediate file will be generated in the same directory as the Scheme source file even if the -o option is used. The -flat option is only meaningful when a link file is being generated (i.e. the -link or -exe options also appear on the command line). The -flat option directs the Gambit linker to generate a flat link file. By default, the linker generates an incremental link file (see the next section for a description of the two types of link files). The -l option is only meaningful when an incremental link file is being generated (i.e. the -link or -exe options appear on the command line and the -flat option is absent). The -l option specifies the link file (without the .c or .js extension) of the base library to use for the incremental link. By default the link file of the Gambit runtime library is used (i.e. ~~lib/_gambit ). The -preload and -nopreload options are only meaningful when a link file is being generated. The -preload option turns on the preload linker bit for the modules that follow on the command line. The following modules will be loaded unconditionally at program startup and in command line order (this is the default for compatibility with how legacy modules have been handled in the past). The -nopreload option turns off the preload linker bit. The following modules will be loaded only to satisfy the module dependencies of the ##demand-module form. The - option starts a REPL interaction. The -e option evaluates the specified expressions in the interaction environment. The -nb-gvm-regs option specifies the number of Gambit virtual machine registers that are available for the generated code. The default number depends on configuration options and the target but it is typically 5 . All modules and the runtime library must be compiled with the same setting. This option exists mainly for experimentation by the developers. For example: $ gsc -nb-gvm-regs 10 -c bench.scm The -nb-arg-regs option specifies the number of procedure call parameters passed in Gambit virtual machine registers. The default number depends on configuration options and the target but it is typically 3 . All modules and the runtime library must be compiled with the same setting. This option exists mainly for experimentation by the developers. For example: $ gsc -nb-arg-regs 2 -c bench.scm The -compactness option selects the level of compactness of the generated code. The default level depends on configuration options and the target but it is typically 5 . Levels from 0 to 5 cause the generation of increasingly compact code with little or no impact on execution speed. Lower values tend to make the generated code more humanly readable. Above a level of 5 the compiler will trade execution speed for saving code space. The detailed meaning of this option depends on the target, some targets may ignore it and some targets may require all modules and the runtime library to be compiled with the same compactness level. For example: $ gsc -target js -compactness 0 -c bench.scm","title":"Batch mode"},{"location":"manual/gsc/batch_mode/#batch-mode","text":"In batch mode gsc accepts on the command line 3 types of non-options which are processed from left to right: search directories, modules, and files. Search directories are added to the list of module search order directories. Every command line argument that is the name of a module that is found in the list of module search order directories will cause that module to be compiled. Similarly, file names (with either no extension, or a C file extension, or some other extension) on the command line will cause that file to be compiled. The compilation is done for the target language specified with the -target target option. target is either js, for JavaScript, or C, which is the default if no target language is specified. The recognized C file extensions are .c , .C , .cc , .cp , .cpp , .CPP , .cxx , .c++ , .m , .M , and .mm . The extension can be omitted from a file name when the Scheme file has a .scm , .sld or .six extension. When the extension of the Scheme file is .six the content of the file will be parsed using the Scheme infix syntax extension (see Scheme infix syntax extension ). Otherwise, gsc will parse the Scheme file using the normal Scheme prefix syntax. Files with a C file extension must have been previously produced by gsc with the C target and the -c option, and are used by the C target Gambit linker. For each Scheme file the compiler creates a file of target code, either file.c or file.js for the C and js targets respectively. The file's name is the same as the Scheme file, but the extension is changed to .c or .js as appropriate. By default the file is created in the same directory as the Scheme file. This default can be overridden with the compiler's -o option. The files of target code produced by the compiler serve two purposes. They will be processed by a C compiler or JavaScript VM, and they also contain information to be read by Gambit\u2019s linker to generate a link file. The link file is a file of target code that collects various linking information for a group of modules, such as the set of all symbols and global variables used by the modules. The linker is only invoked when the -link or -exe options appear on the command line. Compiler options must be specified before the first file name and after the -: runtime option (see section Runtime options ). If present, the -i , -f , and -v compiler options must come first. The available options are: -i : Force interpreter mode. -f :Do not examine the initialization file. -h / -help : Print brief usage information on standard output and exit. -v : Print the system version string, system time stamp, operating system type, and configure script options on standard output and exit. -target target : Select the target language. -prelude expressions : Add expressions to the top of the source code being compiled. -postlude expressions : Add expressions to the bottom of the source code being compiled. -cc compiler : Select specific C compiler. -cc-options options : Add options to the command that invokes the C compiler. -ld-options-prelude options : Add options to the command that invokes the C linker. -ld-options options : Add options to the command that invokes the C linker. -pkg-config pkg-config-args : Use the pkg-config program to determine options for the C compiler and C linker. -pkg-config-path pkg-config-path : Add a path to the PKG_CONFIG_PATH environment variable. -warnings : Display warnings. -verbose : Display a trace of the compiler's activity. -report : Display a global variable usage report. -expansion : Display the source code after expansion. -gvm : Generate a listing of the GVM code. -cfg : Generate a control flow graph of the GVM code. -dg : Generate a dependency graph. -debug : Include all debugging information in the code generated. -debug-location : Include source code location debugging information in the code generated. -debug-source : Include the source code debugging information in the code generated. -debug-environments : Include environment debugging information in the code generated. -track-scheme : Generate #line directives referring back to the Scheme code. -o output : Set name of output file or directory where output file(s) are written. -dynamic : Compile Scheme source files to dynamically loadable object files (this is the default). -exe : Compile Scheme source files to an executable program (machine code or script). -obj : Compile Scheme source files to object files by invoking the C compiler. -keep-temp : Keep any intermediate files that are generated. -c : Compile Scheme source files to target code without generating a link file. -link : Compile Scheme source files to target code and generate a link file. -flat : Generate a flat link file instead of the default incremental link file. -l base : Specify the link file of the base library to use for the link. -module-ref module-ref : Specify the reference of the generated module. -linker-name linker-name : Specify the name of the low-level initialization function exported by the module. -preload : Turn on preload linker bit. -nopreload : Turn off preload linker bit. Start REPL interaction. -e expressions : Evaluate expressions in the interaction environment. -nb-gvm-regs n : Specify the number of available Gambit virtual machine registers. -nb-arg-regs n : Specify the number of procedure call parameters passed in Gambit virtual machine registers. -compactness level : Specify the compactness of the generated code. The -i option forces the compiler to process the remaining command line arguments like the interpreter. The -target option selects the target language of the compilation. It is either js for JavaScript, or C for C (which is the default). The -prelude option adds the specified expressions to the top of the source code being compiled. It can appear multiple times. The main use of this option is to supply declarations on the command line. For example the following invocation of the compiler will compile the file bench.scm in unsafe mode: $ gsc -prelude \"(declare (not safe))\" bench.scm The -postlude option adds the specified expressions to the bottom of the source code being compiled. It can appear multiple times. The main use of this option is to supply the expression that will start the execution of the program. For example: $ gsc -postlude \"(start-bench)\" bench.scm The -cc option is only meaningful when the C target is selected. The -cc option selects the specified C compiler for compiling the generated C code. When this option is used, the default C compiler options that were determined to be needed by the configure script are nullified because they are very likely to be invalid for the specified C compiler. Any options needed for this C compiler should be specified explicitly using the -cc-options , -ld-options-prelude , and -ld-options options. For example: $ gsc -cc clang -cc-options \"-O0 -bundle\" bench.scm # clang on macOS $ gsc -cc tcc -cc-options -shared bench.scm # tcc on linux The -cc-options option is only meaningful when the C target is selected and a dynamically loadable object file is being generated (neither the -c or -link options are used). It can appear multiple times. The -cc-options option adds the specified options to the command that invokes the C compiler. The main use of this option is to specify the include path, some symbols to define or undefine, the optimization level, or any C compiler option that is different from the default. For example: $ gsc -cc-options \"-U___SINGLE_HOST -O2 -I../include\" bench.scm The -ld-options-prelude and -ld-options options are only meaningful when the C target is selected and a dynamically loadable object file is being generated (neither the -c or -link options are used). They can appear multiple times. The -ld-options-prelude and -ld-options options add the specified options to the command that invokes the C linker (the options in ld-options-prelude are passed to the C linker before the input file and the options in ld-options are passed after). The main use of this option is to specify additional object files or libraries that need to be linked, or any C linker option that is different from the default (such as the library search path and flags to select between static and dynamic linking). For example: $ gsc -ld-options \"-L/usr/X11R6/lib -lX11 -dynamic\" app.scm The -pkg-config is only meaningful when the C target is selected. The -pkg-config option will cause the pkg-config program to be invoked to determine the options to add to the command that invokes the C compiler and C linker. It can appear multiple times. The pkg-config program is passed the arguments in the string pkg-config-args in addition to either --cflags or --libs . It is typical for pkg-config-args to be the name of a system library, such as \"sqlite3\" , but other pkg-config options can be specified, such as \"--static sqlite3\" . The -pkg-config-path option adds a path to the PKG_CONFIG_PATH environment variable for use by the pkg-config program to find .pc files. For example: $ gsc -pkg-config \"x11\" -pkg-config-path \"/usr/share/pkgconfig\" app.scm The -warnings option displays on standard output all warnings that the compiler may have. The -verbose option displays on standard output a trace of the compiler's activity. The -report option displays on standard output a global variable usage report. Each global variable used in the program is listed with 4 flags that indicate whether the global variable is defined, referenced, mutated and called. The -expansion option displays on standard output the source code after expansion and inlining by the front end. The -gvm option generates a listing of the intermediate code for the \u201cGambit Virtual Machine\u201d (GVM) of each Scheme file on file.gvm . The -cfg option generates a visual representation of the control flow graph of the intermediate code for the \u201cGambit Virtual Machine\u201d (GVM) of each Scheme file on file.cfg . The file is suitable for processing with the dot program. For example, to generate the PDF file file.cfg.pdf from file.cfg the following command can be used: $ dot -O -Tpdf file.cfg The -dg option generates a visual representation of the dependency graph of each Scheme file on file.dg . The file is suitable for processing with the dot program. For example, to generate the PDF file file.dg.pdf from file.dg the following command can be used: $ dot -O -Tpdf file.dg The -debug option causes all kinds of debugging information to be saved in the code generated. See the documentation of the debug declaration for details. The -debug-location option causes source code location debugging information to be saved in the code generated. See the documentation of the debug-location declaration for details. The -debug-source option causes source code debugging information to be saved in the code generated. See the documentation of the debug-source declaration for details. The -debug-environments option causes environment debugging information to be saved in the code generated. See the documentation of the debug-environments declaration for details. The -track-scheme option is only meaningful when the C target is selected. The -track-scheme option causes the generation of #line directives that refer back to the Scheme source code. This allows the use of a C debugger or profiler to debug Scheme code. The -o option sets the filename of the output file, or the directory in which the output file(s) generated by the compiler are written. If the -link or -exe options appear on the command line, the Gambit linker is invoked to generate the link file from the set of files specified on the command line or produced by the Gambit compiler. By default the link file is named after the last file on the compiler's command line. If the last file stripped of it's extension is last then the link file is last_.c for the C target and last_.js for the js target. When the -c option is specified, the Scheme source files are compiled to target files without invoking the linker, which is useful for separate compilation of modules. When the -exe option is specified, the generated target files and link file are combined to produce an executable program whose name defaults to last on Unix, and last.exe or last.bat on Windows depending on whether a machine code executable or script is produced. When the C target is selected and the -obj option is specified, the generated C files are compiled using the C compiler to produce object files ( .o or .obj extensions). If neither the -link , -c , -exe , or -obj options appear on the command line, the Scheme source files are compiled to dynamically loadable object files ( .on extension). The -keep-temp option will prevent the deletion of any intermediate files that are generated. Note that in this case the intermediate file will be generated in the same directory as the Scheme source file even if the -o option is used. The -flat option is only meaningful when a link file is being generated (i.e. the -link or -exe options also appear on the command line). The -flat option directs the Gambit linker to generate a flat link file. By default, the linker generates an incremental link file (see the next section for a description of the two types of link files). The -l option is only meaningful when an incremental link file is being generated (i.e. the -link or -exe options appear on the command line and the -flat option is absent). The -l option specifies the link file (without the .c or .js extension) of the base library to use for the incremental link. By default the link file of the Gambit runtime library is used (i.e. ~~lib/_gambit ). The -preload and -nopreload options are only meaningful when a link file is being generated. The -preload option turns on the preload linker bit for the modules that follow on the command line. The following modules will be loaded unconditionally at program startup and in command line order (this is the default for compatibility with how legacy modules have been handled in the past). The -nopreload option turns off the preload linker bit. The following modules will be loaded only to satisfy the module dependencies of the ##demand-module form. The - option starts a REPL interaction. The -e option evaluates the specified expressions in the interaction environment. The -nb-gvm-regs option specifies the number of Gambit virtual machine registers that are available for the generated code. The default number depends on configuration options and the target but it is typically 5 . All modules and the runtime library must be compiled with the same setting. This option exists mainly for experimentation by the developers. For example: $ gsc -nb-gvm-regs 10 -c bench.scm The -nb-arg-regs option specifies the number of procedure call parameters passed in Gambit virtual machine registers. The default number depends on configuration options and the target but it is typically 3 . All modules and the runtime library must be compiled with the same setting. This option exists mainly for experimentation by the developers. For example: $ gsc -nb-arg-regs 2 -c bench.scm The -compactness option selects the level of compactness of the generated code. The default level depends on configuration options and the target but it is typically 5 . Levels from 0 to 5 cause the generation of increasingly compact code with little or no impact on execution speed. Lower values tend to make the generated code more humanly readable. Above a level of 5 the compiler will trade execution speed for saving code space. The detailed meaning of this option depends on the target, some targets may ignore it and some targets may require all modules and the runtime library to be compiled with the same compactness level. For example: $ gsc -target js -compactness 0 -c bench.scm","title":"Batch mode"},{"location":"manual/gsc/customization/","text":"Customization Like the interpreter, the compiler will examine the initialization file unless the -f option is specified. Runtime options are explained in Runtime options .","title":"Customization"},{"location":"manual/gsc/customization/#customization","text":"Like the interpreter, the compiler will examine the initialization file unless the -f option is specified. Runtime options are explained in Runtime options .","title":"Customization"},{"location":"manual/gsc/interactive_mode/","text":"Interactive mode When no command line argument is present other than options gsc behaves like gsi in interactive mode .","title":"Interactive mode"},{"location":"manual/gsc/interactive_mode/#interactive-mode","text":"When no command line argument is present other than options gsc behaves like gsi in interactive mode .","title":"Interactive mode"},{"location":"manual/gsc/link_files/","text":"Link files Gambit can be used to create programs and libraries of Scheme modules. This section explains the steps required to do so and the role played by the link files. In general, a program is composed of a set of Scheme modules and modules in the target language. Some of the modules are part of the Gambit runtime library and the other modules are supplied by the user. When the program is started it must setup various global tables (including the symbol table and the global variable table) and then sequentially execute the Scheme modules (more or less as though they were being loaded one after another). The information required for this is contained in one or more link files generated by the Gambit linker from the target files produced by the Gambit compiler. The order of execution of the Scheme modules corresponds to the order of the modules on the command line which produced the link file. The order is usually important because most modules define variables and procedures which are used by other modules (for this reason the program's main computation is normally started by the last module). When a single link file is used to contain the linking information of all the Scheme modules it is called a flat link file. Thus a program built with a flat link file contains in its link file both information on the user modules and on the runtime library. This is fine if the program is to be statically linked but is wasteful in a shared-library context because the linking information of the runtime library can\u2019t be shared and will be duplicated in all programs (this linking information typically takes hundreds of kilobytes). Flat link files are mainly useful to bundle multiple Scheme modules to make a runtime library (such as the Gambit runtime library) or to make a single file that can be loaded with the load procedure. An incremental link file contains only the linking information that is not already contained in a second link file (the \"base\" link file). Assuming that a flat link file was produced when the runtime library was linked, a program can be built by linking the user modules with the runtime library's link file, producing an incremental link file. This allows the creation of a shared-library which contains the modules of the runtime library and its flat link file. The program is dynamically linked with this shared-library and only contains the user modules and the incremental link file. For small programs this approach greatly reduces the size of the program because the incremental link file is small. A \"hello world\" program built this way can be as small as 5 Kbytes. Note that it is perfectly fine to use an incremental link file for statically linked programs (there is very little loss compared to a single flat link file). Incremental link files may be built from other incremental link files. This allows the creation of shared-libraries which extend the functionality of the Gambit runtime library. Building an executable program The simplest way to create an executable program is to invoke gsc with the -exe option. The compiler will transparently perform all the steps necessary, including compiling Scheme source files to target files, generating the link file, and (when the C target is selected) compiling the C files generated to object files and creating the final executable file using the C linker. The following example shows how to use the C target to build the executable program hello.exe which contains the two Scheme modules h.scm and w.six . $ cat h.scm (display \"hello\") (newline) $ cat w.six display(\"world\"); newline(); $ gsc -o hello.exe -exe h.scm w.six h.scm: /Users/feeley/gambit/doc/h.c: w.six: /Users/feeley/gambit/doc/w.c: /Users/feeley/gambit/doc/w_.c: $ ./hello.exe hello world The detailed steps which are performed can be viewed by setting the GAMBUILD_VERBOSE environment variable to a nonnull value. Alternatively, gsc \u2019s -verbose option can be used (it implicitly sets the GAMBUILD_VERBOSE environment variable). For example: $ export GAMBUILD_VERBOSE=yes $ gsc -o hello.exe -exe h.scm w.six h.scm: /Users/feeley/gambit/doc/h.c: gcc -O1 -Wno-unused -Wno-write-strings -Wdisabled-optimization fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -c -o 'h.o' 'h.c' w.six: /Users/feeley/gambit/doc/w.c: gcc -O1 -Wno-unused -Wno-write-strings -Wdisabled-optimization -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -c -o 'w.o' 'w.c' /Users/feeley/gambit/doc/w_.c: gcc -O1 -Wno-unused -Wno-write-strings -Wdisabled-optimization -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -c -o 'w_.o' 'w_.c' gcc -Wno-unused -Wno-write-strings -Wdisabled-optimization -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -o 'hello.exe' 'w_.o' 'h.o' 'w.o' \"/usr/local/Gambit/lib/libgambit.a\" Here is the same example using the js target showing the creation of a shell script invoking nodejs : $ export GAMBUILD_VERBOSE=yes $ gsc -target js -o hello.exe -exe h.scm w.six h.scm: /Users/feeley/gambit/doc/h.js: cat h.js > \"h.o\" w.six: /Users/feeley/gambit/doc/w.js: cat w.js > \"w.o\" /Users/feeley/gambit/doc/w_.js: cat w_.js > \"w_.o\" echo \"#! /usr/bin/env node\" > \"hello.exe\" cat w_.o h.o w.o \"/usr/local/Gambit/lib/_gambit.js\" >> \"hello.exe\" chmod +x \"hello.exe\" Using a single invocation of gsc with the -exe option is sometimes inappropriate when the build process is more complex, for example when the program is composed of several separately compiled modules. In such a case it is useful to decompose the build process into smaller compilation steps. The hello.exe executable program could have been built with the C target by separating the generation of C files from the C compilation and linking: $ gsc -c h.scm $ gsc -c w.six $ gsc -o hello.exe -exe h.c w.c When even finer control is desired the C target's build process can be decomposed into smaller steps that invoke the C compiler and linker explicitly. This is described in the rest of this section. The gsc compiler can be invoked to compile each Scheme module into a C file and to create an incremental link file. The C files and the link file must then be compiled with a C compiler and linked (at the object file level) with the Gambit runtime library and possibly other libraries (such as the math library and the dynamic loading library). Here is for example how a program with three modules (one in C and two in Scheme) can be built. The content of the three source files ( m1.c , m2.scm and m3.scm ) is: /* File: \"m1.c\" */ int power_of_2 (int x) { return 1<<x; } ; File: \"m2.scm\" (c-declare \"extern int power_of_2 ();\") (define pow2 (c-lambda (int) int \"power_of_2\")) (define (twice x) (cons x x)) ; File: \"m3.scm\" (write (map twice (map pow2 '(1 2 3 4)))) (newline) The compilation of the two Scheme source files can be done with three invocations of gsc : $ gsc -c m2.scm # create m2.c (note: .scm is optional) $ gsc -c m3.scm # create m3.c (note: .scm is optional) $ gsc -link m2.c m3.c # create the incremental link file m3_.c Alternatively, the three invocations of gsc can be replaced by a single invocation: $ gsc -link m2 m3 m2: m3: At this point there will be 4 C files: m1.c , m2.c , m3.c , and m3_.c . To produce an executable program these files must be compiled with a C compiler and linked with the Gambit runtime library. The C compiler options needed will depend on the C compiler and the operating system (in particular it may be necessary to add the options -I/usr/local/Gambit/include -L/usr/local/Gambit/lib to access the gambit.h header file and the Gambit runtime library). Here is an example under macOS: $ uname -srmp Darwin 20.6.0 x86_64 i386 $ gsc -obj m1.c m2.c m3.c m3_.c m1.c: m2.c: m3.c: m3_.c: $ gcc m1.o m2.o m3.o m3_.o -lgambit $ ./a.out ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Here is an example under Linux: $ uname -srmp Linux 5.10.0-9-amd64 x86_64 unknown $ gsc -obj m1.c m2.c m3.c m3_.c m1.c: m2.c: m3.c: m3_.c: $ gcc m1.o m2.o m3.o m3_.o -lgambit -lm -ldl -lutil $ ./a.out ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Building a loadable library To bundle multiple modules into a single object file that can be dynamically loaded with the load procedure, a flat link file is needed. The compiler\u2019s -o option must be used to name the C file generated as follows. If the dynamically loadable object file is to be named myfile.on then the -o option must set the name of the link file generated to myfile.on.c (note that the .c extension could also be .cc , .cpp or whatever extension is appropriate for C/C++ source files). The three modules of the previous example can be bundled by generating a link file in this way: $ gsc -link -flat -o foo.o1.c m2 m3 m2: m3: *** WARNING -- \"cons\" is not defined, *** referenced in: (\"m2.c\") *** WARNING -- \"map\" is not defined, *** referenced in: (\"m3.c\") *** WARNING -- \"newline\" is not defined, *** referenced in: (\"m3.c\") *** WARNING -- \"write\" is not defined, *** referenced in: (\"m3.c\") The warnings indicate that there are no definitions ( define s or set! s) of the variables cons , map , newline and write in the set of modules being linked. Before foo.o1 is loaded, these variables will have to be bound; either implicitly (by the runtime library) or explicitly. When compiling the C files and link file generated, the flag -D___DYNAMIC must be passed to the C compiler and the C compiler and linker must be told to generate a dynamically loadable shared library. Here is an example under macOS: $ uname -srmp Darwin 20.6.0 x86_64 i386 $ gsc -link -flat -o foo.o1.c m2 m3 > /dev/null m2: m3: $ gsc -cc-options \"-D___DYNAMIC\" -obj m1.c m2.c m3.c foo.o1.c m1.c: m2.c: m3.c: foo.o1.c: $ gcc -bundle m1.o m2.o m3.o foo.o1.o -o foo.o1 $ gsi foo.o1 ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Here is an example under Linux: $ uname -srmp Linux 5.10.0-9-amd64 x86_64 unknown $ gsc -link -flat -o foo.o1.c m2 m3 > /dev/null m2: m3: $ gsc -cc-options \"-D___DYNAMIC\" -obj m1.c m2.c m3.c foo.o1.c m1.c: m2.c: m3.c: foo.o1.c: $ gcc -shared m1.o m2.o m3.o foo.o1.o -o foo.o1 $ gsi foo.o1 ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Here is a more complex example, under Solaris, which shows how to build a loadable library mymod.o1 composed of the files m4.scm , m5.scm and x.c that links to system shared libraries (for X-windows): $ uname -srmp SunOS ungava 5.6 Generic_105181-05 sun4m sparc SUNW,SPARCstation-20 $ gsc -link -flat -o mymod.o1.c m4 m5 m4: m5: *** WARNING -- \"*\" is not defined, *** referenced in: (\"m4.c\") *** WARNING -- \"+\" is not defined, *** referenced in: (\"m5.c\") *** WARNING -- \"display\" is not defined, *** referenced in: (\"m5.c\" \"m4.c\") *** WARNING -- \"newline\" is not defined, *** referenced in: (\"m5.c\" \"m4.c\") *** WARNING -- \"write\" is not defined, *** referenced in: (\"m5.c\") $ gsc -cc-options \"-D___DYNAMIC\" -obj m4.c m5.c x.c mymod.o1.c m4.c: m5.c: x.c: mymod.o1.c: $ /usr/ccs/bin/ld -G -o mymod.o1 mymod.o1.o m4.o m5.o x.o -lX11 -lsocket $ gsi mymod.o1 hello from m4 hello from m5 (f1 10) = 22 $ cat m4.scm (define (f1 x) (* 2 (f2 x))) (display \"hello from m4\") (newline) (c-declare #<<c-declare-end #include \"x.h\" c-declare-end ) (define x-initialize (c-lambda (char-string) bool \"x_initialize\")) (define x-display-name (c-lambda () char-string \"x_display_name\")) (define x-bell (c-lambda (int) void \"x_bell\")) $ cat m5.scm (define (f2 x) (+ x 1)) (display \"hello from m5\") (newline) (display \"(f1 10) = \") (write (f1 10)) (newline) (x-initialize (x-display-name)) (x-bell 50) ; sound the bell at 50% $ cat x.c #include <X11/Xlib.h> static Display *display; int x_initialize (char *display_name) { display = XOpenDisplay (display_name); return display != NULL; } char *x_display_name (void) { return XDisplayName (NULL); } void x_bell (int volume) { XBell (display, volume); XFlush (display); } $ cat x.h int x_initialize (char *display_name); char *x_display_name (void); void x_bell (int); Building a shared library A shared-library can be built using an incremental link file or a flat link file. An incremental link file is normally used when the Gambit runtime library (or some other library) is to be extended with new procedures. A flat link file is mainly useful when building a \"primal\" runtime library, which is a library (such as the Gambit runtime library) that does not extend another library. When compiling the C files and link file generated, the flags -D___LIBRARY and -D___SHARED must be passed to the C compiler. The flag -D___PRIMAL must also be passed to the C compiler when a primal library is being built. A shared-library mylib.so containing the two first modules of the previous example can be built this way: $ uname -srmp Linux 5.10.0-9-amd64 x86_64 unknown $ gsc -link -o mylib.c m2 $ gsc -obj -cc-options \"-D___SHARED\" m1.c m2.c mylib.c m1.c: m2.c: mylib.c: $ gcc -shared m1.o m2.o mylib.o -o mylib.so Note that this shared-library is built using an incremental link file (it extends the Gambit runtime library with the procedures pow2 and twice ). This shared-library can in turn be used to build an executable program from the third module of the previous example: $ gsc -link -l mylib m3 $ gsc -obj m3.c m3_.c m3.c: m3_.c: $ gcc m3.o m3_.o mylib.so -lgambit $ LD_LIBRARY_PATH=.:/usr/local/lib ./a.out ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Other compilation options The performance of the code can be increased by passing the -D___SINGLE_HOST flag to the C compiler. This will merge all the procedures of a module into a single C procedure, which reduces the cost of intra-module procedure calls. In addition the -O2 option can be passed to the C compiler. For large modules, it will not be practical to specify both -O2 and -D___SINGLE_HOST for typical C compilers because the compile time will be high and the C compiler might even fail to compile the program for lack of memory. It has been observed that lower levels of optimization (e.g. -O1 ) often give faster compilation and also generate faster code. It is a good idea to experiment. Normally C compilers will not automatically search /usr/local/Gambit/include for header files so the flag -I/usr/local/Gambit/include should be passed to the C compiler. Similarly, C compilers/linkers will not automatically search /usr/local/Gambit/lib for libraries so the flag -L/usr/local/Gambit/lib should be passed to the C compiler/linker. Alternatives are given in Accessing the system files . A variety of flags are needed by some C compilers when compiling a shared-library or a dynamically loadable library. Some of these flags are: -shared , -call_shared , -rdynamic , -fpic , -fPIC , -Kpic , -KPIC , -pic , +z , -G . Check your compiler's documentation to see which flag you need.","title":"Link files"},{"location":"manual/gsc/link_files/#link-files","text":"Gambit can be used to create programs and libraries of Scheme modules. This section explains the steps required to do so and the role played by the link files. In general, a program is composed of a set of Scheme modules and modules in the target language. Some of the modules are part of the Gambit runtime library and the other modules are supplied by the user. When the program is started it must setup various global tables (including the symbol table and the global variable table) and then sequentially execute the Scheme modules (more or less as though they were being loaded one after another). The information required for this is contained in one or more link files generated by the Gambit linker from the target files produced by the Gambit compiler. The order of execution of the Scheme modules corresponds to the order of the modules on the command line which produced the link file. The order is usually important because most modules define variables and procedures which are used by other modules (for this reason the program's main computation is normally started by the last module). When a single link file is used to contain the linking information of all the Scheme modules it is called a flat link file. Thus a program built with a flat link file contains in its link file both information on the user modules and on the runtime library. This is fine if the program is to be statically linked but is wasteful in a shared-library context because the linking information of the runtime library can\u2019t be shared and will be duplicated in all programs (this linking information typically takes hundreds of kilobytes). Flat link files are mainly useful to bundle multiple Scheme modules to make a runtime library (such as the Gambit runtime library) or to make a single file that can be loaded with the load procedure. An incremental link file contains only the linking information that is not already contained in a second link file (the \"base\" link file). Assuming that a flat link file was produced when the runtime library was linked, a program can be built by linking the user modules with the runtime library's link file, producing an incremental link file. This allows the creation of a shared-library which contains the modules of the runtime library and its flat link file. The program is dynamically linked with this shared-library and only contains the user modules and the incremental link file. For small programs this approach greatly reduces the size of the program because the incremental link file is small. A \"hello world\" program built this way can be as small as 5 Kbytes. Note that it is perfectly fine to use an incremental link file for statically linked programs (there is very little loss compared to a single flat link file). Incremental link files may be built from other incremental link files. This allows the creation of shared-libraries which extend the functionality of the Gambit runtime library.","title":"Link files"},{"location":"manual/gsc/link_files/#building-an-executable-program","text":"The simplest way to create an executable program is to invoke gsc with the -exe option. The compiler will transparently perform all the steps necessary, including compiling Scheme source files to target files, generating the link file, and (when the C target is selected) compiling the C files generated to object files and creating the final executable file using the C linker. The following example shows how to use the C target to build the executable program hello.exe which contains the two Scheme modules h.scm and w.six . $ cat h.scm (display \"hello\") (newline) $ cat w.six display(\"world\"); newline(); $ gsc -o hello.exe -exe h.scm w.six h.scm: /Users/feeley/gambit/doc/h.c: w.six: /Users/feeley/gambit/doc/w.c: /Users/feeley/gambit/doc/w_.c: $ ./hello.exe hello world The detailed steps which are performed can be viewed by setting the GAMBUILD_VERBOSE environment variable to a nonnull value. Alternatively, gsc \u2019s -verbose option can be used (it implicitly sets the GAMBUILD_VERBOSE environment variable). For example: $ export GAMBUILD_VERBOSE=yes $ gsc -o hello.exe -exe h.scm w.six h.scm: /Users/feeley/gambit/doc/h.c: gcc -O1 -Wno-unused -Wno-write-strings -Wdisabled-optimization fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -c -o 'h.o' 'h.c' w.six: /Users/feeley/gambit/doc/w.c: gcc -O1 -Wno-unused -Wno-write-strings -Wdisabled-optimization -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -c -o 'w.o' 'w.c' /Users/feeley/gambit/doc/w_.c: gcc -O1 -Wno-unused -Wno-write-strings -Wdisabled-optimization -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -c -o 'w_.o' 'w_.c' gcc -Wno-unused -Wno-write-strings -Wdisabled-optimization -fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno -fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC -fno-common -mpc64 -D___SINGLE_HOST -I\"/usr/local/Gambit/include\" -o 'hello.exe' 'w_.o' 'h.o' 'w.o' \"/usr/local/Gambit/lib/libgambit.a\" Here is the same example using the js target showing the creation of a shell script invoking nodejs : $ export GAMBUILD_VERBOSE=yes $ gsc -target js -o hello.exe -exe h.scm w.six h.scm: /Users/feeley/gambit/doc/h.js: cat h.js > \"h.o\" w.six: /Users/feeley/gambit/doc/w.js: cat w.js > \"w.o\" /Users/feeley/gambit/doc/w_.js: cat w_.js > \"w_.o\" echo \"#! /usr/bin/env node\" > \"hello.exe\" cat w_.o h.o w.o \"/usr/local/Gambit/lib/_gambit.js\" >> \"hello.exe\" chmod +x \"hello.exe\" Using a single invocation of gsc with the -exe option is sometimes inappropriate when the build process is more complex, for example when the program is composed of several separately compiled modules. In such a case it is useful to decompose the build process into smaller compilation steps. The hello.exe executable program could have been built with the C target by separating the generation of C files from the C compilation and linking: $ gsc -c h.scm $ gsc -c w.six $ gsc -o hello.exe -exe h.c w.c When even finer control is desired the C target's build process can be decomposed into smaller steps that invoke the C compiler and linker explicitly. This is described in the rest of this section. The gsc compiler can be invoked to compile each Scheme module into a C file and to create an incremental link file. The C files and the link file must then be compiled with a C compiler and linked (at the object file level) with the Gambit runtime library and possibly other libraries (such as the math library and the dynamic loading library). Here is for example how a program with three modules (one in C and two in Scheme) can be built. The content of the three source files ( m1.c , m2.scm and m3.scm ) is: /* File: \"m1.c\" */ int power_of_2 (int x) { return 1<<x; } ; File: \"m2.scm\" (c-declare \"extern int power_of_2 ();\") (define pow2 (c-lambda (int) int \"power_of_2\")) (define (twice x) (cons x x)) ; File: \"m3.scm\" (write (map twice (map pow2 '(1 2 3 4)))) (newline) The compilation of the two Scheme source files can be done with three invocations of gsc : $ gsc -c m2.scm # create m2.c (note: .scm is optional) $ gsc -c m3.scm # create m3.c (note: .scm is optional) $ gsc -link m2.c m3.c # create the incremental link file m3_.c Alternatively, the three invocations of gsc can be replaced by a single invocation: $ gsc -link m2 m3 m2: m3: At this point there will be 4 C files: m1.c , m2.c , m3.c , and m3_.c . To produce an executable program these files must be compiled with a C compiler and linked with the Gambit runtime library. The C compiler options needed will depend on the C compiler and the operating system (in particular it may be necessary to add the options -I/usr/local/Gambit/include -L/usr/local/Gambit/lib to access the gambit.h header file and the Gambit runtime library). Here is an example under macOS: $ uname -srmp Darwin 20.6.0 x86_64 i386 $ gsc -obj m1.c m2.c m3.c m3_.c m1.c: m2.c: m3.c: m3_.c: $ gcc m1.o m2.o m3.o m3_.o -lgambit $ ./a.out ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Here is an example under Linux: $ uname -srmp Linux 5.10.0-9-amd64 x86_64 unknown $ gsc -obj m1.c m2.c m3.c m3_.c m1.c: m2.c: m3.c: m3_.c: $ gcc m1.o m2.o m3.o m3_.o -lgambit -lm -ldl -lutil $ ./a.out ((2 . 2) (4 . 4) (8 . 8) (16 . 16))","title":"Building an executable program"},{"location":"manual/gsc/link_files/#building-a-loadable-library","text":"To bundle multiple modules into a single object file that can be dynamically loaded with the load procedure, a flat link file is needed. The compiler\u2019s -o option must be used to name the C file generated as follows. If the dynamically loadable object file is to be named myfile.on then the -o option must set the name of the link file generated to myfile.on.c (note that the .c extension could also be .cc , .cpp or whatever extension is appropriate for C/C++ source files). The three modules of the previous example can be bundled by generating a link file in this way: $ gsc -link -flat -o foo.o1.c m2 m3 m2: m3: *** WARNING -- \"cons\" is not defined, *** referenced in: (\"m2.c\") *** WARNING -- \"map\" is not defined, *** referenced in: (\"m3.c\") *** WARNING -- \"newline\" is not defined, *** referenced in: (\"m3.c\") *** WARNING -- \"write\" is not defined, *** referenced in: (\"m3.c\") The warnings indicate that there are no definitions ( define s or set! s) of the variables cons , map , newline and write in the set of modules being linked. Before foo.o1 is loaded, these variables will have to be bound; either implicitly (by the runtime library) or explicitly. When compiling the C files and link file generated, the flag -D___DYNAMIC must be passed to the C compiler and the C compiler and linker must be told to generate a dynamically loadable shared library. Here is an example under macOS: $ uname -srmp Darwin 20.6.0 x86_64 i386 $ gsc -link -flat -o foo.o1.c m2 m3 > /dev/null m2: m3: $ gsc -cc-options \"-D___DYNAMIC\" -obj m1.c m2.c m3.c foo.o1.c m1.c: m2.c: m3.c: foo.o1.c: $ gcc -bundle m1.o m2.o m3.o foo.o1.o -o foo.o1 $ gsi foo.o1 ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Here is an example under Linux: $ uname -srmp Linux 5.10.0-9-amd64 x86_64 unknown $ gsc -link -flat -o foo.o1.c m2 m3 > /dev/null m2: m3: $ gsc -cc-options \"-D___DYNAMIC\" -obj m1.c m2.c m3.c foo.o1.c m1.c: m2.c: m3.c: foo.o1.c: $ gcc -shared m1.o m2.o m3.o foo.o1.o -o foo.o1 $ gsi foo.o1 ((2 . 2) (4 . 4) (8 . 8) (16 . 16)) Here is a more complex example, under Solaris, which shows how to build a loadable library mymod.o1 composed of the files m4.scm , m5.scm and x.c that links to system shared libraries (for X-windows): $ uname -srmp SunOS ungava 5.6 Generic_105181-05 sun4m sparc SUNW,SPARCstation-20 $ gsc -link -flat -o mymod.o1.c m4 m5 m4: m5: *** WARNING -- \"*\" is not defined, *** referenced in: (\"m4.c\") *** WARNING -- \"+\" is not defined, *** referenced in: (\"m5.c\") *** WARNING -- \"display\" is not defined, *** referenced in: (\"m5.c\" \"m4.c\") *** WARNING -- \"newline\" is not defined, *** referenced in: (\"m5.c\" \"m4.c\") *** WARNING -- \"write\" is not defined, *** referenced in: (\"m5.c\") $ gsc -cc-options \"-D___DYNAMIC\" -obj m4.c m5.c x.c mymod.o1.c m4.c: m5.c: x.c: mymod.o1.c: $ /usr/ccs/bin/ld -G -o mymod.o1 mymod.o1.o m4.o m5.o x.o -lX11 -lsocket $ gsi mymod.o1 hello from m4 hello from m5 (f1 10) = 22 $ cat m4.scm (define (f1 x) (* 2 (f2 x))) (display \"hello from m4\") (newline) (c-declare #<<c-declare-end #include \"x.h\" c-declare-end ) (define x-initialize (c-lambda (char-string) bool \"x_initialize\")) (define x-display-name (c-lambda () char-string \"x_display_name\")) (define x-bell (c-lambda (int) void \"x_bell\")) $ cat m5.scm (define (f2 x) (+ x 1)) (display \"hello from m5\") (newline) (display \"(f1 10) = \") (write (f1 10)) (newline) (x-initialize (x-display-name)) (x-bell 50) ; sound the bell at 50% $ cat x.c #include <X11/Xlib.h> static Display *display; int x_initialize (char *display_name) { display = XOpenDisplay (display_name); return display != NULL; } char *x_display_name (void) { return XDisplayName (NULL); } void x_bell (int volume) { XBell (display, volume); XFlush (display); } $ cat x.h int x_initialize (char *display_name); char *x_display_name (void); void x_bell (int);","title":"Building a loadable library"},{"location":"manual/gsc/link_files/#building-a-shared-library","text":"A shared-library can be built using an incremental link file or a flat link file. An incremental link file is normally used when the Gambit runtime library (or some other library) is to be extended with new procedures. A flat link file is mainly useful when building a \"primal\" runtime library, which is a library (such as the Gambit runtime library) that does not extend another library. When compiling the C files and link file generated, the flags -D___LIBRARY and -D___SHARED must be passed to the C compiler. The flag -D___PRIMAL must also be passed to the C compiler when a primal library is being built. A shared-library mylib.so containing the two first modules of the previous example can be built this way: $ uname -srmp Linux 5.10.0-9-amd64 x86_64 unknown $ gsc -link -o mylib.c m2 $ gsc -obj -cc-options \"-D___SHARED\" m1.c m2.c mylib.c m1.c: m2.c: mylib.c: $ gcc -shared m1.o m2.o mylib.o -o mylib.so Note that this shared-library is built using an incremental link file (it extends the Gambit runtime library with the procedures pow2 and twice ). This shared-library can in turn be used to build an executable program from the third module of the previous example: $ gsc -link -l mylib m3 $ gsc -obj m3.c m3_.c m3.c: m3_.c: $ gcc m3.o m3_.o mylib.so -lgambit $ LD_LIBRARY_PATH=.:/usr/local/lib ./a.out ((2 . 2) (4 . 4) (8 . 8) (16 . 16))","title":"Building a shared library"},{"location":"manual/gsc/link_files/#other-compilation-options","text":"The performance of the code can be increased by passing the -D___SINGLE_HOST flag to the C compiler. This will merge all the procedures of a module into a single C procedure, which reduces the cost of intra-module procedure calls. In addition the -O2 option can be passed to the C compiler. For large modules, it will not be practical to specify both -O2 and -D___SINGLE_HOST for typical C compilers because the compile time will be high and the C compiler might even fail to compile the program for lack of memory. It has been observed that lower levels of optimization (e.g. -O1 ) often give faster compilation and also generate faster code. It is a good idea to experiment. Normally C compilers will not automatically search /usr/local/Gambit/include for header files so the flag -I/usr/local/Gambit/include should be passed to the C compiler. Similarly, C compilers/linkers will not automatically search /usr/local/Gambit/lib for libraries so the flag -L/usr/local/Gambit/lib should be passed to the C compiler/linker. Alternatives are given in Accessing the system files . A variety of flags are needed by some C compilers when compiling a shared-library or a dynamically loadable library. Some of these flags are: -shared , -call_shared , -rdynamic , -fpic , -fPIC , -Kpic , -KPIC , -pic , +z , -G . Check your compiler's documentation to see which flag you need.","title":"Other compilation options"},{"location":"manual/gsc/procedures/","text":"Procedures specific to the compiler The Gambit Scheme compiler features the following procedures that are not available in the Gambit Scheme interpreter. compile-file-to-target (compile-file-to-target file [options: options] [output: output] [expression: expression]) ;; procedure The file parameter must be a string. If expression is not specified, file must name an existing file containing Scheme source code. The extension can be omitted from file when the Scheme file has a .scm , .sld or .six extension. By default, this procedure compiles the source file into a file containing C code. A different target language can be selected in the options . The generated file is named after file with the extension replaced with .c or .js , as appropriate for the target selected. The name of the generated file can also be specified directly with the output parameter. If output is a string naming a directory then the generated file is created in that directory. Otherwise the name of the generated file is output . Compilation options are specified through the options parameter which must be an association list. Any combination of the following options can be used: target , verbose , report , expansion , gvm , debug , module-ref , and linker-name . When expression is specified, the file parameter is not open or read. Instead, expression is used as though it was the content of the file. This makes it possible to compile source code without having to create a file to contain the code. Note that file is used in error messages and to determine the output file name if output is not specified. When the compilation is successful, compile-file-to-target returns the name of the file generated. When there is a compilation error, #f is returned. $ cat h.scm (display \"hello\") (newline) $ gsc Gambit v4.9.4 > (compile-file-to-target \"h\") \"/Users/feeley/gambit/doc/h.c\" compile-file (compile-file file [options: options] [output: output] [base: base] [expression: expression] [cc-options: cc-options] [ld-options-prelude: ld-options-prelude] [ld-options: ld-options]) ;; procedure The file , options , output , and expression parameters have the same meaning as for the compile-file-to-target procedure, except that file may be a Scheme source file or a file possibly generated by the Gambit Scheme compiler (for example with the compile-file-to-target procedure). The cc-options parameter is a string containing the options to pass to the C compiler and the ld-options-prelude and ld-options parameters are strings containing the options to pass to the C linker (the options in ld-options-prelude are passed to the C linker before the input file and the options in ld-options are passed after). The compile-file procedure compiles the source file file into an object file, which is either a file dynamically loadable using the load procedure, or a C linkable object file destined to be linked with the C linker (for example to create a standalone executable program). The presence of the obj option in options will cause the creation of a C linkable object file and therefore the options ld-options-prelude and ld-options are ignored, otherwise a dynamically loadable file is created. In both cases, if file is a Scheme source file, the compiler first compiles file to a C file which is created in the same directory as file regardless of the output parameter. Then the C file is compiled with the C compiler. When the compilation is successful, compile-file returns the name of the object file generated. When there is a compilation error, #f is returned. The name of the object file can be specified with the output parameter. If output is a string naming a directory then the object file is created in that directory. Otherwise the name of the object file is output . In the case of a dynamically loadable object file, by default the object file is named after file with the extension replaced with .on , where n is a positive integer that acts as a version number. The next available version number is generated automatically by compile-file . When dynamically loaded object files are loaded using the load procedure, the .on extension can be specified (to select a particular version) or omitted (to load the file with a .on extension with the highest n consecutively from 1 ). When the .on extension is not specified and older versions are no longer needed, all versions must be deleted and the compilation must be repeated (this is necessary because the file name, including the extension, is used to name some of the exported symbols of the object file). Note that dynamically loadable object files can only be generated on host operating systems that support dynamic loading. $ cat h.scm (display \"hello\") (newline) $ gsc Gambit v4.9.4 > (compile-file \"h\") \"/Users/feeley/gambit/doc/h.o1\" > (load \"h\") hello \"/Users/feeley/gambit/doc/h.o1\" > (compile-file-to-target \"h\" output: \"h.o99.c\") \"/Users/feeley/gambit/doc/h.o99.c\" > (compile-file \"h.o99.c\") \"/Users/feeley/gambit/doc/h.o99\" > (load \"h.o99\") hello \"/Users/feeley/gambit/doc/h.o99\" > (compile-file-to-target \"h\") \"/Users/feeley/gambit/doc/h.c\" > (compile-file \"h.c\" options: '(obj)) \"/Users/feeley/gambit/doc/h.o\" link-incremental (link-incremental module-list [output: output] [linker-name: linker-name] [base: base] [warnings?: warnings?]) ;; procedure The first parameter must be a non empty list of strings naming Scheme modules to link (the file extension may be omitted). An incremental link file is generated for the modules specified in module-list . By default the link file generated is named last_.ext , where last is the name of the last module, without the file extension, and ext is the appropriate extension for the target. The name of the generated link file can be specified with the output parameter. If output is a string naming a directory then the link file is created in that directory. Otherwise the name of the link file is output . The base link file is specified by the base parameter, which must be a string. By default the base link file is the Gambit runtime library link file ~~lib/_gambit (with extension appropriate for the target). However, when base is supplied it is the name of the base link file (the file extension may be omitted). The warnings? parameter controls whether warnings are generated for undefined references. The following example shows how to build the executable program hello which contains the two Scheme modules h.scm and w.six . $ uname -srmp Darwin 8.1.0 Power Macintosh powerpc $ cat h.scm (display \"hello\") (newline) $ cat w.six display(\"world\"); newline(); $ gsc Gambit v4.9.4 > (compile-file-to-target \"h\") \"/Users/feeley/gambit/doc/h.c\" > (compile-file-to-target \"w\") \"/Users/feeley/gambit/doc/w.c\" > (link-incremental '(\"h\" \"w\") output: \"hello.c\") \"/Users/feeley/gambit/doc/hello_.c\" > ,q $ gsc -obj h.c w.c hello.c h.c: w.c: hello.c: $ gcc h.o w.o hello.o -lgambit -o hello $ ./hello hello world link-flat (link-flat module-list [output: output] [linker-name: linker-name] [warnings?: warnings?]) ;; procedure The first parameter must be a non empty list of strings naming Scheme modules to link (the file extension may be omitted). The first string must be the name of a Scheme module or the name of a link file and the remaining strings must name Scheme modules. A flat link file is generated for the modules specified in module-list . By default the link file generated is named last_.ext , where last is the name of the last module, without the file extension, and ext is the appropriate extension for the target. The name of the generated link file can be specified with the output parameter. If output is a string naming a directory then the link file is created in that directory. Otherwise the name of the link file is output . If a dynamically loadable object file is produced from the link file output , then the name of the dynamically loadable object file must be output stripped of its file extension. The warnings? parameter controls whether warnings are generated for undefined references. The following example shows how to build the dynamically loadable object file lib.o1 which contains the two Scheme modules m6.scm and m7.scm . $ uname -srmp Darwin 8.1.0 Power Macintosh powerpc $ cat m6.scm (define (f x) (g (* x x))) $ cat m7.scm (define (g y) (+ n y)) $ gsc Gambit v4.9.4 > (compile-file-to-target \"m6\") \"/Users/feeley/gambit/doc/m6.c\" > (compile-file-to-target \"m7\") \"/Users/feeley/gambit/doc/m7.c\" > (link-flat '(\"m6\" \"m7\") output: \"lib.o1.c\") *** WARNING -- \"*\" is not defined, *** referenced in: (\"m6.c\") *** WARNING -- \"+\" is not defined, *** referenced in: (\"m7.c\") *** WARNING -- \"n\" is not defined, *** referenced in: (\"m7.c\") \"/Users/feeley/gambit/doc/lib.o1.c\" > ,q $ gcc -bundle -D___DYNAMIC m6.c m7.c lib.o1.c -o lib.o1 $ gsc Gambit v4.9.4 > (load \"lib\") *** WARNING -- Variable \"n\" used in module \"m7\" is undefined \"/Users/feeley/gambit/doc/lib.o1\" > (define n 10) > (f 5) 35 > ,q The warnings indicate that there are no definitions ( defines or set! s) of the variables * , + and n in the modules contained in the library. Before the library is used, these variables will have to be bound; either implicitly (by the runtime library) or explicitly.","title":"Procedures specific to the compiler"},{"location":"manual/gsc/procedures/#procedures-specific-to-the-compiler","text":"The Gambit Scheme compiler features the following procedures that are not available in the Gambit Scheme interpreter.","title":"Procedures specific to the compiler"},{"location":"manual/gsc/procedures/#compile-file-to-target","text":"(compile-file-to-target file [options: options] [output: output] [expression: expression]) ;; procedure The file parameter must be a string. If expression is not specified, file must name an existing file containing Scheme source code. The extension can be omitted from file when the Scheme file has a .scm , .sld or .six extension. By default, this procedure compiles the source file into a file containing C code. A different target language can be selected in the options . The generated file is named after file with the extension replaced with .c or .js , as appropriate for the target selected. The name of the generated file can also be specified directly with the output parameter. If output is a string naming a directory then the generated file is created in that directory. Otherwise the name of the generated file is output . Compilation options are specified through the options parameter which must be an association list. Any combination of the following options can be used: target , verbose , report , expansion , gvm , debug , module-ref , and linker-name . When expression is specified, the file parameter is not open or read. Instead, expression is used as though it was the content of the file. This makes it possible to compile source code without having to create a file to contain the code. Note that file is used in error messages and to determine the output file name if output is not specified. When the compilation is successful, compile-file-to-target returns the name of the file generated. When there is a compilation error, #f is returned. $ cat h.scm (display \"hello\") (newline) $ gsc Gambit v4.9.4 > (compile-file-to-target \"h\") \"/Users/feeley/gambit/doc/h.c\"","title":"compile-file-to-target"},{"location":"manual/gsc/procedures/#compile-file","text":"(compile-file file [options: options] [output: output] [base: base] [expression: expression] [cc-options: cc-options] [ld-options-prelude: ld-options-prelude] [ld-options: ld-options]) ;; procedure The file , options , output , and expression parameters have the same meaning as for the compile-file-to-target procedure, except that file may be a Scheme source file or a file possibly generated by the Gambit Scheme compiler (for example with the compile-file-to-target procedure). The cc-options parameter is a string containing the options to pass to the C compiler and the ld-options-prelude and ld-options parameters are strings containing the options to pass to the C linker (the options in ld-options-prelude are passed to the C linker before the input file and the options in ld-options are passed after). The compile-file procedure compiles the source file file into an object file, which is either a file dynamically loadable using the load procedure, or a C linkable object file destined to be linked with the C linker (for example to create a standalone executable program). The presence of the obj option in options will cause the creation of a C linkable object file and therefore the options ld-options-prelude and ld-options are ignored, otherwise a dynamically loadable file is created. In both cases, if file is a Scheme source file, the compiler first compiles file to a C file which is created in the same directory as file regardless of the output parameter. Then the C file is compiled with the C compiler. When the compilation is successful, compile-file returns the name of the object file generated. When there is a compilation error, #f is returned. The name of the object file can be specified with the output parameter. If output is a string naming a directory then the object file is created in that directory. Otherwise the name of the object file is output . In the case of a dynamically loadable object file, by default the object file is named after file with the extension replaced with .on , where n is a positive integer that acts as a version number. The next available version number is generated automatically by compile-file . When dynamically loaded object files are loaded using the load procedure, the .on extension can be specified (to select a particular version) or omitted (to load the file with a .on extension with the highest n consecutively from 1 ). When the .on extension is not specified and older versions are no longer needed, all versions must be deleted and the compilation must be repeated (this is necessary because the file name, including the extension, is used to name some of the exported symbols of the object file). Note that dynamically loadable object files can only be generated on host operating systems that support dynamic loading. $ cat h.scm (display \"hello\") (newline) $ gsc Gambit v4.9.4 > (compile-file \"h\") \"/Users/feeley/gambit/doc/h.o1\" > (load \"h\") hello \"/Users/feeley/gambit/doc/h.o1\" > (compile-file-to-target \"h\" output: \"h.o99.c\") \"/Users/feeley/gambit/doc/h.o99.c\" > (compile-file \"h.o99.c\") \"/Users/feeley/gambit/doc/h.o99\" > (load \"h.o99\") hello \"/Users/feeley/gambit/doc/h.o99\" > (compile-file-to-target \"h\") \"/Users/feeley/gambit/doc/h.c\" > (compile-file \"h.c\" options: '(obj)) \"/Users/feeley/gambit/doc/h.o\"","title":"compile-file"},{"location":"manual/gsc/procedures/#link-incremental","text":"(link-incremental module-list [output: output] [linker-name: linker-name] [base: base] [warnings?: warnings?]) ;; procedure The first parameter must be a non empty list of strings naming Scheme modules to link (the file extension may be omitted). An incremental link file is generated for the modules specified in module-list . By default the link file generated is named last_.ext , where last is the name of the last module, without the file extension, and ext is the appropriate extension for the target. The name of the generated link file can be specified with the output parameter. If output is a string naming a directory then the link file is created in that directory. Otherwise the name of the link file is output . The base link file is specified by the base parameter, which must be a string. By default the base link file is the Gambit runtime library link file ~~lib/_gambit (with extension appropriate for the target). However, when base is supplied it is the name of the base link file (the file extension may be omitted). The warnings? parameter controls whether warnings are generated for undefined references. The following example shows how to build the executable program hello which contains the two Scheme modules h.scm and w.six . $ uname -srmp Darwin 8.1.0 Power Macintosh powerpc $ cat h.scm (display \"hello\") (newline) $ cat w.six display(\"world\"); newline(); $ gsc Gambit v4.9.4 > (compile-file-to-target \"h\") \"/Users/feeley/gambit/doc/h.c\" > (compile-file-to-target \"w\") \"/Users/feeley/gambit/doc/w.c\" > (link-incremental '(\"h\" \"w\") output: \"hello.c\") \"/Users/feeley/gambit/doc/hello_.c\" > ,q $ gsc -obj h.c w.c hello.c h.c: w.c: hello.c: $ gcc h.o w.o hello.o -lgambit -o hello $ ./hello hello world","title":"link-incremental"},{"location":"manual/gsc/procedures/#link-flat","text":"(link-flat module-list [output: output] [linker-name: linker-name] [warnings?: warnings?]) ;; procedure The first parameter must be a non empty list of strings naming Scheme modules to link (the file extension may be omitted). The first string must be the name of a Scheme module or the name of a link file and the remaining strings must name Scheme modules. A flat link file is generated for the modules specified in module-list . By default the link file generated is named last_.ext , where last is the name of the last module, without the file extension, and ext is the appropriate extension for the target. The name of the generated link file can be specified with the output parameter. If output is a string naming a directory then the link file is created in that directory. Otherwise the name of the link file is output . If a dynamically loadable object file is produced from the link file output , then the name of the dynamically loadable object file must be output stripped of its file extension. The warnings? parameter controls whether warnings are generated for undefined references. The following example shows how to build the dynamically loadable object file lib.o1 which contains the two Scheme modules m6.scm and m7.scm . $ uname -srmp Darwin 8.1.0 Power Macintosh powerpc $ cat m6.scm (define (f x) (g (* x x))) $ cat m7.scm (define (g y) (+ n y)) $ gsc Gambit v4.9.4 > (compile-file-to-target \"m6\") \"/Users/feeley/gambit/doc/m6.c\" > (compile-file-to-target \"m7\") \"/Users/feeley/gambit/doc/m7.c\" > (link-flat '(\"m6\" \"m7\") output: \"lib.o1.c\") *** WARNING -- \"*\" is not defined, *** referenced in: (\"m6.c\") *** WARNING -- \"+\" is not defined, *** referenced in: (\"m7.c\") *** WARNING -- \"n\" is not defined, *** referenced in: (\"m7.c\") \"/Users/feeley/gambit/doc/lib.o1.c\" > ,q $ gcc -bundle -D___DYNAMIC m6.c m7.c lib.o1.c -o lib.o1 $ gsc Gambit v4.9.4 > (load \"lib\") *** WARNING -- Variable \"n\" used in module \"m7\" is undefined \"/Users/feeley/gambit/doc/lib.o1\" > (define n 10) > (f 5) 35 > ,q The warnings indicate that there are no definitions ( defines or set! s) of the variables * , + and n in the modules contained in the library. Before the library is used, these variables will have to be bound; either implicitly (by the runtime library) or explicitly.","title":"link-flat"},{"location":"manual/gsi/","text":"The Gambit Scheme Interpreter gsi [-:runtimeoption,\u2026] [-i] [-f] [-h] [-help] [-v] [[-] [-e expressions] [-install] [-uninstall] [-update] [search-directory-or-module-or-file]]\u2026 The interpreter is executed in batch mode when the command line contains a module or file or a - , or -e option. The interpreter is executed in module management mode when the command line contains the -install , -uninstall , or -update option. Otherwise the interpreter is executed in interactive mode. The -i option is ignored by the interpreter. The initialization file will be examined unless the -f option is present (see section Customization ). The -h and -help options print brief usage information on standard output and exit. The -v option prints the system version string, system time stamp, operating system type, and configure script options on standard output and exits. Runtime options are explained in Runtime options.","title":"The Gambit Scheme Interpreter"},{"location":"manual/gsi/#the-gambit-scheme-interpreter","text":"gsi [-:runtimeoption,\u2026] [-i] [-f] [-h] [-help] [-v] [[-] [-e expressions] [-install] [-uninstall] [-update] [search-directory-or-module-or-file]]\u2026 The interpreter is executed in batch mode when the command line contains a module or file or a - , or -e option. The interpreter is executed in module management mode when the command line contains the -install , -uninstall , or -update option. Otherwise the interpreter is executed in interactive mode. The -i option is ignored by the interpreter. The initialization file will be examined unless the -f option is present (see section Customization ). The -h and -help options print brief usage information on standard output and exit. The -v option prints the system version string, system time stamp, operating system type, and configure script options on standard output and exits. Runtime options are explained in Runtime options.","title":"The Gambit Scheme Interpreter"},{"location":"manual/gsi/batch_mode/","text":"Batch mode In batch mode the command line arguments denote modules and files to execute, REPL interactions to start ( - option), and expressions to be evaluated ( -e option). Those options can be interspersed with the search directories, modules, and files on the command line and can occur multiple times. In addition to these options the command line may contain 3 types of non-options: search directories, modules, and files. Search directories : Search directories are locations in the file system that are searched to resolve references to modules. Any command line argument that ends with a path separator or a . is treated as a search directory. By default the module search order is initially ~~lib (which contains builtin modules) followed by ~~userlib (which contains user installed modules and is typically the directory .gambit_userlib in the user's home directory). Search directories on the command line are added to the front of the search order, and thus take precedence over the default module search order. Modules : Modules are either unversioned or versioned (managed by the git version-control system). There are two flavors of versioned modules: hosted modules have a git repository on a network accessible repository manager site such as github.com and gitlab.com , and local modules have a git repository on the local file system. Module names have a syntax similar to the paths used to identify files. They consist of one or more non-empty parts separated by / . The last part may end with a suffix of the form @version . Only the first part and version may contain . , otherwise only the characters a-z, A-Z, 0-9, - , and _ are permitted. If there are at least 3 parts and the first part contains at least one . and no _ , then it refers to a hosted module (1st part = host , 2nd part = account , 3rd part = repository name ). For example github.com/gambit/hello@1.0 is a hosted module reference. Otherwise it refers to a local versioned module or an unversioned module, for example foobar or A/B/C/D . Files : Files are simple code containers located on the local file system. They are also identified by a path. If a path is a valid module or file, it is interpreted as a module. Note that a path with a last component containing an extension, such as .scm , and no @ , is always interpreted as a file. The interpreter processes the command line arguments from left to right. Search directories are added to the head of the module search order. Files are executed using the load procedure. Modules are requested using the ##demand-module special form (this form is explained in Modules, but essentially it causes that module to be searched in the module search order and executed once). The -e option uses the eval procedure to evaluate expressions in the global interaction environment. After this processing the interpreter exits. The ports associated with (current-input-port) , (current-output-port) and (current-error-port) initially refer respectively to the standard input ( stdin ), standard output ( stdout ) and the standard error ( stderr ) of the interpreter. This is true even in REPLs started with the - option. The usual interaction channel is still used to read expressions and commands and to display results. This makes it possible to use REPLs to debug programs which read the standard input and write to the standard output, even when these have been redirected. Here is a sample use of the interpreter in batch mode, under UNIX: $ cat h.scm (display \"hello\") (newline) $ cat w.six display(\"world\"); newline(); $ gsi h.scm - w.six -e \"(pretty-print 1)(pretty-print 2)\" hello > (define (display x) (write (reverse (string->list x)))) > ,c (#\\d #\\l #\\r #\\o #\\w) 1 2 $ gsi . h w # add . to search order to load modules h and w hello world","title":"Batch mode"},{"location":"manual/gsi/batch_mode/#batch-mode","text":"In batch mode the command line arguments denote modules and files to execute, REPL interactions to start ( - option), and expressions to be evaluated ( -e option). Those options can be interspersed with the search directories, modules, and files on the command line and can occur multiple times. In addition to these options the command line may contain 3 types of non-options: search directories, modules, and files. Search directories : Search directories are locations in the file system that are searched to resolve references to modules. Any command line argument that ends with a path separator or a . is treated as a search directory. By default the module search order is initially ~~lib (which contains builtin modules) followed by ~~userlib (which contains user installed modules and is typically the directory .gambit_userlib in the user's home directory). Search directories on the command line are added to the front of the search order, and thus take precedence over the default module search order. Modules : Modules are either unversioned or versioned (managed by the git version-control system). There are two flavors of versioned modules: hosted modules have a git repository on a network accessible repository manager site such as github.com and gitlab.com , and local modules have a git repository on the local file system. Module names have a syntax similar to the paths used to identify files. They consist of one or more non-empty parts separated by / . The last part may end with a suffix of the form @version . Only the first part and version may contain . , otherwise only the characters a-z, A-Z, 0-9, - , and _ are permitted. If there are at least 3 parts and the first part contains at least one . and no _ , then it refers to a hosted module (1st part = host , 2nd part = account , 3rd part = repository name ). For example github.com/gambit/hello@1.0 is a hosted module reference. Otherwise it refers to a local versioned module or an unversioned module, for example foobar or A/B/C/D . Files : Files are simple code containers located on the local file system. They are also identified by a path. If a path is a valid module or file, it is interpreted as a module. Note that a path with a last component containing an extension, such as .scm , and no @ , is always interpreted as a file. The interpreter processes the command line arguments from left to right. Search directories are added to the head of the module search order. Files are executed using the load procedure. Modules are requested using the ##demand-module special form (this form is explained in Modules, but essentially it causes that module to be searched in the module search order and executed once). The -e option uses the eval procedure to evaluate expressions in the global interaction environment. After this processing the interpreter exits. The ports associated with (current-input-port) , (current-output-port) and (current-error-port) initially refer respectively to the standard input ( stdin ), standard output ( stdout ) and the standard error ( stderr ) of the interpreter. This is true even in REPLs started with the - option. The usual interaction channel is still used to read expressions and commands and to display results. This makes it possible to use REPLs to debug programs which read the standard input and write to the standard output, even when these have been redirected. Here is a sample use of the interpreter in batch mode, under UNIX: $ cat h.scm (display \"hello\") (newline) $ cat w.six display(\"world\"); newline(); $ gsi h.scm - w.six -e \"(pretty-print 1)(pretty-print 2)\" hello > (define (display x) (write (reverse (string->list x)))) > ,c (#\\d #\\l #\\r #\\o #\\w) 1 2 $ gsi . h w # add . to search order to load modules h and w hello world","title":"Batch mode"},{"location":"manual/gsi/customization/","text":"Customization There are two ways to customize the interpreter. When the interpreter starts off it tries to execute a (load \"~~lib/gambext\") (for an explanation of how file names are interpreted see Host environment). An error is not signaled when the file does not exist. Interpreter extensions and patches that are meant to apply to all users and all modes should go in that file. Extensions which are meant to apply to a single user or to a specific working directory are best placed in the initialization file, which is a file containing Scheme code. In all modes, the interpreter first tries to locate the initialization file by searching the following locations: \u2018.gambini\u2019 and ~/.gambini (with no extension, a .sld extension, a .scm extension, and a .six extension in that order). The first file that is found is examined as though the expression (include initialization-file) had been entered at the read-eval-print loop where initialization-file is the file that was found. Note that by using an include the macros defined in the initialization file will be visible from the read-eval-print loop (this would not have been the case if load had been used). The initialization file is not searched for or examined when the -f option is specified.","title":"Customization"},{"location":"manual/gsi/customization/#customization","text":"There are two ways to customize the interpreter. When the interpreter starts off it tries to execute a (load \"~~lib/gambext\") (for an explanation of how file names are interpreted see Host environment). An error is not signaled when the file does not exist. Interpreter extensions and patches that are meant to apply to all users and all modes should go in that file. Extensions which are meant to apply to a single user or to a specific working directory are best placed in the initialization file, which is a file containing Scheme code. In all modes, the interpreter first tries to locate the initialization file by searching the following locations: \u2018.gambini\u2019 and ~/.gambini (with no extension, a .sld extension, a .scm extension, and a .six extension in that order). The first file that is found is examined as though the expression (include initialization-file) had been entered at the read-eval-print loop where initialization-file is the file that was found. Note that by using an include the macros defined in the initialization file will be visible from the read-eval-print loop (this would not have been the case if load had been used). The initialization file is not searched for or examined when the -f option is specified.","title":"Customization"},{"location":"manual/gsi/interactive_mode/","text":"Interactive mode In interactive mode a read-eval-print loop (REPL) is started for the user to interact with the interpreter. At each iteration of this loop the interpreter displays a prompt, reads a command and executes it. The commands can be expressions to evaluate (the typical case) or special commands related to debugging, for example ,q to terminate the process (for a complete list of commands see Debugging or use the ,help command). Most commands produce some output, such as the value or error message resulting from an evaluation. The input and output of the interaction is done on the interaction channel. The interaction channel can be specified through the runtime options but if none is specified the system uses a reasonable default that depends on the system's configuration. Typically the program's standard input and output are used as the interaction channel. When using the runtime option -:debug=c , the interaction channel is the user`s console, also known as the controlling terminal in the UNIX world. When the REPL starts, the ports associated with (current-input-port) , (current-output-port) and (current-error-port) all refer to the interaction channel. Expressions are evaluated in the global interaction environment. The interpreter adds to this environment any definition entered using the define and define-macro special forms. Once the evaluation of an expression is completed, the value or values resulting from the evaluation are output to the interaction channel by the pretty printer. The special void object is not output. This object is returned by most procedures and special forms which are defined as returning an unspecified value (e.g. write , set! , define ). Here is a sample interaction with gsi: $ gsi Gambit v4.9.4 > (define (fact n) (if (< n 2) 1 (* n (fact (- n 1))))) > (map fact '(1 2 3 4 5 6)) (1 2 6 24 120 720) > (values (fact 10) (fact 40)) 3628800 815915283247897734345611269596115894272000000000 > ,q What happens when errors occur is explained in Debugging .","title":"Interactive mode"},{"location":"manual/gsi/interactive_mode/#interactive-mode","text":"In interactive mode a read-eval-print loop (REPL) is started for the user to interact with the interpreter. At each iteration of this loop the interpreter displays a prompt, reads a command and executes it. The commands can be expressions to evaluate (the typical case) or special commands related to debugging, for example ,q to terminate the process (for a complete list of commands see Debugging or use the ,help command). Most commands produce some output, such as the value or error message resulting from an evaluation. The input and output of the interaction is done on the interaction channel. The interaction channel can be specified through the runtime options but if none is specified the system uses a reasonable default that depends on the system's configuration. Typically the program's standard input and output are used as the interaction channel. When using the runtime option -:debug=c , the interaction channel is the user`s console, also known as the controlling terminal in the UNIX world. When the REPL starts, the ports associated with (current-input-port) , (current-output-port) and (current-error-port) all refer to the interaction channel. Expressions are evaluated in the global interaction environment. The interpreter adds to this environment any definition entered using the define and define-macro special forms. Once the evaluation of an expression is completed, the value or values resulting from the evaluation are output to the interaction channel by the pretty printer. The special void object is not output. This object is returned by most procedures and special forms which are defined as returning an unspecified value (e.g. write , set! , define ). Here is a sample interaction with gsi: $ gsi Gambit v4.9.4 > (define (fact n) (if (< n 2) 1 (* n (fact (- n 1))))) > (map fact '(1 2 3 4 5 6)) (1 2 6 24 120 720) > (values (fact 10) (fact 40)) 3628800 815915283247897734345611269596115894272000000000 > ,q What happens when errors occur is explained in Debugging .","title":"Interactive mode"},{"location":"manual/gsi/module_management_mode/","text":"Module management mode Package management operations are executed using the command line options -install , -uninstall , and -update which respectively install, uninstall and update packages. Package installation is explained in detail in Modules, but here are a few examples: $ gsi -install github.com/gambit/hello installing github.com/gambit/hello to /Users/feeley/.gambit_userlib/ $ gsi github.com/gambit/hello@1.0 hello world! $ gsi -uninstall github.com/gambit/hello uninstalling github.com/gambit/hello from /Users/feeley/.gambit_userlib/","title":"Module management mode"},{"location":"manual/gsi/module_management_mode/#module-management-mode","text":"Package management operations are executed using the command line options -install , -uninstall , and -update which respectively install, uninstall and update packages. Package installation is explained in detail in Modules, but here are a few examples: $ gsi -install github.com/gambit/hello installing github.com/gambit/hello to /Users/feeley/.gambit_userlib/ $ gsi github.com/gambit/hello@1.0 hello world! $ gsi -uninstall github.com/gambit/hello uninstalling github.com/gambit/hello from /Users/feeley/.gambit_userlib/","title":"Module management mode"},{"location":"manual/gsi/process_exit_status/","text":"Process exit status The status is zero when the interpreter exits normally and is nonzero when the interpreter exits due to an error. Here is the meaning of the exit statuses: 0 : The execution of the primordial thread (i.e. the main thread) did not encounter any error. It is however possible that other threads terminated abnormally (by default threads other than the primordial thread terminate silently when they raise an exception that is not handled). 64 : The runtime options or the environment variable GAMBOPT contained a syntax error or were invalid. 70 : This normally indicates that an exception was raised in the primordial thread and the exception was not handled. 71 : There was a problem initializing the runtime system, for example insufficient memory to allocate critical tables. For example, if the shell is sh : $ gsi -e \"(pretty-print (expt 2 100))\" 1267650600228229401496703205376 $ echo $? 0 $ gsi -e \"(pretty-print (expo 2 100))\" *** ERROR IN (string)@1.16 -- Unbound variable: expo $ echo $? 70 $ gsi -:debug=0 -e \"(pretty-print (expo 2 100))\" $ echo $? 70 $ gsi -:debug=0,unknown # try to use an unknown runtime option $ echo $? 64 $ gsi -:debug=0 nonexistent.scm # try to load a file that does not exist $ echo $? 70 $ gsi nonexistent.scm *** ERROR IN ##load-module-or-file -- No such file or directory (load \"nonexistent.scm\") $ echo $? 70 Note the use of the runtime option -:debug=0 that prevents error messages from being output.","title":"Process exit status"},{"location":"manual/gsi/process_exit_status/#process-exit-status","text":"The status is zero when the interpreter exits normally and is nonzero when the interpreter exits due to an error. Here is the meaning of the exit statuses: 0 : The execution of the primordial thread (i.e. the main thread) did not encounter any error. It is however possible that other threads terminated abnormally (by default threads other than the primordial thread terminate silently when they raise an exception that is not handled). 64 : The runtime options or the environment variable GAMBOPT contained a syntax error or were invalid. 70 : This normally indicates that an exception was raised in the primordial thread and the exception was not handled. 71 : There was a problem initializing the runtime system, for example insufficient memory to allocate critical tables. For example, if the shell is sh : $ gsi -e \"(pretty-print (expt 2 100))\" 1267650600228229401496703205376 $ echo $? 0 $ gsi -e \"(pretty-print (expo 2 100))\" *** ERROR IN (string)@1.16 -- Unbound variable: expo $ echo $? 70 $ gsi -:debug=0 -e \"(pretty-print (expo 2 100))\" $ echo $? 70 $ gsi -:debug=0,unknown # try to use an unknown runtime option $ echo $? 64 $ gsi -:debug=0 nonexistent.scm # try to load a file that does not exist $ echo $? 70 $ gsi nonexistent.scm *** ERROR IN ##load-module-or-file -- No such file or directory (load \"nonexistent.scm\") $ echo $? 70 Note the use of the runtime option -:debug=0 that prevents error messages from being output.","title":"Process exit status"},{"location":"manual/gsi/scheme_scripts/","text":"Scheme scripts The load procedure treats specially files that begin with the two characters #! and @; . Such files are called script files and the first line is called the script line. In addition to indicating that the file is a script, the script line provides information about the source code language to be used by the load procedure. After the two characters #! and @; the system will search for the first substring matching one of the following language specifying tokens: scheme-r4rs : R4RS language with prefix syntax, case-insensitivity, keyword syntax not supported scheme-r5rs : R5RS language with prefix syntax, case-insensitivity, keyword syntax not supported scheme-ieee-1178-1990 : IEEE 1178-1990 language with prefix syntax, case-insensitivity, keyword syntax not supported scheme-srfi-0 : R5RS language with prefix syntax and SRFI 0 support (i.e. cond-expand special form), case-insensitivity, keyword syntax not supported gsi-script : Full Gambit Scheme language with prefix syntax, case-sensitivity, keyword syntax supported gsc-script : Full Gambit Scheme language with prefix syntax, case-sensitivity, keyword syntax supported six-script : Full Gambit Scheme language with infix syntax, case-sensitivity, keyword syntax supported If a language specifying token is not found, load will use the same language as a nonscript file (i.e. it uses the file extension and runtime system options to determine the language). After processing the script line, load will parse the rest of the file (using the syntax of the language indicated) and then execute it. When the file is being loaded because it is an argument on the interpreter's command line, the interpreter will: Setup the command-line procedure so that it returns a list containing the expanded file name of the script file and the arguments following the script file on the command line. This is done before the script is executed. The expanded file name of the script file can be used to determine the directory that contains the script (i.e. (path-directory (car (command-line))) ). After the script is loaded the procedure main is called with the command line arguments. The way this is done depends on the language specifying token. For scheme-r4rs , scheme-r5rs , scheme-ieee-1178-1990 , and scheme-srfi-0 , the main procedure is called with the equivalent of (main (cdr (command-line))) and main is expected to return a process exit status code in the range 0 to 255. This conforms to the \"Running Scheme Scripts on Unix SRFI\" (SRFI 22). For gsi-script and six-script the main procedure is called with the equivalent of (apply main (cdr (command-line))) and the process exit status code is 0 ( main \u2019s result is ignored). The Gambit system has a predefined main procedure which accepts any number of arguments and returns 0, so it is perfectly valid for a script to not define main and to do all its processing with top-level expressions (examples are given in the next section). When main returns, the interpreter exits. The command line arguments after a script file are consequently not processed (however they do appear in the list returned by the command-line procedure, after the script file's expanded file name, so it is up to the script to process them). Scripts under UNIX and macOS Under UNIX and macOS, the Gambit installation process creates the executable gsi and also the executables six , gsi-script , six-script , scheme-r5rs , scheme-srfi-0 , etc as links to gsi . A Scheme script need only start with the name of the desired Scheme language variant prefixed with #! and the directory where the Gambit executables are stored. This script should be made executable by setting the execute permission bits (with a chmod +x script ). Here is an example of a script which lists on standard output the files in the current directory: #!/usr/local/Gambit/bin/gsi-script (for-each pretty-print (directory-files)) Here is another UNIX script, using the Scheme infix syntax extension, which takes a single integer argument and prints on standard output the numbers from 1 to that integer: #!/usr/local/Gambit/bin/six-script function main(n_str) { scmobj n = \\string->number(n_str); for (scmobj i=1; i<=n; i++) \\pretty-print(i); } For maximal portability it is a good idea to start scripts indirectly through the /usr/bin/env program, so that the executable of the interpreter will be searched in the user's PATH . This is what SRFI 22 recommends. For example here is a script that mimics the UNIX cat utility for text files: #!/usr/bin/env gsi-script (define (display-file filename) (display (call-with-input-file filename (lambda (port) (read-line port #f))))) (for-each display-file (cdr (command-line))) Scripts under Microsoft Windows Under Microsoft Windows, the Gambit installation process creates the executable gsi.exe and six.exe and also the batch files gsi-script.bat , six-script.bat , scheme-r5rs.bat , scheme-srfi-0.bat , etc which simply invoke gsi.exe with the same command line arguments. A Scheme script need only start with the name of the desired Scheme language variant prefixed with @; . A UNIX script can be converted to a Microsoft Windows script simply by changing the script line and storing the script in a file whose name has a .bat or .cmd extension: @;gsi-script %~f0 %* (display \"files:\\n\") (pretty-print (directory-files)) Note that Microsoft Windows always searches executables in the user's PATH , so there is no need for an indirection such as the UNIX /usr/bin/env . However the script line must end with %~f0 %* to pass the expanded filename of the script and command line arguments to the interpreter. Compiling scripts A script file can be compiled using the Gambit Scheme compiler (see section The Gambit Scheme compiler ) into a standalone executable. The script line will provide information to the compiler on which language to use. The script line also provides information on which runtime options to use when executing the compiled script. This is useful to set the default runtime options of an executable program. The compiled script will be executed similarly to an interpreted script (i.e. the list of command line arguments returned by the command-line procedure and the invocation of the main procedure). For example: $ cat square.scm #!/usr/local/Gambit/bin/gsi-script -:debug=0 (define (main arg) (pretty-print (expt (string->number arg) 2))) $ gsi square 30 # gsi will load square.scm 900 $ gsc -exe square # compile the script to a standalone program $ ./square 30 900 $ ./square 1 2 3 # too many arguments to main $ echo $? 70 $ ./square -:debug=1 1 2 3 # ask for error message *** ERROR IN ##start-main -- Wrong number of arguments passed to procedure (main \"1\" \"2\" \"3\")","title":"Scheme scripts"},{"location":"manual/gsi/scheme_scripts/#scheme-scripts","text":"The load procedure treats specially files that begin with the two characters #! and @; . Such files are called script files and the first line is called the script line. In addition to indicating that the file is a script, the script line provides information about the source code language to be used by the load procedure. After the two characters #! and @; the system will search for the first substring matching one of the following language specifying tokens: scheme-r4rs : R4RS language with prefix syntax, case-insensitivity, keyword syntax not supported scheme-r5rs : R5RS language with prefix syntax, case-insensitivity, keyword syntax not supported scheme-ieee-1178-1990 : IEEE 1178-1990 language with prefix syntax, case-insensitivity, keyword syntax not supported scheme-srfi-0 : R5RS language with prefix syntax and SRFI 0 support (i.e. cond-expand special form), case-insensitivity, keyword syntax not supported gsi-script : Full Gambit Scheme language with prefix syntax, case-sensitivity, keyword syntax supported gsc-script : Full Gambit Scheme language with prefix syntax, case-sensitivity, keyword syntax supported six-script : Full Gambit Scheme language with infix syntax, case-sensitivity, keyword syntax supported If a language specifying token is not found, load will use the same language as a nonscript file (i.e. it uses the file extension and runtime system options to determine the language). After processing the script line, load will parse the rest of the file (using the syntax of the language indicated) and then execute it. When the file is being loaded because it is an argument on the interpreter's command line, the interpreter will: Setup the command-line procedure so that it returns a list containing the expanded file name of the script file and the arguments following the script file on the command line. This is done before the script is executed. The expanded file name of the script file can be used to determine the directory that contains the script (i.e. (path-directory (car (command-line))) ). After the script is loaded the procedure main is called with the command line arguments. The way this is done depends on the language specifying token. For scheme-r4rs , scheme-r5rs , scheme-ieee-1178-1990 , and scheme-srfi-0 , the main procedure is called with the equivalent of (main (cdr (command-line))) and main is expected to return a process exit status code in the range 0 to 255. This conforms to the \"Running Scheme Scripts on Unix SRFI\" (SRFI 22). For gsi-script and six-script the main procedure is called with the equivalent of (apply main (cdr (command-line))) and the process exit status code is 0 ( main \u2019s result is ignored). The Gambit system has a predefined main procedure which accepts any number of arguments and returns 0, so it is perfectly valid for a script to not define main and to do all its processing with top-level expressions (examples are given in the next section). When main returns, the interpreter exits. The command line arguments after a script file are consequently not processed (however they do appear in the list returned by the command-line procedure, after the script file's expanded file name, so it is up to the script to process them).","title":"Scheme scripts"},{"location":"manual/gsi/scheme_scripts/#scripts-under-unix-and-macos","text":"Under UNIX and macOS, the Gambit installation process creates the executable gsi and also the executables six , gsi-script , six-script , scheme-r5rs , scheme-srfi-0 , etc as links to gsi . A Scheme script need only start with the name of the desired Scheme language variant prefixed with #! and the directory where the Gambit executables are stored. This script should be made executable by setting the execute permission bits (with a chmod +x script ). Here is an example of a script which lists on standard output the files in the current directory: #!/usr/local/Gambit/bin/gsi-script (for-each pretty-print (directory-files)) Here is another UNIX script, using the Scheme infix syntax extension, which takes a single integer argument and prints on standard output the numbers from 1 to that integer: #!/usr/local/Gambit/bin/six-script function main(n_str) { scmobj n = \\string->number(n_str); for (scmobj i=1; i<=n; i++) \\pretty-print(i); } For maximal portability it is a good idea to start scripts indirectly through the /usr/bin/env program, so that the executable of the interpreter will be searched in the user's PATH . This is what SRFI 22 recommends. For example here is a script that mimics the UNIX cat utility for text files: #!/usr/bin/env gsi-script (define (display-file filename) (display (call-with-input-file filename (lambda (port) (read-line port #f))))) (for-each display-file (cdr (command-line)))","title":"Scripts under UNIX and macOS"},{"location":"manual/gsi/scheme_scripts/#scripts-under-microsoft-windows","text":"Under Microsoft Windows, the Gambit installation process creates the executable gsi.exe and six.exe and also the batch files gsi-script.bat , six-script.bat , scheme-r5rs.bat , scheme-srfi-0.bat , etc which simply invoke gsi.exe with the same command line arguments. A Scheme script need only start with the name of the desired Scheme language variant prefixed with @; . A UNIX script can be converted to a Microsoft Windows script simply by changing the script line and storing the script in a file whose name has a .bat or .cmd extension: @;gsi-script %~f0 %* (display \"files:\\n\") (pretty-print (directory-files)) Note that Microsoft Windows always searches executables in the user's PATH , so there is no need for an indirection such as the UNIX /usr/bin/env . However the script line must end with %~f0 %* to pass the expanded filename of the script and command line arguments to the interpreter.","title":"Scripts under Microsoft Windows"},{"location":"manual/gsi/scheme_scripts/#compiling-scripts","text":"A script file can be compiled using the Gambit Scheme compiler (see section The Gambit Scheme compiler ) into a standalone executable. The script line will provide information to the compiler on which language to use. The script line also provides information on which runtime options to use when executing the compiled script. This is useful to set the default runtime options of an executable program. The compiled script will be executed similarly to an interpreted script (i.e. the list of command line arguments returned by the command-line procedure and the invocation of the main procedure). For example: $ cat square.scm #!/usr/local/Gambit/bin/gsi-script -:debug=0 (define (main arg) (pretty-print (expt (string->number arg) 2))) $ gsi square 30 # gsi will load square.scm 900 $ gsc -exe square # compile the script to a standalone program $ ./square 30 900 $ ./square 1 2 3 # too many arguments to main $ echo $? 70 $ ./square -:debug=1 1 2 3 # ask for error message *** ERROR IN ##start-main -- Wrong number of arguments passed to procedure (main \"1\" \"2\" \"3\")","title":"Compiling scripts"},{"location":"manual/host_environment/","text":"Host environment","title":"Host environment"},{"location":"manual/host_environment/#host-environment","text":"","title":"Host environment"},{"location":"manual/io_and_ports/","text":"I/O and ports","title":"I/O and ports"},{"location":"manual/io_and_ports/#io-and-ports","text":"","title":"I/O and ports"},{"location":"manual/lexical_syntax_and_readtables/","text":"Lexical syntax and readtables This sections documents Gambit's lexical syntax and readtables.","title":"Lexical syntax and readtables"},{"location":"manual/lexical_syntax_and_readtables/#lexical-syntax-and-readtables","text":"This sections documents Gambit's lexical syntax and readtables.","title":"Lexical syntax and readtables"},{"location":"manual/lexical_syntax_and_readtables/readtables/","text":"Readtables Readtables control the external textual representation of Scheme objects, that is the encoding of Scheme objects using characters. Readtables affect the behavior of the reader (i.e. the read procedure and the parser used by the load procedure and the interpreter and compiler) and the printer (i.e. the procedures write , display , print , println , pretty-print , and pp , and the procedure used by the REPL to print results). To preserve write/read invariance the printer and reader must be using compatible readtables. For example a symbol which contains upper case letters will be printed with special escapes if the readtable indicates that the reader is case-insensitive. Readtables are immutable records whose fields specify various textual representation aspects. There are accessor procedures to retrieve the content of specific fields. There are also functional update procedures that create a copy of a readtable, with a specific field set to a new value. readtable? (readtable? obj) ;; procedure This procedure returns #t when obj is a readtable and #f otherwise. For example: > (readtable? (current-readtable)) #t > (readtable? 123) #f readtable-case-conversion? readtable-case-conversion?-set (readtable-case-conversion? readtable) procedure (readtable-case-conversion?-set readtable new-value) procedure The procedure readtable-case-conversion? returns the content of the \u2018case-conversion?\u2019 field of readtable. When the content of this field is #f, the reader preserves the case of symbols, keyword and named characters that are read (i.e. Ice and ice are distinct symbols). When the content of this field is the symbol upcase, the reader converts to uppercase (i.e. Ice is read as the symbol (string->symbol \"ICE\")). Otherwise the reader converts using string-foldcase, which for many letters converts them to lowercase (i.e. Ice is read as the symbol (string->symbol \"ice\")). The procedure readtable-case-conversion?-set returns a copy of readtable where only the \u2018case-conversion?\u2019 field has been changed to new-value. For example: (output-port-readtable-set! (repl-output-port) (readtable-case-conversion?-set (output-port-readtable (repl-output-port)) #f)) (input-port-readtable-set! (repl-input-port) (readtable-case-conversion?-set (input-port-readtable (repl-input-port)) #f)) 'Ice Ice (input-port-readtable-set! (repl-input-port) (readtable-case-conversion?-set (input-port-readtable (repl-input-port)) #t)) 'Ice ice (input-port-readtable-set! (repl-input-port) (readtable-case-conversion?-set (input-port-readtable (repl-input-port)) 'upcase)) 'Ice ICE (readtable-keywords-allowed? readtable) procedure (readtable-keywords-allowed?-set readtable new-value) procedure The procedure readtable-keywords-allowed? returns the content of the \u2018keywords-allowed?\u2019 field of readtable. When the content of this field is #f, the reader does not recognize keyword objects (i.e. :foo and foo: are read as the symbols (string->symbol \":foo\") and (string->symbol \"foo:\") respectively). When the content of this field is the symbol prefix, the reader recognizes keyword objects that start with a colon, as in Common Lisp (i.e. :foo is read as the keyword (string->keyword \"foo\")). Otherwise the reader recognizes keyword objects that end with a colon, as in DSSSL (i.e. foo: is read as the symbol (string->symbol \"foo\")). The procedure readtable-keywords-allowed?-set returns a copy of readtable where only the \u2018keywords-allowed?\u2019 field has been changed to new-value. For example: (input-port-readtable-set! (repl-input-port) (readtable-keywords-allowed?-set (input-port-readtable (repl-input-port)) #f)) (map keyword? '(foo :foo foo:)) (#f #f #f) (input-port-readtable-set! (repl-input-port) (readtable-keywords-allowed?-set (input-port-readtable (repl-input-port)) #t)) (map keyword? '(foo :foo foo:)) (#f #f #t) (input-port-readtable-set! (repl-input-port) (readtable-keywords-allowed?-set (input-port-readtable (repl-input-port)) 'prefix)) (map keyword? '(foo :foo foo:)) (#f #t #f) (readtable-sharing-allowed? readtable) procedure (readtable-sharing-allowed?-set readtable new-value) procedure The procedure readtable-sharing-allowed? returns the content of the \u2018sharing-allowed?\u2019 field of readtable. The reader recognizes the #n# and #n=datum notation for shared and circular structures and the printer uses this notation depending on the content of the \u2018sharing-allowed?\u2019 field and the printing primitive used. When the content of the \u2018sharing-allowed?\u2019 field is the symbol default, the procedure write-shared will use this notation for shared and circular structures, the procedures write, display, pp, pretty-print, print, and println will use this notation for circular structures, and the procedure write-simple does not use this notation. When the content of the \u2018sharing-allowed?\u2019 field is #f, the printing procedures will not use this notation. When the content of the \u2018sharing-allowed?\u2019 field is #t, the printing procedures will use this notation for shared and circular structures. Finally, when the content of the \u2018sharing-allowed?\u2019 field is the symbol serialize, the printer uses a special external representation that the reader understands and that extends write/read invariance to the following types: records, procedures and continuations. Note that an object can be serialized and deserialized if and only if all of its components are serializable. The procedure readtable-sharing-allowed?-set returns a copy of readtable where only the \u2018sharing-allowed?\u2019 field has been changed to new-value. Here is a simple example: (define (wr obj allow?) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-sharing-allowed?-set (output-port-readtable p) allow?)) (write obj p)))) (define (rd str allow?) (call-with-input-string str (lambda (p) (input-port-readtable-set! p (readtable-sharing-allowed?-set (input-port-readtable p) allow?)) (read p)))) (define x (list 1 2 3)) (set-car! (cdr x) (cddr x)) (wr x #f) \"(1 (3) 3)\" (wr x #t) \"(1 #0=(3) . #0#)\" (define y (rd (wr x #t) #t)) y (1 (3) 3) (eq? (cadr y) (cddr y)) t (define f #f) (let ((free (expt 2 10))) (set! f (lambda (x) (+ x free)))) (define s (wr f 'serialize)) (string-length s) 4196 (define g (rd s 'serialize)) (eq? f g) f (g 4) 1028 Continuations are tricky to serialize because they contain a dynamic environment and this dynamic environment may contain non-serializable objects, in particular ports attached to operating-system streams such as files, the console or standard input/output. Indeed, all dynamic environments contain a binding for the current-input-port and current-output-port. Moreover, any thread that has started a REPL has a continuation which refers to the repl-context object in its dynamic environment. A repl-context object contains the interaction channel, which is typically connected to a non-serializable port, such as the console. Another problem is that the parameterize form saves the old binding of the parameter in the continuation, so it is not possible to eliminate the references to these ports in the continuation by using the parameterize form alone. Serialization of continuations can be achieved dependably by taking advantage of string-ports, which are serializable objects (unless there is a blocked thread), and the following features of threads: they inherit the dynamic environment of the parent thread and they start with an initial continuation that contains only serializable objects. So a thread created in a dynamic environment where current-input-port and current-output-port are bound to a dummy string-port has a serializable continuation. Here is an example where continuations are serialized: (define (wr obj) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-sharing-allowed?-set (output-port-readtable p) 'serialize)) (write obj p)))) (define (rd str) (call-with-input-string str (lambda (p) (input-port-readtable-set! p (readtable-sharing-allowed?-set (input-port-readtable p) 'serialize)) (read p)))) (define fifo (open-vector)) (define (suspend-and-die!) (call-with-current-continuation (lambda (k) (write (wr k) fifo) (newline fifo) (force-output fifo) (thread-terminate! (current-thread))))) (let ((dummy-port (open-string))) (parameterize ((current-input-port dummy-port) (current-output-port dummy-port)) (thread-start! (make-thread (lambda () (* 100 (suspend-and-die!))))))) (define s (read fifo)) (thread-join! (thread-start! (make-thread (lambda () ((rd s) 111))))) 11100 (thread-join! (thread-start! (make-thread (lambda () ((rd s) 222))))) 22200 (string-length s) 13114 (readtable-eval-allowed? readtable) procedure (readtable-eval-allowed?-set readtable new-value) procedure The procedure readtable-eval-allowed? returns the content of the \u2018eval-allowed?\u2019 field of readtable. The reader recognizes the #.expression notation for read-time evaluation if and only if the content of the \u2018eval-allowed?\u2019 field is not #f. The procedure readtable-eval-allowed?-set returns a copy of readtable where only the \u2018eval-allowed?\u2019 field has been changed to new-value. For example: (input-port-readtable-set! (repl-input-port) (readtable-eval-allowed?-set (input-port-readtable (repl-input-port)) #t)) '(5 plus 7 is #.(+ 5 7)) (5 plus 7 is 12) '(buf = #.(make-u8vector 25)) (buf = #u8(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)) (readtable-write-cdr-read-macros? readtable) procedure (readtable-write-cdr-read-macros?-set readtable new-value) procedure (readtable-write-extended-read-macros? readtable) procedure (readtable-write-extended-read-macros?-set readtable new-value) procedure The procedure readtable-write-cdr-read-macros? returns the content of the \u2018write-cdr-read-macros?\u2019 field of readtable. The procedure readtable-write-extended-read-macros? returns the content of the \u2018write-extended-read-macros?\u2019 field of readtable. At all times the printer uses read-macros in its output for datums of the form (quote datum), (quasiquote datum), (unquote datum), and (unquote-splicing datum). That is the following read-macro notations will be used respectively: 'datum, `datum, ,datum, and ,@datum. Moreover, normally the read-macros will not be used when the form appears in the cdr of a list, for example (foo quote bar), (foo . (quote bar)) and (foo . 'bar) will all be printed as (foo quote bar). When the content of the \u2018write-cdr-read-macros?\u2019 field is not #f, the printer will use read-macros when the forms appear in the cdr of a list. For example (foo quote bar) will be printed as (foo . 'bar). When the content of the \u2018write-extended-read-macros?\u2019 field is not #f, the printer will also use extended read-macros, for example #'datum in place of (syntax datum). The procedure readtable-write-cdr-read-macros?-set returns a copy of readtable where only the \u2018write-cdr-read-macros?\u2019 field has been changed to new-value. The procedure readtable-write-extended-read-macros?-set returns a copy of readtable where only the \u2018write-extended-read-macros?\u2019 field has been changed to new-value. For example: (output-port-readtable-set! (repl-output-port) (readtable-write-extended-read-macros?-set (output-port-readtable (repl-output-port)) #t)) '(foo (syntax bar)) (foo #'bar) '(foo syntax bar) (foo syntax bar) (output-port-readtable-set! (repl-output-port) (readtable-write-cdr-read-macros?-set (output-port-readtable (repl-output-port)) #t)) '(foo syntax bar) (foo . #'bar) (readtable-max-write-level readtable) procedure (readtable-max-write-level-set readtable new-value) procedure The procedure readtable-max-write-level returns the content of the \u2018max-write-level\u2019 field of readtable. The printer will display an ellipsis for the elements of lists and vectors that are nested deeper than this level. The procedure readtable-max-write-level-set returns a copy of readtable where only the \u2018max-write-level\u2019 field has been changed to new-value, which must be an nonnegative fixnum. For example: (define (wr obj n) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-max-write-level-set (output-port-readtable p) n)) (write obj p)))) (wr '(a #(b (c c) #u8(9 9 9) b) a) 3) \"(a #(b (c c) #u8(9 9 9) b) a)\" (wr '(a #(b (c c) #u8(9 9 9) b) a) 2) \"(a #(b (...) #u8(...) b) a)\" (wr '(a #(b (c c) #u8(9 9 9) b) a) 1) \"(a #(...) a)\" (wr '(a #(b (c c) #u8(9 9 9) b) a) 0) \"(...)\" (wr 'hello 0) \"hello\" (readtable-max-write-length readtable) procedure (readtable-max-write-length-set readtable new-value) procedure The procedure readtable-max-write-length returns the content of the \u2018max-write-length\u2019 field of readtable. The printer will display an ellipsis for the elements of lists and vectors that are at an index beyond that length. The procedure readtable-max-write-length-set returns a copy of readtable where only the \u2018max-write-length\u2019 field has been changed to new-value, which must be an nonnegative fixnum. For example: (define (wr obj n) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-max-write-length-set (output-port-readtable p) n)) (write obj p)))) (wr '(a #(b (c c) #u8(9 9 9) b) . a) 4) \"(a #(b (c c) #u8(9 9 9) b) . a)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 3) \"(a #(b (c c) #u8(9 9 9) ...) . a)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 2) \"(a #(b (c c) ...) . a)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 1) \"(a ...)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 0) \"(...)\" (readtable-max-unescaped-char readtable) procedure (readtable-max-unescaped-char-set readtable new-value) procedure The procedure readtable-max-unescaped-char returns the content of the \u2018max-unescaped-char\u2019 field of readtable. The printer will display using an escape sequence any character within symbols, strings and character objects greater than \u2018max-unescaped-char\u2019. When \u2018max-unescaped-char\u2019 is #f, the default value, the printer will take into account the output port and use an escape sequence for any character that isn\u2019t supported by the port\u2019s character encoding. The procedure readtable-max-unescaped-char-set returns a copy of readtable where only the \u2018max-unescaped-char\u2019 field has been changed to new-value, which must be a character or #f. For example: (define rt (output-port-readtable (repl-output-port))) (readtable-max-unescaped-char rt) \\delete (string (integer->char 233)) \"\\351\" (define (f c) (with-output-to-string (list readtable: (readtable-max-unescaped-char-set rt c)) (lambda () (write (string (integer->char 233)))))) (f #\\delete) \"\\\"\\351\\\"\" (string-length (f #\\delete)) 6 (f #\\U0010ffff) \"\\\"\\351\\\"\" (string-length (f #\\U0010ffff)) 3 (output-port-readtable-set! (repl-output-port) (readtable-max-unescaped-char-set rt #\\U0010ffff)) (string (integer->char 233)) \"\u00e9\" (readtable-start-syntax readtable) procedure (readtable-start-syntax-set readtable new-value) procedure The procedure readtable-start-syntax returns the content of the \u2018start-syntax\u2019 field of readtable. The reader uses this field to determine in which syntax to start parsing the input. When the content of this field is the symbol six, the reader starts in the infix syntax. Otherwise the reader starts in the prefix syntax. The procedure readtable-start-syntax-set returns a copy of readtable where only the \u2018start-syntax\u2019 field has been changed to new-value. For example: (+ 2 3) 5 (input-port-readtable-set! (repl-input-port) (readtable-start-syntax-set (input-port-readtable (repl-input-port)) 'six)) 2+3; 5 exit();","title":"Readtables"},{"location":"manual/lexical_syntax_and_readtables/readtables/#readtables","text":"Readtables control the external textual representation of Scheme objects, that is the encoding of Scheme objects using characters. Readtables affect the behavior of the reader (i.e. the read procedure and the parser used by the load procedure and the interpreter and compiler) and the printer (i.e. the procedures write , display , print , println , pretty-print , and pp , and the procedure used by the REPL to print results). To preserve write/read invariance the printer and reader must be using compatible readtables. For example a symbol which contains upper case letters will be printed with special escapes if the readtable indicates that the reader is case-insensitive. Readtables are immutable records whose fields specify various textual representation aspects. There are accessor procedures to retrieve the content of specific fields. There are also functional update procedures that create a copy of a readtable, with a specific field set to a new value.","title":"Readtables"},{"location":"manual/lexical_syntax_and_readtables/readtables/#readtable","text":"(readtable? obj) ;; procedure This procedure returns #t when obj is a readtable and #f otherwise. For example: > (readtable? (current-readtable)) #t > (readtable? 123) #f","title":"readtable?"},{"location":"manual/lexical_syntax_and_readtables/readtables/#readtable-case-conversion","text":"","title":"readtable-case-conversion?"},{"location":"manual/lexical_syntax_and_readtables/readtables/#readtable-case-conversion-set","text":"(readtable-case-conversion? readtable) procedure (readtable-case-conversion?-set readtable new-value) procedure The procedure readtable-case-conversion? returns the content of the \u2018case-conversion?\u2019 field of readtable. When the content of this field is #f, the reader preserves the case of symbols, keyword and named characters that are read (i.e. Ice and ice are distinct symbols). When the content of this field is the symbol upcase, the reader converts to uppercase (i.e. Ice is read as the symbol (string->symbol \"ICE\")). Otherwise the reader converts using string-foldcase, which for many letters converts them to lowercase (i.e. Ice is read as the symbol (string->symbol \"ice\")). The procedure readtable-case-conversion?-set returns a copy of readtable where only the \u2018case-conversion?\u2019 field has been changed to new-value. For example: (output-port-readtable-set! (repl-output-port) (readtable-case-conversion?-set (output-port-readtable (repl-output-port)) #f)) (input-port-readtable-set! (repl-input-port) (readtable-case-conversion?-set (input-port-readtable (repl-input-port)) #f)) 'Ice Ice (input-port-readtable-set! (repl-input-port) (readtable-case-conversion?-set (input-port-readtable (repl-input-port)) #t)) 'Ice ice (input-port-readtable-set! (repl-input-port) (readtable-case-conversion?-set (input-port-readtable (repl-input-port)) 'upcase)) 'Ice ICE (readtable-keywords-allowed? readtable) procedure (readtable-keywords-allowed?-set readtable new-value) procedure The procedure readtable-keywords-allowed? returns the content of the \u2018keywords-allowed?\u2019 field of readtable. When the content of this field is #f, the reader does not recognize keyword objects (i.e. :foo and foo: are read as the symbols (string->symbol \":foo\") and (string->symbol \"foo:\") respectively). When the content of this field is the symbol prefix, the reader recognizes keyword objects that start with a colon, as in Common Lisp (i.e. :foo is read as the keyword (string->keyword \"foo\")). Otherwise the reader recognizes keyword objects that end with a colon, as in DSSSL (i.e. foo: is read as the symbol (string->symbol \"foo\")). The procedure readtable-keywords-allowed?-set returns a copy of readtable where only the \u2018keywords-allowed?\u2019 field has been changed to new-value. For example: (input-port-readtable-set! (repl-input-port) (readtable-keywords-allowed?-set (input-port-readtable (repl-input-port)) #f)) (map keyword? '(foo :foo foo:)) (#f #f #f) (input-port-readtable-set! (repl-input-port) (readtable-keywords-allowed?-set (input-port-readtable (repl-input-port)) #t)) (map keyword? '(foo :foo foo:)) (#f #f #t) (input-port-readtable-set! (repl-input-port) (readtable-keywords-allowed?-set (input-port-readtable (repl-input-port)) 'prefix)) (map keyword? '(foo :foo foo:)) (#f #t #f) (readtable-sharing-allowed? readtable) procedure (readtable-sharing-allowed?-set readtable new-value) procedure The procedure readtable-sharing-allowed? returns the content of the \u2018sharing-allowed?\u2019 field of readtable. The reader recognizes the #n# and #n=datum notation for shared and circular structures and the printer uses this notation depending on the content of the \u2018sharing-allowed?\u2019 field and the printing primitive used. When the content of the \u2018sharing-allowed?\u2019 field is the symbol default, the procedure write-shared will use this notation for shared and circular structures, the procedures write, display, pp, pretty-print, print, and println will use this notation for circular structures, and the procedure write-simple does not use this notation. When the content of the \u2018sharing-allowed?\u2019 field is #f, the printing procedures will not use this notation. When the content of the \u2018sharing-allowed?\u2019 field is #t, the printing procedures will use this notation for shared and circular structures. Finally, when the content of the \u2018sharing-allowed?\u2019 field is the symbol serialize, the printer uses a special external representation that the reader understands and that extends write/read invariance to the following types: records, procedures and continuations. Note that an object can be serialized and deserialized if and only if all of its components are serializable. The procedure readtable-sharing-allowed?-set returns a copy of readtable where only the \u2018sharing-allowed?\u2019 field has been changed to new-value. Here is a simple example: (define (wr obj allow?) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-sharing-allowed?-set (output-port-readtable p) allow?)) (write obj p)))) (define (rd str allow?) (call-with-input-string str (lambda (p) (input-port-readtable-set! p (readtable-sharing-allowed?-set (input-port-readtable p) allow?)) (read p)))) (define x (list 1 2 3)) (set-car! (cdr x) (cddr x)) (wr x #f) \"(1 (3) 3)\" (wr x #t) \"(1 #0=(3) . #0#)\" (define y (rd (wr x #t) #t)) y (1 (3) 3) (eq? (cadr y) (cddr y))","title":"readtable-case-conversion?-set"},{"location":"manual/lexical_syntax_and_readtables/readtables/#t","text":"(define f #f) (let ((free (expt 2 10))) (set! f (lambda (x) (+ x free)))) (define s (wr f 'serialize)) (string-length s) 4196 (define g (rd s 'serialize)) (eq? f g)","title":"t"},{"location":"manual/lexical_syntax_and_readtables/readtables/#f","text":"(g 4) 1028 Continuations are tricky to serialize because they contain a dynamic environment and this dynamic environment may contain non-serializable objects, in particular ports attached to operating-system streams such as files, the console or standard input/output. Indeed, all dynamic environments contain a binding for the current-input-port and current-output-port. Moreover, any thread that has started a REPL has a continuation which refers to the repl-context object in its dynamic environment. A repl-context object contains the interaction channel, which is typically connected to a non-serializable port, such as the console. Another problem is that the parameterize form saves the old binding of the parameter in the continuation, so it is not possible to eliminate the references to these ports in the continuation by using the parameterize form alone. Serialization of continuations can be achieved dependably by taking advantage of string-ports, which are serializable objects (unless there is a blocked thread), and the following features of threads: they inherit the dynamic environment of the parent thread and they start with an initial continuation that contains only serializable objects. So a thread created in a dynamic environment where current-input-port and current-output-port are bound to a dummy string-port has a serializable continuation. Here is an example where continuations are serialized: (define (wr obj) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-sharing-allowed?-set (output-port-readtable p) 'serialize)) (write obj p)))) (define (rd str) (call-with-input-string str (lambda (p) (input-port-readtable-set! p (readtable-sharing-allowed?-set (input-port-readtable p) 'serialize)) (read p)))) (define fifo (open-vector)) (define (suspend-and-die!) (call-with-current-continuation (lambda (k) (write (wr k) fifo) (newline fifo) (force-output fifo) (thread-terminate! (current-thread))))) (let ((dummy-port (open-string))) (parameterize ((current-input-port dummy-port) (current-output-port dummy-port)) (thread-start! (make-thread (lambda () (* 100 (suspend-and-die!)))))))","title":"f"},{"location":"manual/lexical_syntax_and_readtables/readtables/#_1","text":"(define s (read fifo)) (thread-join! (thread-start! (make-thread (lambda () ((rd s) 111))))) 11100 (thread-join! (thread-start! (make-thread (lambda () ((rd s) 222))))) 22200 (string-length s) 13114 (readtable-eval-allowed? readtable) procedure (readtable-eval-allowed?-set readtable new-value) procedure The procedure readtable-eval-allowed? returns the content of the \u2018eval-allowed?\u2019 field of readtable. The reader recognizes the #.expression notation for read-time evaluation if and only if the content of the \u2018eval-allowed?\u2019 field is not #f. The procedure readtable-eval-allowed?-set returns a copy of readtable where only the \u2018eval-allowed?\u2019 field has been changed to new-value. For example: (input-port-readtable-set! (repl-input-port) (readtable-eval-allowed?-set (input-port-readtable (repl-input-port)) #t)) '(5 plus 7 is #.(+ 5 7)) (5 plus 7 is 12) '(buf = #.(make-u8vector 25)) (buf = #u8(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)) (readtable-write-cdr-read-macros? readtable) procedure (readtable-write-cdr-read-macros?-set readtable new-value) procedure (readtable-write-extended-read-macros? readtable) procedure (readtable-write-extended-read-macros?-set readtable new-value) procedure The procedure readtable-write-cdr-read-macros? returns the content of the \u2018write-cdr-read-macros?\u2019 field of readtable. The procedure readtable-write-extended-read-macros? returns the content of the \u2018write-extended-read-macros?\u2019 field of readtable. At all times the printer uses read-macros in its output for datums of the form (quote datum), (quasiquote datum), (unquote datum), and (unquote-splicing datum). That is the following read-macro notations will be used respectively: 'datum, `datum, ,datum, and ,@datum. Moreover, normally the read-macros will not be used when the form appears in the cdr of a list, for example (foo quote bar), (foo . (quote bar)) and (foo . 'bar) will all be printed as (foo quote bar). When the content of the \u2018write-cdr-read-macros?\u2019 field is not #f, the printer will use read-macros when the forms appear in the cdr of a list. For example (foo quote bar) will be printed as (foo . 'bar). When the content of the \u2018write-extended-read-macros?\u2019 field is not #f, the printer will also use extended read-macros, for example #'datum in place of (syntax datum). The procedure readtable-write-cdr-read-macros?-set returns a copy of readtable where only the \u2018write-cdr-read-macros?\u2019 field has been changed to new-value. The procedure readtable-write-extended-read-macros?-set returns a copy of readtable where only the \u2018write-extended-read-macros?\u2019 field has been changed to new-value. For example: (output-port-readtable-set! (repl-output-port) (readtable-write-extended-read-macros?-set (output-port-readtable (repl-output-port)) #t)) '(foo (syntax bar)) (foo #'bar) '(foo syntax bar) (foo syntax bar) (output-port-readtable-set! (repl-output-port) (readtable-write-cdr-read-macros?-set (output-port-readtable (repl-output-port)) #t)) '(foo syntax bar) (foo . #'bar) (readtable-max-write-level readtable) procedure (readtable-max-write-level-set readtable new-value) procedure The procedure readtable-max-write-level returns the content of the \u2018max-write-level\u2019 field of readtable. The printer will display an ellipsis for the elements of lists and vectors that are nested deeper than this level. The procedure readtable-max-write-level-set returns a copy of readtable where only the \u2018max-write-level\u2019 field has been changed to new-value, which must be an nonnegative fixnum. For example: (define (wr obj n) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-max-write-level-set (output-port-readtable p) n)) (write obj p)))) (wr '(a #(b (c c) #u8(9 9 9) b) a) 3) \"(a #(b (c c) #u8(9 9 9) b) a)\" (wr '(a #(b (c c) #u8(9 9 9) b) a) 2) \"(a #(b (...) #u8(...) b) a)\" (wr '(a #(b (c c) #u8(9 9 9) b) a) 1) \"(a #(...) a)\" (wr '(a #(b (c c) #u8(9 9 9) b) a) 0) \"(...)\" (wr 'hello 0) \"hello\" (readtable-max-write-length readtable) procedure (readtable-max-write-length-set readtable new-value) procedure The procedure readtable-max-write-length returns the content of the \u2018max-write-length\u2019 field of readtable. The printer will display an ellipsis for the elements of lists and vectors that are at an index beyond that length. The procedure readtable-max-write-length-set returns a copy of readtable where only the \u2018max-write-length\u2019 field has been changed to new-value, which must be an nonnegative fixnum. For example: (define (wr obj n) (call-with-output-string (lambda (p) (output-port-readtable-set! p (readtable-max-write-length-set (output-port-readtable p) n)) (write obj p)))) (wr '(a #(b (c c) #u8(9 9 9) b) . a) 4) \"(a #(b (c c) #u8(9 9 9) b) . a)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 3) \"(a #(b (c c) #u8(9 9 9) ...) . a)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 2) \"(a #(b (c c) ...) . a)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 1) \"(a ...)\" (wr '(a #(b (c c) #u8(9 9 9) b) . a) 0) \"(...)\" (readtable-max-unescaped-char readtable) procedure (readtable-max-unescaped-char-set readtable new-value) procedure The procedure readtable-max-unescaped-char returns the content of the \u2018max-unescaped-char\u2019 field of readtable. The printer will display using an escape sequence any character within symbols, strings and character objects greater than \u2018max-unescaped-char\u2019. When \u2018max-unescaped-char\u2019 is #f, the default value, the printer will take into account the output port and use an escape sequence for any character that isn\u2019t supported by the port\u2019s character encoding. The procedure readtable-max-unescaped-char-set returns a copy of readtable where only the \u2018max-unescaped-char\u2019 field has been changed to new-value, which must be a character or #f. For example: (define rt (output-port-readtable (repl-output-port))) (readtable-max-unescaped-char rt)","title":""},{"location":"manual/lexical_syntax_and_readtables/readtables/#delete","text":"(string (integer->char 233)) \"\\351\" (define (f c) (with-output-to-string (list readtable: (readtable-max-unescaped-char-set rt c)) (lambda () (write (string (integer->char 233)))))) (f #\\delete) \"\\\"\\351\\\"\" (string-length (f #\\delete)) 6 (f #\\U0010ffff) \"\\\"\\351\\\"\" (string-length (f #\\U0010ffff)) 3 (output-port-readtable-set! (repl-output-port) (readtable-max-unescaped-char-set rt #\\U0010ffff)) (string (integer->char 233)) \"\u00e9\" (readtable-start-syntax readtable) procedure (readtable-start-syntax-set readtable new-value) procedure The procedure readtable-start-syntax returns the content of the \u2018start-syntax\u2019 field of readtable. The reader uses this field to determine in which syntax to start parsing the input. When the content of this field is the symbol six, the reader starts in the infix syntax. Otherwise the reader starts in the prefix syntax. The procedure readtable-start-syntax-set returns a copy of readtable where only the \u2018start-syntax\u2019 field has been changed to new-value. For example: (+ 2 3) 5 (input-port-readtable-set! (repl-input-port) (readtable-start-syntax-set (input-port-readtable (repl-input-port)) 'six)) 2+3; 5 exit();","title":"\\delete"},{"location":"manual/modules/","text":"Modules Gambit supports multiple modularization approaches and constructs: legacy modules, primitive modules and R7RS compatible modules. These are described in that order, which corresponds to increased abstraction level. Unless there is a need for detailed control over the modules, it is best to use the R7RS compatible module system for the development of new code.","title":"Modules"},{"location":"manual/modules/#modules","text":"Gambit supports multiple modularization approaches and constructs: legacy modules, primitive modules and R7RS compatible modules. These are described in that order, which corresponds to increased abstraction level. Unless there is a need for detailed control over the modules, it is best to use the R7RS compatible module system for the development of new code.","title":"Modules"},{"location":"manual/modules/compiling_modules/","text":"Compiling modules When gsc finds a command line argument that is the name of a module found on the list of module search order directories (after an automatic installation if that is appropriate) that module's main source code file will be compiled. When a dynamic compilation is requested (which is the default compilation mode and when the command line option -dynamic is used) the compiler will compile for the selected target the main source code file to a target file and a dynamically loadable object file with a .o1 extension. These files will be created in a directory next to the module's main source code file, with the same name stripped of it's extension and suffixed with the Gambit version and the target name. This naming strategy aims to avoid loading the compiled file in an inappropriate context. The module loading algorithm knows it should check this directory to find a compiled version of the module. For example: $ mkdir lib1 lib2 $ cat > lib1/lib1.sld (define-library (lib1) (export fact) (import (scheme base) (scheme write)) (begin (define (fact n) (if (<= n 1) 1 (* n (fact (- n 1))))) (display \"lib1 loaded\\n\"))) $ cat > lib2/lib2.sld (define-library (lib2) (import (lib1) (scheme base) (scheme write)) (begin (display (cond-expand ((compilation-target C) \"lib2 compiled to C\\n\") ((compilation-target (_)) \"lib2 interpreted\\n\") (else \"lib2 compiled to other\\n\"))) (display (fact 10)) (newline))) $ gsi . lib2 # loads lib1.sld and lib2.sld lib1 loaded lib2 interpreted 3628800 lib1 $ tree --charset=ascii --noreport lib1 lib2 `-- lib1.sld lib2 `-- lib2.sld $ gsc . lib1 lib2 # compile lib1.sld and lib2.sld using C target $ gsi . lib2 # loads generated lib1.o1 and lib2.o1 lib1 loaded lib2 compiled to C 3628800 $ gsc -target js . lib1 lib2 # also compile them for js target $ tree --charset=ascii --noreport lib1 lib2 lib1 |-- lib1.sld |-- lib1@gambit409003@C | |-- lib1.c | `-- lib1.o1 `-- lib1@gambit409003@js |-- lib1.js `-- lib1.o1 lib2 |-- lib2.sld |-- lib2@gambit409003@C | |-- lib2.c | `-- lib2.o1 `-- lib2@gambit409003@js |-- lib2.js `-- lib2.o1 To create an executable program from a set of non-legacy modules it is important to use the -nopreload linking option when linking so that the modules will be initialized in an order that is consistent with the module dependencies. If the default -preload linking option is used some modules may be initialized out of order, leading to incorrect execution. Here is an example that extends the previous example: $ gsc -exe -nopreload . lib1/lib1.sld lib2/lib2.sld $ lib2/lib2 lib1 loaded lib2 compiled to C 3628800 $ gsc -target js -exe -nopreload . lib1/lib1.sld lib2/lib2.sld $ lib2/lib2 lib1 loaded lib2 compiled to other 3628800","title":"Compiling modules"},{"location":"manual/modules/compiling_modules/#compiling-modules","text":"When gsc finds a command line argument that is the name of a module found on the list of module search order directories (after an automatic installation if that is appropriate) that module's main source code file will be compiled. When a dynamic compilation is requested (which is the default compilation mode and when the command line option -dynamic is used) the compiler will compile for the selected target the main source code file to a target file and a dynamically loadable object file with a .o1 extension. These files will be created in a directory next to the module's main source code file, with the same name stripped of it's extension and suffixed with the Gambit version and the target name. This naming strategy aims to avoid loading the compiled file in an inappropriate context. The module loading algorithm knows it should check this directory to find a compiled version of the module. For example: $ mkdir lib1 lib2 $ cat > lib1/lib1.sld (define-library (lib1) (export fact) (import (scheme base) (scheme write)) (begin (define (fact n) (if (<= n 1) 1 (* n (fact (- n 1))))) (display \"lib1 loaded\\n\"))) $ cat > lib2/lib2.sld (define-library (lib2) (import (lib1) (scheme base) (scheme write)) (begin (display (cond-expand ((compilation-target C) \"lib2 compiled to C\\n\") ((compilation-target (_)) \"lib2 interpreted\\n\") (else \"lib2 compiled to other\\n\"))) (display (fact 10)) (newline))) $ gsi . lib2 # loads lib1.sld and lib2.sld lib1 loaded lib2 interpreted 3628800 lib1 $ tree --charset=ascii --noreport lib1 lib2 `-- lib1.sld lib2 `-- lib2.sld $ gsc . lib1 lib2 # compile lib1.sld and lib2.sld using C target $ gsi . lib2 # loads generated lib1.o1 and lib2.o1 lib1 loaded lib2 compiled to C 3628800 $ gsc -target js . lib1 lib2 # also compile them for js target $ tree --charset=ascii --noreport lib1 lib2 lib1 |-- lib1.sld |-- lib1@gambit409003@C | |-- lib1.c | `-- lib1.o1 `-- lib1@gambit409003@js |-- lib1.js `-- lib1.o1 lib2 |-- lib2.sld |-- lib2@gambit409003@C | |-- lib2.c | `-- lib2.o1 `-- lib2@gambit409003@js |-- lib2.js `-- lib2.o1 To create an executable program from a set of non-legacy modules it is important to use the -nopreload linking option when linking so that the modules will be initialized in an order that is consistent with the module dependencies. If the default -preload linking option is used some modules may be initialized out of order, leading to incorrect execution. Here is an example that extends the previous example: $ gsc -exe -nopreload . lib1/lib1.sld lib2/lib2.sld $ lib2/lib2 lib1 loaded lib2 compiled to C 3628800 $ gsc -target js -exe -nopreload . lib1/lib1.sld lib2/lib2.sld $ lib2/lib2 lib1 loaded lib2 compiled to other 3628800","title":"Compiling modules"},{"location":"manual/modules/installing_modules/","text":"Installing modules When a module is imported, the processing of the import form must locate and read the source code of the module at macro expansion time to determine which names are exported and to what they are mapped. The list of module search directories ( ~~lib followed by ~~userlib by default) is searched to find the module's source code. At execution time the same search algorithm is used to locate and load the module, either in source code form or compiled form. The ~~lib directory is where the system's builtin modules are put when Gambit is installed. The ~~userlib directory is a convenient place where other modules can be installed by the user because locating them does not require extending the list of module search directories. module-search-order-reset! module-search-order-add! (module-search-order-reset!) ;; procedure (module-search-order-add! dir) ;; procedure The list of module search directories can be modified using the procedures module-search-order-reset! and module-search-order-add! that respectively clear the list and extend the list with the directory dir which must be a string. The list can also be extended by using the -:search=DIR runtime option or by a command line argument to gsi and gsc that ends with a path separator or a . (see section ##demand-module and ##supply-module forms). For example: $ cat foobar.sld (define-library (foobar) (import (scheme write)) (begin (display \"foobar library has executed\\n\"))) $ gsi Gambit v4.9.4 > (import (foobar)) *** ERROR IN (stdin)@1.9 -- Cannot find library (foobar) > (module-search-order-add! \".\") > (import (foobar)) foobar library has executed > ,q $ gsi -:search=. foobar foobar library has executed $ gsi . foobar foobar library has executed module-whitelist-reset! module-whitelist-add! (module-whitelist-reset!) ;; procedure (module-whitelist-add! source) ;; procedure When modules are installed it is done at the granularity of a package, which is defined as a git repository possibly containing more than one module. For example, if the hosted module github.com/gambit/hello/demo needs to be installed it is all of the code at github.com/gambit/hello that is installed (this includes the three modules github.com/gambit/hello , github.com/gambit/hello/demo , and github.com/gambit/hello/test ). For convenience the runtime system will automatically install in the ~~userlib directory any hosted module that is from a trusted source. The whitelist of trusted sources, which initially contains only github.com/gambit , can be modified using the procedures module-whitelist-reset! and module-whitelist-add! that respectively clear the list and extend the list with the source source which must be a string. The list can also be extended with the -:whitelist=SOURCE runtime option. For example: $ gsi github.com/gambit/hello/demo # auto-install of github.com/gambit/hello package People customarily greet each other when they meet. In English you can say: hello Bob, nice to see you! In French you can say: bonjour Bob, je suis enchant\ufffd! Demo source code: /Users/feeley/.gambit_userlib/github.com/gambit/hello/@/demo.scm $ gsi github.com/feeley/roman/demo # no auto-install because not on whitelist *** ERROR IN ##main -- No such file or directory (load \"github.com/feeley/roman/demo\") $ gsi -:whitelist=github.com/feeley github.com/feeley/roman/demo 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals $ gsi github.com/feeley/roman/demo # OK because module is now installed 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals $ gsi github.com/feeley/roman/test # the test module was also installed *** all tests passed out of a total of 19 tests The use of the runtime option -:whitelist= (with no SOURCE ) will disable the automatic installation of modules, even from github.com/gambit . For example: $ gsi -:whitelist= github.com/gambit/hello/demo *** ERROR IN ##main -- No such file or directory (load \"github.com/gambit/hello/demo\") A manual management of packages is nevertheless possible with the gsi package management operations. These are invoked with the command line options -install , -uninstall , and -update which respectively install, uninstall and update packages. The package management operations accept a list of packages. Packages are installed in ~~userlib which is mapped to ~/.gambit_userlib by default. An optional -dir dir option can be used to install the package in some other directory. For example: $ gsi -install github.com/feeley/roman installing github.com/feeley/roman to /Users/feeley/.gambit_userlib/ $ gsi github.com/feeley/roman/demo 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals $ gsi -uninstall github.com/feeley/roman uninstalling github.com/feeley/roman from /Users/feeley/.gambit_userlib/ $ gsi -install -dir ~/mylibs github.com/feeley/roman installing github.com/feeley/roman to /Users/feeley/mylibs $ gsi ~/mylibs/ github.com/feeley/roman/demo 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals Local git repositories can also be installed manually with the package management operations using a path to the local repository. This can be useful during the development phase before a library becomes hosted. For example: $ mkdir some $ mkdir some/dir $ mkdir some/dir/mylib $ cd some/dir/mylib $ cat > mylib.sld (define-library (mylib) (import (scheme write)) (begin (display \"mylib library has executed\\n\"))) $ git init Initialized empty Git repository in /Users/feeley/doc/some/dir/mylib/.git/ $ git add mylib.sld $ git commit -m \"first commit\" [master (root-commit) c3f6aff] first commit 1 file changed, 3 insertions(+) create mode 100644 mylib.sld $ cd ../../.. $ gsi some/dir/ mylib # execution of mylib without installation mylib library has executed $ gsi -install some/dir/mylib installing some/dir/mylib to /Users/feeley/.gambit_userlib/ $ gsi mylib # execution of mylib after installation mylib library has executed","title":"Installing modules"},{"location":"manual/modules/installing_modules/#installing-modules","text":"When a module is imported, the processing of the import form must locate and read the source code of the module at macro expansion time to determine which names are exported and to what they are mapped. The list of module search directories ( ~~lib followed by ~~userlib by default) is searched to find the module's source code. At execution time the same search algorithm is used to locate and load the module, either in source code form or compiled form. The ~~lib directory is where the system's builtin modules are put when Gambit is installed. The ~~userlib directory is a convenient place where other modules can be installed by the user because locating them does not require extending the list of module search directories.","title":"Installing modules"},{"location":"manual/modules/installing_modules/#module-search-order-reset","text":"","title":"module-search-order-reset!"},{"location":"manual/modules/installing_modules/#module-search-order-add","text":"(module-search-order-reset!) ;; procedure (module-search-order-add! dir) ;; procedure The list of module search directories can be modified using the procedures module-search-order-reset! and module-search-order-add! that respectively clear the list and extend the list with the directory dir which must be a string. The list can also be extended by using the -:search=DIR runtime option or by a command line argument to gsi and gsc that ends with a path separator or a . (see section ##demand-module and ##supply-module forms). For example: $ cat foobar.sld (define-library (foobar) (import (scheme write)) (begin (display \"foobar library has executed\\n\"))) $ gsi Gambit v4.9.4 > (import (foobar)) *** ERROR IN (stdin)@1.9 -- Cannot find library (foobar) > (module-search-order-add! \".\") > (import (foobar)) foobar library has executed > ,q $ gsi -:search=. foobar foobar library has executed $ gsi . foobar foobar library has executed","title":"module-search-order-add!"},{"location":"manual/modules/installing_modules/#module-whitelist-reset","text":"","title":"module-whitelist-reset!"},{"location":"manual/modules/installing_modules/#module-whitelist-add","text":"(module-whitelist-reset!) ;; procedure (module-whitelist-add! source) ;; procedure When modules are installed it is done at the granularity of a package, which is defined as a git repository possibly containing more than one module. For example, if the hosted module github.com/gambit/hello/demo needs to be installed it is all of the code at github.com/gambit/hello that is installed (this includes the three modules github.com/gambit/hello , github.com/gambit/hello/demo , and github.com/gambit/hello/test ). For convenience the runtime system will automatically install in the ~~userlib directory any hosted module that is from a trusted source. The whitelist of trusted sources, which initially contains only github.com/gambit , can be modified using the procedures module-whitelist-reset! and module-whitelist-add! that respectively clear the list and extend the list with the source source which must be a string. The list can also be extended with the -:whitelist=SOURCE runtime option. For example: $ gsi github.com/gambit/hello/demo # auto-install of github.com/gambit/hello package People customarily greet each other when they meet. In English you can say: hello Bob, nice to see you! In French you can say: bonjour Bob, je suis enchant\ufffd! Demo source code: /Users/feeley/.gambit_userlib/github.com/gambit/hello/@/demo.scm $ gsi github.com/feeley/roman/demo # no auto-install because not on whitelist *** ERROR IN ##main -- No such file or directory (load \"github.com/feeley/roman/demo\") $ gsi -:whitelist=github.com/feeley github.com/feeley/roman/demo 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals $ gsi github.com/feeley/roman/demo # OK because module is now installed 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals $ gsi github.com/feeley/roman/test # the test module was also installed *** all tests passed out of a total of 19 tests The use of the runtime option -:whitelist= (with no SOURCE ) will disable the automatic installation of modules, even from github.com/gambit . For example: $ gsi -:whitelist= github.com/gambit/hello/demo *** ERROR IN ##main -- No such file or directory (load \"github.com/gambit/hello/demo\") A manual management of packages is nevertheless possible with the gsi package management operations. These are invoked with the command line options -install , -uninstall , and -update which respectively install, uninstall and update packages. The package management operations accept a list of packages. Packages are installed in ~~userlib which is mapped to ~/.gambit_userlib by default. An optional -dir dir option can be used to install the package in some other directory. For example: $ gsi -install github.com/feeley/roman installing github.com/feeley/roman to /Users/feeley/.gambit_userlib/ $ gsi github.com/feeley/roman/demo 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals $ gsi -uninstall github.com/feeley/roman uninstalling github.com/feeley/roman from /Users/feeley/.gambit_userlib/ $ gsi -install -dir ~/mylibs github.com/feeley/roman installing github.com/feeley/roman to /Users/feeley/mylibs $ gsi ~/mylibs/ github.com/feeley/roman/demo 1 is I in roman numerals 2 is II in roman numerals 4 is IV in roman numerals 8 is VIII in roman numerals 16 is XVI in roman numerals 32 is XXXII in roman numerals 64 is LXIV in roman numerals Local git repositories can also be installed manually with the package management operations using a path to the local repository. This can be useful during the development phase before a library becomes hosted. For example: $ mkdir some $ mkdir some/dir $ mkdir some/dir/mylib $ cd some/dir/mylib $ cat > mylib.sld (define-library (mylib) (import (scheme write)) (begin (display \"mylib library has executed\\n\"))) $ git init Initialized empty Git repository in /Users/feeley/doc/some/dir/mylib/.git/ $ git add mylib.sld $ git commit -m \"first commit\" [master (root-commit) c3f6aff] first commit 1 file changed, 3 insertions(+) create mode 100644 mylib.sld $ cd ../../.. $ gsi some/dir/ mylib # execution of mylib without installation mylib library has executed $ gsi -install some/dir/mylib installing some/dir/mylib to /Users/feeley/.gambit_userlib/ $ gsi mylib # execution of mylib after installation mylib library has executed","title":"module-whitelist-add!"},{"location":"manual/modules/legacy_modules/","text":"Legacy modules The legacy way of modularizing code, which was popular up to R5RS, is still supported by Gambit. It consists of using the load procedure and the include form. We discuss it first to introduce some useful terms and explain the shortcomings of this modularization approach. load (load path) ;;procedure The load procedure's path argument, a string, specifies the location in the file system of a file to load. Loading a file executes the code contained in the file, which is either source code or compiled code (a dynamically loadable object file created by the Gambit Scheme compiler, see the procedure compile-file ). When path has no extension the load procedure first attempts to load the file with no extension as a Scheme source file. If that file doesn\u2019t exist it will search for both a source file and an object file. The object file's path is obtained by adding to path a .on extension with the highest consecutive version number starting with 1. The source file's path is obtained by adding to path the file extensions .sld , .scm and .six (the first found is the source file). If both a source file and an object file exist, then the one with the latest modification time is loaded. Otherwise the file that is found is loaded. When path has an extension, the load procedure will only attempt to load the file with that specific extension. After executing the code contained in the file, the load procedure returns the path of the file that was loaded. When a source code file is loaded its extension is used to determine how it is parsed, unless the file's first line is a special script line (see Scheme scripts ). When the extension is different from .six the content of the file is parsed using the normal Scheme prefix syntax. When the extension is .six the content of the file is parsed using the Scheme infix syntax extension (see Scheme infix syntax extension ). Due to operating system limitations, loading a given .on object file more than once in the same process is not supported. It is possible however to recompile the source code file to create a new .om object file with m > n and load that object file. For example: $ cat my-mod.scm (define (double x) (* x 2)) (display \"my-mod has finished loading!!!\\n\") $ gsi Gambit v4.9.4 > (load \"my-mod\") my-mod has finished loading!!! \"/Users/feeley/gambit/doc/my-mod.scm\" > (double 21) 42 > (load \"my-mod.scm\") my-mod has finished loading!!! \"/Users/feeley/gambit/doc/my-mod.scm\" > ,q $ gsc my-mod $ gsi Gambit v4.9.4 > (load \"my-mod\") my-mod has finished loading!!! \"/Users/feeley/gambit/doc/my-mod.o1\" > (double 21) 42 > (load \"my-mod\") *** ERROR IN (console)@3.1 -- Can't load a given object file more than once (load \"my-mod\") 1> Note that any macro definition in the loaded file is local to the file and is not visible from the REPL or other files that loaded this file. The include form can be used to access the macros defined in another file. include ##include (include path) ;; special form (##include path) ;; special form The path argument must be a string specifying the location of an existing file containing Scheme source code. Relative paths are relative to the file that contains the include form. The include special form splices the content of the specified source file. This form can only appear where a define form is acceptable, i.e. at top level or in the body of a binding form. For example: $ cat my-defs.scm (define-macro (double x) `(* ,x 2)) (define (quad y) (double (double y))) (display \"howdy!\\n\") $ cat my-includer.scm (define (f x) (include \"my-defs.scm\") (+ 1 (quad x))) $ gsi Gambit v4.9.4 > (load \"my-includer\") \"/Users/feeley/udem-dlteam/gambit/my-includer.scm\" > (f 10) howdy! 41 > (f 20) howdy! 81 With legacy modularization, the code that implements the module's functionality is put in a source code file and this module is accessed by other code by using a load or include of that file. Here is an example of an angle0 module that is used by an app0 main program: ;;;---------------------------------------- file: angle0/angle0.scm (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app0.scm (load \"angle0/angle0.scm\") ;; or (include \"angle0/angle0.scm\") (println \"90 degrees is \" (deg->rad 90) \" radians\") ;; run with: gsi app0.scm Issues This modularization approach has a number of issues: It hinders code sharing among different programs and users because a shared module's location in the filesystem must be known to all modules loading or including it. In the above example the path \"angle0/angle0.scm\" is relative so the load procedure will resolve the path incorrectly if the program executes (current-directory \"...\") before calling load . When a module is needed by more than one other module there will be code duplication, redundant evaluation/compilation, and probably incorrect execution if the module has side effects that should only happen once (displaying a message, opening a database on the filesystem, initializing the module's state, etc). Moreover, when the module has been compiled to an object file it can't be loaded more than once. All the definitions of a module will be put in the global environment (including top level macro definitions when using a top level include but not when using load ). This pollutes the global environment with definitions that were not intended to be exported by the module's designer, such as the variable factor in the above example that is only meant to be used by the deg->rad and rad->deg procedures. Other modules may also need a factor variable internally, for instance to convert distances from the metric to the english system. Nothing prevents such accidental clashes.","title":"Legacy modules"},{"location":"manual/modules/legacy_modules/#legacy-modules","text":"The legacy way of modularizing code, which was popular up to R5RS, is still supported by Gambit. It consists of using the load procedure and the include form. We discuss it first to introduce some useful terms and explain the shortcomings of this modularization approach.","title":"Legacy modules"},{"location":"manual/modules/legacy_modules/#load","text":"(load path) ;;procedure The load procedure's path argument, a string, specifies the location in the file system of a file to load. Loading a file executes the code contained in the file, which is either source code or compiled code (a dynamically loadable object file created by the Gambit Scheme compiler, see the procedure compile-file ). When path has no extension the load procedure first attempts to load the file with no extension as a Scheme source file. If that file doesn\u2019t exist it will search for both a source file and an object file. The object file's path is obtained by adding to path a .on extension with the highest consecutive version number starting with 1. The source file's path is obtained by adding to path the file extensions .sld , .scm and .six (the first found is the source file). If both a source file and an object file exist, then the one with the latest modification time is loaded. Otherwise the file that is found is loaded. When path has an extension, the load procedure will only attempt to load the file with that specific extension. After executing the code contained in the file, the load procedure returns the path of the file that was loaded. When a source code file is loaded its extension is used to determine how it is parsed, unless the file's first line is a special script line (see Scheme scripts ). When the extension is different from .six the content of the file is parsed using the normal Scheme prefix syntax. When the extension is .six the content of the file is parsed using the Scheme infix syntax extension (see Scheme infix syntax extension ). Due to operating system limitations, loading a given .on object file more than once in the same process is not supported. It is possible however to recompile the source code file to create a new .om object file with m > n and load that object file. For example: $ cat my-mod.scm (define (double x) (* x 2)) (display \"my-mod has finished loading!!!\\n\") $ gsi Gambit v4.9.4 > (load \"my-mod\") my-mod has finished loading!!! \"/Users/feeley/gambit/doc/my-mod.scm\" > (double 21) 42 > (load \"my-mod.scm\") my-mod has finished loading!!! \"/Users/feeley/gambit/doc/my-mod.scm\" > ,q $ gsc my-mod $ gsi Gambit v4.9.4 > (load \"my-mod\") my-mod has finished loading!!! \"/Users/feeley/gambit/doc/my-mod.o1\" > (double 21) 42 > (load \"my-mod\") *** ERROR IN (console)@3.1 -- Can't load a given object file more than once (load \"my-mod\") 1> Note that any macro definition in the loaded file is local to the file and is not visible from the REPL or other files that loaded this file. The include form can be used to access the macros defined in another file.","title":"load"},{"location":"manual/modules/legacy_modules/#include","text":"","title":"include"},{"location":"manual/modules/legacy_modules/#include_1","text":"(include path) ;; special form (##include path) ;; special form The path argument must be a string specifying the location of an existing file containing Scheme source code. Relative paths are relative to the file that contains the include form. The include special form splices the content of the specified source file. This form can only appear where a define form is acceptable, i.e. at top level or in the body of a binding form. For example: $ cat my-defs.scm (define-macro (double x) `(* ,x 2)) (define (quad y) (double (double y))) (display \"howdy!\\n\") $ cat my-includer.scm (define (f x) (include \"my-defs.scm\") (+ 1 (quad x))) $ gsi Gambit v4.9.4 > (load \"my-includer\") \"/Users/feeley/udem-dlteam/gambit/my-includer.scm\" > (f 10) howdy! 41 > (f 20) howdy! 81 With legacy modularization, the code that implements the module's functionality is put in a source code file and this module is accessed by other code by using a load or include of that file. Here is an example of an angle0 module that is used by an app0 main program: ;;;---------------------------------------- file: angle0/angle0.scm (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app0.scm (load \"angle0/angle0.scm\") ;; or (include \"angle0/angle0.scm\") (println \"90 degrees is \" (deg->rad 90) \" radians\") ;; run with: gsi app0.scm","title":"##include"},{"location":"manual/modules/legacy_modules/#issues","text":"This modularization approach has a number of issues: It hinders code sharing among different programs and users because a shared module's location in the filesystem must be known to all modules loading or including it. In the above example the path \"angle0/angle0.scm\" is relative so the load procedure will resolve the path incorrectly if the program executes (current-directory \"...\") before calling load . When a module is needed by more than one other module there will be code duplication, redundant evaluation/compilation, and probably incorrect execution if the module has side effects that should only happen once (displaying a message, opening a database on the filesystem, initializing the module's state, etc). Moreover, when the module has been compiled to an object file it can't be loaded more than once. All the definitions of a module will be put in the global environment (including top level macro definitions when using a top level include but not when using load ). This pollutes the global environment with definitions that were not intended to be exported by the module's designer, such as the variable factor in the above example that is only meant to be used by the deg->rad and rad->deg procedures. Other modules may also need a factor variable internally, for instance to convert distances from the metric to the english system. Nothing prevents such accidental clashes.","title":"Issues"},{"location":"manual/modules/primitive_modules/","text":"Primitive modules Module forms ##demand-module ##supply-module (##demand-module mod) ;; special form (##supply-module mod) ;; special form The ##demand-module form offers a way to avoid the issues of multiple loading and filesystem localization of modules. The sole parameter of this form is an (unevaluated) symbol mod that identifies the module on which the module containing the ##demand-module depends. When a module A contains a (##demand-module B) , Gambit's runtime system will ensure that module B is loaded before module A is loaded. It also registers the module in a cache when it is loaded so that it is loaded exactly once. In other words the ##demand-module form expresses the requirement that the current module needs the functionality of another module. A module can contain multiple uses of ##demand-module and possibly more than once for a given module. The ##demand-module form can appear anywhere a define can appear. There is also a related ##supply-module form that should appear in the module to declare the module's identity. Gambit's runtime system searches for modules in various directories, by default in ~~lib then in ~~userlib (which maps to ~/.gambit_userlib by default). These two directories are where builtin modules and user installed modules are located respectively. The source code for a module M is searched, in each of the module search order directories, first in M/M.ext and then in M.ext , where .ext is one of the acceptable Scheme source code file extensions ( .sld , .scm , .six , etc). The list of module search order directories can be extended with the -:search=DIR runtime option or by a command line argument to gsi and gsc that ends with a path separator or a . . With ##demand-module and ##supply-module the previous example can be rewritten like this: ;;;---------------------------------------- file: angle1/angle1.scm (##supply-module angle1) ;; declare that this is the module angle1 (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app1.scm (##demand-module angle1) ;; declare dependency on module angle1 (println \"90 degrees is \" (deg->rad 90) \" radians\") ;; run with either: gsi . app1.scm ;; or: gsi -:search=. app1.scm ;; ;; or install the angle1 module to avoid the . and -:search=. namespace ##namespace import ##import (namespace ...) ;; special form (##namespace ...) ;; special form (import module-ref) ;; special form (##import module-ref) ;; special form The ##namespace form offers a way to avoid name clashes by specifying a mapping between identifiers. The mapping it specifies has the same scope as a macro definition: it applies to the rest of a source code file if it is at top level, or applies to the rest of the body of a binding form if it is used in the body of a binding form. The call (##namespace (\"foo#\" a b)) specifies that a reference to a becomes foo#a and a reference to b becomes foo#b . Here foo# is the namespace. Finer control over the mapping is possible by using aliases as in (##namespace (\"foo#\" (a bar) b)) which maps a to foo#bar and b to foo#b . Multiple namespace specifications can appear in the body of the ##namespace form. When no identifiers are specified, the mapping maps all identifiers not containing # to the namespace. For example in the scope of (##namespace (\"foo#\")) the reference x maps to foo#x and the reference bar#x remains unchanged. Given that modules are identified by a unique symbol, the global names defined by a module M can be put in the namespace M# to avoid name clashes with other modules. The source code of module M and the modules depending on M can explicitly prefix the global names defined by M with M# or use a ##namespace form to make this prefixing implicit. By convention the namespace definition for the identifiers exported by module M is specified in the source code file M#.scm in the same directory as the M.scm file. Using this convention and the include and ##namespace forms, the previous example can be rewritten like this: ;;;---------------------------------------- file: angle2/angle2#.scm (##namespace (\"angle2#\" deg->rad rad->deg)) ;;;---------------------------------------- file: angle2/angle2.scm (include \"angle2#.scm\") (##namespace (\"angle2#\" factor)) (##supply-module angle2) (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app2.scm (include \"angle2/angle2#.scm\") (##demand-module angle2) (println \"90 degrees is \" (deg->rad 90) \" radians\") Note that the parameters of the two include forms are different, but this is correct because the paths are relative to the file containing the include form. However the module localization problem has been reintroduced for the file angle2/angle2#.scm . This problem can be solved using the ##import form that combines the semantics of the include and ##demand-module forms. The call (##import M) will use the module search order directories to locate the source code file of module M and will expand to an include of the \"hash\" file M#.ext if it exists in the same directory, and a (##demand-module M) . In addition, a builtin module gambit exists that contains all the global names exported by the runtime library. The gambit module's \"hash\" file gambit#.scm contains a ##namespace form that lists all the names exported by the runtime library in an empty namespace: ;;;---------------------------------------- file: ~~lib/gambit#.scm (##namespace (\"\" define if quote set! cons car cdr + - * / ;; etc Using the gambit module and the ##import form, the previous example can be rewritten like this: ;;;---------------------------------------- file: angle3/angle3#.scm (##namespace (\"angle3#\" deg->rad rad->deg)) ;;;---------------------------------------- file: angle3/angle3.scm (##namespace (\"angle3#\")) ;; map all identifiers to angle3# namespace (##import gambit) ;; except those defined by Gambit's RTS (##supply-module angle3) (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app3.scm (##import angle3) (println \"90 degrees is \" (deg->rad 90) \" radians\") In this example the (##import angle3) takes care of the namespace mapping and the loading of angle3.scm because it is equivalent to: (begin (##include \"angle3/angle3#.scm\") (##demand-module angle3)) Macros In addition to procedures, a module M may export macros. The file M#.scm is the designated place to put exported macro definitions. These macro definitions will essentially be copied at the point where the ##import of the module is done. Macros that are needed strictly for the implementation of a module may be defined in the file M.scm and these macro definitions will not be visible elsewhere. Note that the macros defined with define-macro are not hygienic, so the macro definition writer should take care to explicitly indicate what identifiers resolve to using fully qualified identifiers (i.e. containing a # sign). To explain these issues, lets extend our example module in the following ways. First we want the module to export the macros sind and asind that are like the sin and asin procedures but use degrees instead of radians. Note that it would be a better design for sind and asind to be procedures, but we'll implement them as macros for the sake of the example. Second we want the procedures deg->rad and rad->deg to check that their argument is a real number using a check-real macro. In a setting where name clashes are not an issue these macros can be defined as follows: (define-macro (sind x) `(sin (deg->rad ,x))) (define-macro (asind x) `(rad->deg (asin ,x))) (define-macro (check-real x y) `(if (real? ,x) ,y (error \"not real!\"))) Name clashes will occur when the locations where these macros are called are in the scope of new bindings for sin , deg->rad , if , error , etc which are identifiers used in the expanded code. A name clash can also happen for the name define-macro itself. To remove the possibility of name clashes the ##namespace form and fully qualified identifiers can be used. All the Gambit special forms, such as let , if , and define-macro , have a fully qualified version ( ##let , ##if , and ##define-macro ). Gambit predefined procedures, such as sin , real? , and error , don't necessarily have a fully qualified version (some do and some don't) but an empty namespace definition in a ##let form can be used to avoid the clash, i.e. (##let () (##namespace (\"\") sin)) refers to the global variable sin whatever scope it is in. With these forms our example can be written like this: ;;;---------------------------------------- file: angle4/angle4#.scm (##namespace (\"angle4#\" deg->rad rad->deg)) (##define-macro (sind x) `((##let () (##namespace (\"\")) sin) (angle4#deg->rad ,x))) (##define-macro (asind x) `(angle4#rad->deg ((##let () (##namespace (\"\")) asin) ,x))) ;;;---------------------------------------- file: angle4/angle4.scm (##namespace (\"angle4#\")) ;; map all identifiers to angle4# namespace (##import gambit) ;; except those defined by Gambit's RTS (##supply-module angle4) (##define-macro (check-real x y) `(##if ((##let () (##namespace (\"\")) real?) ,x) ,y ((##let () (##namespace (\"\")) error) \"not real!\"))) (define factor (/ (atan 1) 45)) (define (deg->rad x) (check-real x (* x factor))) (define (rad->deg x) (check-real x (/ x factor))) ;;;---------------------------------------- file: app4.scm (##import angle4) (println \"90 degrees is \" (deg->rad 90) \" radians\") (println \"sind(90) is \" (sind 90))","title":"Primitive modules"},{"location":"manual/modules/primitive_modules/#primitive-modules","text":"","title":"Primitive modules"},{"location":"manual/modules/primitive_modules/#module-forms","text":"","title":"Module forms"},{"location":"manual/modules/primitive_modules/#demand-module","text":"","title":"##demand-module"},{"location":"manual/modules/primitive_modules/#supply-module","text":"(##demand-module mod) ;; special form (##supply-module mod) ;; special form The ##demand-module form offers a way to avoid the issues of multiple loading and filesystem localization of modules. The sole parameter of this form is an (unevaluated) symbol mod that identifies the module on which the module containing the ##demand-module depends. When a module A contains a (##demand-module B) , Gambit's runtime system will ensure that module B is loaded before module A is loaded. It also registers the module in a cache when it is loaded so that it is loaded exactly once. In other words the ##demand-module form expresses the requirement that the current module needs the functionality of another module. A module can contain multiple uses of ##demand-module and possibly more than once for a given module. The ##demand-module form can appear anywhere a define can appear. There is also a related ##supply-module form that should appear in the module to declare the module's identity. Gambit's runtime system searches for modules in various directories, by default in ~~lib then in ~~userlib (which maps to ~/.gambit_userlib by default). These two directories are where builtin modules and user installed modules are located respectively. The source code for a module M is searched, in each of the module search order directories, first in M/M.ext and then in M.ext , where .ext is one of the acceptable Scheme source code file extensions ( .sld , .scm , .six , etc). The list of module search order directories can be extended with the -:search=DIR runtime option or by a command line argument to gsi and gsc that ends with a path separator or a . . With ##demand-module and ##supply-module the previous example can be rewritten like this: ;;;---------------------------------------- file: angle1/angle1.scm (##supply-module angle1) ;; declare that this is the module angle1 (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app1.scm (##demand-module angle1) ;; declare dependency on module angle1 (println \"90 degrees is \" (deg->rad 90) \" radians\") ;; run with either: gsi . app1.scm ;; or: gsi -:search=. app1.scm ;; ;; or install the angle1 module to avoid the . and -:search=.","title":"##supply-module"},{"location":"manual/modules/primitive_modules/#namespace","text":"","title":"namespace"},{"location":"manual/modules/primitive_modules/#namespace_1","text":"","title":"##namespace"},{"location":"manual/modules/primitive_modules/#import","text":"","title":"import"},{"location":"manual/modules/primitive_modules/#import_1","text":"(namespace ...) ;; special form (##namespace ...) ;; special form (import module-ref) ;; special form (##import module-ref) ;; special form The ##namespace form offers a way to avoid name clashes by specifying a mapping between identifiers. The mapping it specifies has the same scope as a macro definition: it applies to the rest of a source code file if it is at top level, or applies to the rest of the body of a binding form if it is used in the body of a binding form. The call (##namespace (\"foo#\" a b)) specifies that a reference to a becomes foo#a and a reference to b becomes foo#b . Here foo# is the namespace. Finer control over the mapping is possible by using aliases as in (##namespace (\"foo#\" (a bar) b)) which maps a to foo#bar and b to foo#b . Multiple namespace specifications can appear in the body of the ##namespace form. When no identifiers are specified, the mapping maps all identifiers not containing # to the namespace. For example in the scope of (##namespace (\"foo#\")) the reference x maps to foo#x and the reference bar#x remains unchanged. Given that modules are identified by a unique symbol, the global names defined by a module M can be put in the namespace M# to avoid name clashes with other modules. The source code of module M and the modules depending on M can explicitly prefix the global names defined by M with M# or use a ##namespace form to make this prefixing implicit. By convention the namespace definition for the identifiers exported by module M is specified in the source code file M#.scm in the same directory as the M.scm file. Using this convention and the include and ##namespace forms, the previous example can be rewritten like this: ;;;---------------------------------------- file: angle2/angle2#.scm (##namespace (\"angle2#\" deg->rad rad->deg)) ;;;---------------------------------------- file: angle2/angle2.scm (include \"angle2#.scm\") (##namespace (\"angle2#\" factor)) (##supply-module angle2) (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app2.scm (include \"angle2/angle2#.scm\") (##demand-module angle2) (println \"90 degrees is \" (deg->rad 90) \" radians\") Note that the parameters of the two include forms are different, but this is correct because the paths are relative to the file containing the include form. However the module localization problem has been reintroduced for the file angle2/angle2#.scm . This problem can be solved using the ##import form that combines the semantics of the include and ##demand-module forms. The call (##import M) will use the module search order directories to locate the source code file of module M and will expand to an include of the \"hash\" file M#.ext if it exists in the same directory, and a (##demand-module M) . In addition, a builtin module gambit exists that contains all the global names exported by the runtime library. The gambit module's \"hash\" file gambit#.scm contains a ##namespace form that lists all the names exported by the runtime library in an empty namespace: ;;;---------------------------------------- file: ~~lib/gambit#.scm (##namespace (\"\" define if quote set! cons car cdr + - * / ;; etc Using the gambit module and the ##import form, the previous example can be rewritten like this: ;;;---------------------------------------- file: angle3/angle3#.scm (##namespace (\"angle3#\" deg->rad rad->deg)) ;;;---------------------------------------- file: angle3/angle3.scm (##namespace (\"angle3#\")) ;; map all identifiers to angle3# namespace (##import gambit) ;; except those defined by Gambit's RTS (##supply-module angle3) (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) ;;;---------------------------------------- file: app3.scm (##import angle3) (println \"90 degrees is \" (deg->rad 90) \" radians\") In this example the (##import angle3) takes care of the namespace mapping and the loading of angle3.scm because it is equivalent to: (begin (##include \"angle3/angle3#.scm\") (##demand-module angle3))","title":"##import"},{"location":"manual/modules/primitive_modules/#macros","text":"In addition to procedures, a module M may export macros. The file M#.scm is the designated place to put exported macro definitions. These macro definitions will essentially be copied at the point where the ##import of the module is done. Macros that are needed strictly for the implementation of a module may be defined in the file M.scm and these macro definitions will not be visible elsewhere. Note that the macros defined with define-macro are not hygienic, so the macro definition writer should take care to explicitly indicate what identifiers resolve to using fully qualified identifiers (i.e. containing a # sign). To explain these issues, lets extend our example module in the following ways. First we want the module to export the macros sind and asind that are like the sin and asin procedures but use degrees instead of radians. Note that it would be a better design for sind and asind to be procedures, but we'll implement them as macros for the sake of the example. Second we want the procedures deg->rad and rad->deg to check that their argument is a real number using a check-real macro. In a setting where name clashes are not an issue these macros can be defined as follows: (define-macro (sind x) `(sin (deg->rad ,x))) (define-macro (asind x) `(rad->deg (asin ,x))) (define-macro (check-real x y) `(if (real? ,x) ,y (error \"not real!\"))) Name clashes will occur when the locations where these macros are called are in the scope of new bindings for sin , deg->rad , if , error , etc which are identifiers used in the expanded code. A name clash can also happen for the name define-macro itself. To remove the possibility of name clashes the ##namespace form and fully qualified identifiers can be used. All the Gambit special forms, such as let , if , and define-macro , have a fully qualified version ( ##let , ##if , and ##define-macro ). Gambit predefined procedures, such as sin , real? , and error , don't necessarily have a fully qualified version (some do and some don't) but an empty namespace definition in a ##let form can be used to avoid the clash, i.e. (##let () (##namespace (\"\") sin)) refers to the global variable sin whatever scope it is in. With these forms our example can be written like this: ;;;---------------------------------------- file: angle4/angle4#.scm (##namespace (\"angle4#\" deg->rad rad->deg)) (##define-macro (sind x) `((##let () (##namespace (\"\")) sin) (angle4#deg->rad ,x))) (##define-macro (asind x) `(angle4#rad->deg ((##let () (##namespace (\"\")) asin) ,x))) ;;;---------------------------------------- file: angle4/angle4.scm (##namespace (\"angle4#\")) ;; map all identifiers to angle4# namespace (##import gambit) ;; except those defined by Gambit's RTS (##supply-module angle4) (##define-macro (check-real x y) `(##if ((##let () (##namespace (\"\")) real?) ,x) ,y ((##let () (##namespace (\"\")) error) \"not real!\"))) (define factor (/ (atan 1) 45)) (define (deg->rad x) (check-real x (* x factor))) (define (rad->deg x) (check-real x (/ x factor))) ;;;---------------------------------------- file: app4.scm (##import angle4) (println \"90 degrees is \" (deg->rad 90) \" radians\") (println \"sind(90) is \" (sind 90))","title":"Macros"},{"location":"manual/modules/primitive_procedures/","text":"Primitive procedures This documentation needs work, cleanup or clarification. Identifiers with a ## prefix are not valid identifiers according to RnRS. This means that code containing ## prefixed identifiers cannot be processed by and shared with other Scheme implementations. They are hard to read by people that aren't used to that extension. Moreover the code lacks abstraction and safety because using ##car rather than car has a specific meaning: avoiding type checks. Consequently it is hard to \"turn on\" safe execution of the code when it needs to be debugged. Many parts of the runtime library are expressed at a low level of abstraction (with ## prefixed identifiers) even when not required. For those reasons ## prefixed identifiers should be used sparingly in new code, and existing code should gradually be rewritten to avoid them. The primitive operations which are used to build higher-level operations are all defined as procedures with a ## prefix. primitive standard define-procedure define-primitive The file ~~lib/_gambit#.scm contains the definition of the primitive macro whose purpose is to abstract from the ## prefix. The call (primitive foo) is equivalent to ##foo and (primitive (foo a b)) is equivalent to (##foo a b) . The file ~~lib/_gambit#.scm also contains the definition of the standard macro whose purpose is similar, but forces the use of the empty namespace. The call (standard +) is equivalent to (##let () (##namespace (\"\" +)) +) and (standard (+ a b)) is equivalent to ((##let () (##namespace (\"\" +)) +) a b) . Code that uses the primitive and standard macros can be ported to other Scheme implementations by defining implementation specific primitive and standard macros that implement the appropriate mapping for that implementation. The file ~~lib/_gambit#.scm also contains definitions for the define-procedure and define-primitive macros. The primitive and standard macros work in tandem with the define-procedure and define-primitive macros and the ~~lib/gambit/prim/prim#.scm file and (gambit prim) library. The file ~~lib/gambit/prim/prim#.scm contains namespace declarations that map operations exported by the runtime library without a ## prefix to their ## prefixed names if this preserves the meaning of the operation but possibly (and usually) with no type checking. The (gambit prim) library is similar but in the form of a R7RS library. For example the following code: (include \"~~lib/gambit/prim/prim#.scm\") (define (foo x) (square (car x))) (println (foo (bar 0.5))) (pp \"hello\") is equivalent to this code: (##define (foo x) (##square (##car x))) (##println (foo (bar 0.5))) (##unimplemented#pp \"hello\") The namespace declarations in ~~lib/gambit/prim/prim#.scm have caused a mapping of square to ##square , car to ##car and println to ##println because those primitives perform the same operations (when the code has no errors). Note that foo and bar have remained the same, because they are not procedures exported by the runtime library, and pp has been mapped to ##unimplemented#pp because pp is a procedure exported by the runtime library but ##pp is not defined. Having unimplemented in the name helps catch situations where the programmer expected a primitive operation to exist but this isn't the case. The define-procedure macro does two things. It supports type annotations in the parameter list and it inserts a (include \"~~lib/gambit/prim/prim#.scm\") in the body so that primitive operations can be used without the ## prefix. Type checking and automatic forcing of promise arguments are also added implicitly. The macro define-primitive is similar, but the procedure defined is implicitly prefixed with ## . So all of these things work together to abstract away from the concept of primitive operations. Primitives are implemented using procedures with a ## prefix, but other Scheme implementations could do it differently. Finally, there's the (declare-safe-define-procedure <bool>) macro that can be used to enable/disable the mapping of names exported by the runtime library to the corresponding primitives. This is useful to enable type checks in the code. For example the following definition: (define-procedure (foo (x vector)) (vector-ref x 5)) which expands to (define (foo x) (macro-check-vector x '(1 . x) (foo x) (##vector-ref x 5))) which expands to (define (foo x) (if (##vector? x) (##vector-ref x 5) (##fail-check-vector '(1 . x) foo x))) If the code is in the scope of a (declare-safe-define-procedure #t) then it is vector-ref that is called instead of ##vector-ref which will both check that x is a vector (redundantly) and that the index is in range. However, the use of ##vector-ref can be forced by writing the code with an explicit use of the primitive macro: (define-procedure (foo (x vector)) (primitive (vector-ref x 5))) The expectation is that the primitive special form will be used sparingly. Searching the source code for the pattern \"(primitive\" is a good way to find potentially unsafe code. Type specifiers Here is a list of the available type specifiers for a define-procedure parameter x and the associated constraint on the value of x . Note that there is no direct way for checking for a \"list\" or \"list of elements of type T\". A procedure taking a list parameter will likely iterate on the list's pairs going from cdr to cdr until a non-pair is found. Then a check for the empty list with (macro-check-proper-list-null lst <arg-id> (<procedure-name> <args>...) <body>) will check that the parameter is a proper list (i.e. that it ends with the empty list). Basic types (other than numbers) boolean : x is a boolean char : x is a character pair : x is a pair procedure : x is a procedure string : x is a string symbol : x is a symbol vector : x is a vector Numbers number : x is a number (possibly complex, rational, etc) real : x is a real number (any number except complex) fixnum : x is a fixnum and -2^(W-3) <= x <= 2^(W-3) - 1 (fixnum-range lo hi) : x is a fixnum and lo <= x < hi (fixnum-range-incl lo hi) : x is a fixnum and lo <= x <= hi index : x is a fixnum and 0 <= x (index-range lo hi) : x is a fixnum and 0 <= lo <= x < hi (index-range-incl lo hi) : x is a fixnum and 0 <= lo <= x <= hi exact-signed-int8 : x is an exact integer, -128 <= x <= 127 exact-signed-int16 : x is an exact integer n , -32768 <= x <= 32767 exact-signed-int32 : x is an exact integer n , -2^31 <= x <= 2^31 - 1 exact-signed-int64 : x is an exact integer n , -2^63 <= x <= 2^63 - 1 exact-unsigned-int8 : x is an exact integer n , 0 <= x <= 255 exact-unsigned-int16 : x is an exact integer n , 0 <= x <= 65535 exact-unsigned-int32 : x is an exact integer n , 0 <= x <= 2^32 - 1 exact-unsigned-int64 : x is an exact integer n , 0 <= x <= 2^64 - 1 flonum : x is a flonum, exception mentions FLONUM inexact-real : x is a flonum, exception mentions Inexact REAL inexact-real-list : x is a flonum, exception mentions Inexact REAL LIST Time types time : x is a time object absrel-time : x is a real or a time object absrel-time-or-false : x is #f or a real or a time object Ports port : x is a port (input, output, or input-output) input-port : x is an input port output-port : x is an output port object-input-port : x is an object input port object-output-port : x is an object output port vector-input-port : x is a vector input port vector-output-port : x is a vector output port character-input-port : x is a character input port character-output-port : x is a character output port string-input-port : x is a string input port string-output-port : x is a string output port byte-port : x is a byte port (input, output, or input-output) byte-input-port : x is a byte input port byte-output-port : x is a byte output port u8vector-input-port : x is a u8vector input port u8vector-output-port : x is a u8vector output port device-input-port : x is a device intput port device-output-port : x is a device output port process-port : x is a process port tcp-client-port : x is a tcp-client port tcp-server-port : x is a tcp-server port udp-port : x is a udp port udp-input-port : x is a udp input port udp-output-port : x is a udp output port tty-port : x is a tty port List and vector variants of the above list : no type checking (a non-null non-pair object is in fact a degenerate dotted list), exception mentions LIST proper-list : no type checking (code traversing the list must check for a proper-list), exception mentions PROPER LIST proper-list-null : x is the empty list, exception mentions PROPER LIST proper-or-circular-list : no type checking (code traversing the list must check for a proper-list or circular-list), exception mentions PROPER or CIRCULAR LIST proper-or-circular-list-null : x is the empty list, exception mentions PROPER LIST char-list : x is a character, exception mentions CHARACTER LIST char-vector : x is a character, exception mentions CHARACTER VECTOR pair-list : x is a pair, exception mentions PAIR LIST exact-unsigned-int8-list-exact-unsigned-int8 : x is an exact-unsigned-int8 , exception mentions INTEGER LIST exact-unsigned-int16-list-exact-unsigned-int16 : x is an exact-unsigned-int16 , exception mentions INTEGER LIST exact-unsigned-int32-list-exact-unsigned-int32 : x is an exact-unsigned-int32, exception mentions INTEGER LIST exact-unsigned-int64-list-exact-unsigned-int64 : x is an exact-unsigned-int64, exception mentions INTEGER LIST exact-signed-int8-list-exact-signed-int8 : x is an exact-signed-int8, exception mentions INTEGER LIST exact-signed-int16-list-exact-signed-int16 : x is an exact-signed-int16, exception mentions INTEGER LIST exact-signed-int32-list-exact-signed-int32 : x is an exact-signed-int32, exception mentions INTEGER LIST exact-signed-int64-list-exact-signed-int64 : x is an exact-signed-int64, exception mentions INTEGER LIST Gambit types error-exception : x is an error-exception object box : x is a box condvar : x is a condition variable f32vector : x is a f32vector f64vector : x is a f64vector foreign : x is a foreign object keyword : x is a keyword mutex : x is a mutex processor : x is a processor object s16vector : x is a s16vector s32vector : x is a s32vector s64vector : x is a s64vector s8vector : x is a s8vector table : x is a table tgroup : x is a thread group thread : x is a thread u16vector : x is a u16vector u32vector : x is a u32vector u64vector : x is a u64vector u8vector : x is a u8vector will : x is a will continuation : x is a continuation object random-source : x is a random-source object readtable : x is a readtable type : x is a structure type descriptor mutable : x is a mutable object Others not-initialized-thread not-started-thread not-started-thread-given-initialized string-or-ip-address string-or-nonnegative-fixnum","title":"Primitive procedures"},{"location":"manual/modules/primitive_procedures/#primitive-procedures","text":"This documentation needs work, cleanup or clarification. Identifiers with a ## prefix are not valid identifiers according to RnRS. This means that code containing ## prefixed identifiers cannot be processed by and shared with other Scheme implementations. They are hard to read by people that aren't used to that extension. Moreover the code lacks abstraction and safety because using ##car rather than car has a specific meaning: avoiding type checks. Consequently it is hard to \"turn on\" safe execution of the code when it needs to be debugged. Many parts of the runtime library are expressed at a low level of abstraction (with ## prefixed identifiers) even when not required. For those reasons ## prefixed identifiers should be used sparingly in new code, and existing code should gradually be rewritten to avoid them. The primitive operations which are used to build higher-level operations are all defined as procedures with a ## prefix.","title":"Primitive procedures"},{"location":"manual/modules/primitive_procedures/#primitive","text":"","title":"primitive"},{"location":"manual/modules/primitive_procedures/#standard","text":"","title":"standard"},{"location":"manual/modules/primitive_procedures/#define-procedure","text":"","title":"define-procedure"},{"location":"manual/modules/primitive_procedures/#define-primitive","text":"The file ~~lib/_gambit#.scm contains the definition of the primitive macro whose purpose is to abstract from the ## prefix. The call (primitive foo) is equivalent to ##foo and (primitive (foo a b)) is equivalent to (##foo a b) . The file ~~lib/_gambit#.scm also contains the definition of the standard macro whose purpose is similar, but forces the use of the empty namespace. The call (standard +) is equivalent to (##let () (##namespace (\"\" +)) +) and (standard (+ a b)) is equivalent to ((##let () (##namespace (\"\" +)) +) a b) . Code that uses the primitive and standard macros can be ported to other Scheme implementations by defining implementation specific primitive and standard macros that implement the appropriate mapping for that implementation. The file ~~lib/_gambit#.scm also contains definitions for the define-procedure and define-primitive macros. The primitive and standard macros work in tandem with the define-procedure and define-primitive macros and the ~~lib/gambit/prim/prim#.scm file and (gambit prim) library. The file ~~lib/gambit/prim/prim#.scm contains namespace declarations that map operations exported by the runtime library without a ## prefix to their ## prefixed names if this preserves the meaning of the operation but possibly (and usually) with no type checking. The (gambit prim) library is similar but in the form of a R7RS library. For example the following code: (include \"~~lib/gambit/prim/prim#.scm\") (define (foo x) (square (car x))) (println (foo (bar 0.5))) (pp \"hello\") is equivalent to this code: (##define (foo x) (##square (##car x))) (##println (foo (bar 0.5))) (##unimplemented#pp \"hello\") The namespace declarations in ~~lib/gambit/prim/prim#.scm have caused a mapping of square to ##square , car to ##car and println to ##println because those primitives perform the same operations (when the code has no errors). Note that foo and bar have remained the same, because they are not procedures exported by the runtime library, and pp has been mapped to ##unimplemented#pp because pp is a procedure exported by the runtime library but ##pp is not defined. Having unimplemented in the name helps catch situations where the programmer expected a primitive operation to exist but this isn't the case. The define-procedure macro does two things. It supports type annotations in the parameter list and it inserts a (include \"~~lib/gambit/prim/prim#.scm\") in the body so that primitive operations can be used without the ## prefix. Type checking and automatic forcing of promise arguments are also added implicitly. The macro define-primitive is similar, but the procedure defined is implicitly prefixed with ## . So all of these things work together to abstract away from the concept of primitive operations. Primitives are implemented using procedures with a ## prefix, but other Scheme implementations could do it differently. Finally, there's the (declare-safe-define-procedure <bool>) macro that can be used to enable/disable the mapping of names exported by the runtime library to the corresponding primitives. This is useful to enable type checks in the code. For example the following definition: (define-procedure (foo (x vector)) (vector-ref x 5)) which expands to (define (foo x) (macro-check-vector x '(1 . x) (foo x) (##vector-ref x 5))) which expands to (define (foo x) (if (##vector? x) (##vector-ref x 5) (##fail-check-vector '(1 . x) foo x))) If the code is in the scope of a (declare-safe-define-procedure #t) then it is vector-ref that is called instead of ##vector-ref which will both check that x is a vector (redundantly) and that the index is in range. However, the use of ##vector-ref can be forced by writing the code with an explicit use of the primitive macro: (define-procedure (foo (x vector)) (primitive (vector-ref x 5))) The expectation is that the primitive special form will be used sparingly. Searching the source code for the pattern \"(primitive\" is a good way to find potentially unsafe code.","title":"define-primitive"},{"location":"manual/modules/primitive_procedures/#type-specifiers","text":"Here is a list of the available type specifiers for a define-procedure parameter x and the associated constraint on the value of x . Note that there is no direct way for checking for a \"list\" or \"list of elements of type T\". A procedure taking a list parameter will likely iterate on the list's pairs going from cdr to cdr until a non-pair is found. Then a check for the empty list with (macro-check-proper-list-null lst <arg-id> (<procedure-name> <args>...) <body>) will check that the parameter is a proper list (i.e. that it ends with the empty list).","title":"Type specifiers"},{"location":"manual/modules/primitive_procedures/#basic-types-other-than-numbers","text":"boolean : x is a boolean char : x is a character pair : x is a pair procedure : x is a procedure string : x is a string symbol : x is a symbol vector : x is a vector","title":"Basic types (other than numbers)"},{"location":"manual/modules/primitive_procedures/#numbers","text":"number : x is a number (possibly complex, rational, etc) real : x is a real number (any number except complex) fixnum : x is a fixnum and -2^(W-3) <= x <= 2^(W-3) - 1 (fixnum-range lo hi) : x is a fixnum and lo <= x < hi (fixnum-range-incl lo hi) : x is a fixnum and lo <= x <= hi index : x is a fixnum and 0 <= x (index-range lo hi) : x is a fixnum and 0 <= lo <= x < hi (index-range-incl lo hi) : x is a fixnum and 0 <= lo <= x <= hi exact-signed-int8 : x is an exact integer, -128 <= x <= 127 exact-signed-int16 : x is an exact integer n , -32768 <= x <= 32767 exact-signed-int32 : x is an exact integer n , -2^31 <= x <= 2^31 - 1 exact-signed-int64 : x is an exact integer n , -2^63 <= x <= 2^63 - 1 exact-unsigned-int8 : x is an exact integer n , 0 <= x <= 255 exact-unsigned-int16 : x is an exact integer n , 0 <= x <= 65535 exact-unsigned-int32 : x is an exact integer n , 0 <= x <= 2^32 - 1 exact-unsigned-int64 : x is an exact integer n , 0 <= x <= 2^64 - 1 flonum : x is a flonum, exception mentions FLONUM inexact-real : x is a flonum, exception mentions Inexact REAL inexact-real-list : x is a flonum, exception mentions Inexact REAL LIST","title":"Numbers"},{"location":"manual/modules/primitive_procedures/#time-types","text":"time : x is a time object absrel-time : x is a real or a time object absrel-time-or-false : x is #f or a real or a time object","title":"Time types"},{"location":"manual/modules/primitive_procedures/#ports","text":"port : x is a port (input, output, or input-output) input-port : x is an input port output-port : x is an output port object-input-port : x is an object input port object-output-port : x is an object output port vector-input-port : x is a vector input port vector-output-port : x is a vector output port character-input-port : x is a character input port character-output-port : x is a character output port string-input-port : x is a string input port string-output-port : x is a string output port byte-port : x is a byte port (input, output, or input-output) byte-input-port : x is a byte input port byte-output-port : x is a byte output port u8vector-input-port : x is a u8vector input port u8vector-output-port : x is a u8vector output port device-input-port : x is a device intput port device-output-port : x is a device output port process-port : x is a process port tcp-client-port : x is a tcp-client port tcp-server-port : x is a tcp-server port udp-port : x is a udp port udp-input-port : x is a udp input port udp-output-port : x is a udp output port tty-port : x is a tty port","title":"Ports"},{"location":"manual/modules/primitive_procedures/#list-and-vector-variants-of-the-above","text":"list : no type checking (a non-null non-pair object is in fact a degenerate dotted list), exception mentions LIST proper-list : no type checking (code traversing the list must check for a proper-list), exception mentions PROPER LIST proper-list-null : x is the empty list, exception mentions PROPER LIST proper-or-circular-list : no type checking (code traversing the list must check for a proper-list or circular-list), exception mentions PROPER or CIRCULAR LIST proper-or-circular-list-null : x is the empty list, exception mentions PROPER LIST char-list : x is a character, exception mentions CHARACTER LIST char-vector : x is a character, exception mentions CHARACTER VECTOR pair-list : x is a pair, exception mentions PAIR LIST exact-unsigned-int8-list-exact-unsigned-int8 : x is an exact-unsigned-int8 , exception mentions INTEGER LIST exact-unsigned-int16-list-exact-unsigned-int16 : x is an exact-unsigned-int16 , exception mentions INTEGER LIST exact-unsigned-int32-list-exact-unsigned-int32 : x is an exact-unsigned-int32, exception mentions INTEGER LIST exact-unsigned-int64-list-exact-unsigned-int64 : x is an exact-unsigned-int64, exception mentions INTEGER LIST exact-signed-int8-list-exact-signed-int8 : x is an exact-signed-int8, exception mentions INTEGER LIST exact-signed-int16-list-exact-signed-int16 : x is an exact-signed-int16, exception mentions INTEGER LIST exact-signed-int32-list-exact-signed-int32 : x is an exact-signed-int32, exception mentions INTEGER LIST exact-signed-int64-list-exact-signed-int64 : x is an exact-signed-int64, exception mentions INTEGER LIST","title":"List and vector variants of the above"},{"location":"manual/modules/primitive_procedures/#gambit-types","text":"error-exception : x is an error-exception object box : x is a box condvar : x is a condition variable f32vector : x is a f32vector f64vector : x is a f64vector foreign : x is a foreign object keyword : x is a keyword mutex : x is a mutex processor : x is a processor object s16vector : x is a s16vector s32vector : x is a s32vector s64vector : x is a s64vector s8vector : x is a s8vector table : x is a table tgroup : x is a thread group thread : x is a thread u16vector : x is a u16vector u32vector : x is a u32vector u64vector : x is a u64vector u8vector : x is a u8vector will : x is a will continuation : x is a continuation object random-source : x is a random-source object readtable : x is a readtable type : x is a structure type descriptor mutable : x is a mutable object","title":"Gambit types"},{"location":"manual/modules/primitive_procedures/#others","text":"not-initialized-thread not-started-thread not-started-thread-given-initialized string-or-ip-address string-or-nonnegative-fixnum","title":"Others"},{"location":"manual/modules/r7rs_compatible_modules/","text":"R7RS compatible modules The R7RS Scheme standard specifies a modularization approach based on the concept of library. A library is defined using the define-library form. This form is implemented as a macro that expands into the constructs used by primitive modules, in particular a ##namespace declaration with a namespace derived from the library's name so that all variables defined by the library are in that namespace. With the define-library form the angle3 module example given previously can be written like this: ;;;---------------------------------------- file: angle3.sld (define-library (angle3) (export deg->rad rad->deg) (import (scheme base) (scheme inexact)) (begin (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)))) For this library the expansion of the define-library form will contain a ##namespace declaration that causes the definition of the global variables angle3#factor , angle3#deg->rad , and angle3#rad->deg . Meanwhile an (import (angle3)) in another library will generate a ##namespace declaration that maps uses of deg->rad and rad->deg to the global variables angle3#deg->rad and angle3#rad->deg respectively (note that the unexported global variable factor is not included in the generated ##namespace declaration). For more complex libraries whose code is split into multiple files it is convenient to put all the files in a dedicated subdirectory. This is the preferred filesystem structure for a library but the runtime system supports both styles. The previous module could be structured like this instead: ;;;---------------------------------------- file: angle3/angle3.sld (define-library (angle3) (export deg->rad rad->deg) (import (scheme base) (scheme inexact)) (include \"angle3.scm\")) ;; path is relative to angle3.sld file ;;;---------------------------------------- file: angle3/angle3.scm (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)) Identifying libraries Each library is given a name so that it can be referred to in various contexts, most notably in import forms and the interpreter's and compiler's command line. The R7RS defines a library name as a list whose members are identifiers and exact non-negative integers, for example (widget) , (_hamt) , (scheme base) , and (srfi 64) . The system maps these R7RS library names to module identifiers that are symbols formed by concatenating the parts of the library name separated with / . The library name and module name are interchangeable. Consequently, (import srfi/64) and (import _hamt) are respectively equivalent to (import (srfi 64)) and (import (_hamt)) . Using the module name to identify libraries on the command line is convenient as it avoids having to escape parentheses and spaces. define-library (define-library name declaration ...) ;; special form In a library definition name specifies the name of the library and declaration is one of: (export <export spec> ...) (import <import set> ...) (begin <command or definition> ...) (include <filename> ...) (include-ci <filename> ...) (include-library-declarations <filename> ...) (cond-expand <cond expand features> ...) (namespace <namespace>) (cc-options <options> ...) (ld-options <options> ...) (ld-options-prelude <options> ...) (pkg-config <options> ...) (pkg-config-path <path> ...) export (export <export spec> ...) An export declaration specifies a list of identifiers which can be made visible to other libraries or programs. An <export spec> takes one of the following forms: <identifier> (rename <identifier>1 <identifier>2) In an <export spec> , an <identifier> names a single binding (variable or macro) defined within or imported into the library, where the external name for the export is the same as the name of the binding within the library. A rename spec exports the binding defined within or imported into the library and named by <identifier>1 in each (<identifier>1 <identifier>2) pairing, using <identifier>2 as the external name. import (import <import set> ...) A library declares a dependency to another library with the import declaration. The (import <import set> ...) form identifies the imported library or libraries. Each <import set> names a set of bindings from a library and possibly specifies local names for the imported bindings. An <import set> takes one of the following forms: <library name> (only <import set> <identifier> ...) (except <import set> <identifier> ...) (prefix <import set> <identifier>) (rename <import set> (<identifier>1 <identifier>2) ...) In the first form, all of the identifiers in the named library's export clauses are imported with the same names (or the exported names if exported with rename ). The additional <import set> forms modify this set as follows: only produces a subset of the given <import set> including only the listed identifiers (after any renaming). It is an error if any of the listed identifiers are not found in the original set. except produces a subset of the given <import set> , excluding the listed identifiers (after any renaming). It is an error if any of the listed identifiers are not found in the original set. rename modifies the given <import set> , replacing each instance of <identifier>1 with <identifier>2 . It is an error if any of the listed <identifier>1 s are not found in the original set. prefix automatically renames all identifiers in the given <import set> , prefixing each with the specified <identifier> . As an extension to the R7RS syntax it is allowed for a <library name> to contain a trailing @version when the library is hosted in a git repository. The version must match a tag of that repository and it indicates the specific library version required. For example, (import (github.com/gambit hello @1.0)) or equivalently (import github.com/gambit/hello@1.0) . Note that the version specifier is not separated with a / in the module name. Another extension to the R7RS syntax when the library is hosted in a git repository is the use of dots before the name of the library to indicate a relative reference within the repository. The number of dots indicates the number of parent hops. For example, in the library (github.com/gambit hello demo) an (import (.. hello)) will resolve to the (github.com/gambit hello) library. A relative library reference should not contain an explicit @version because the version is implicitly the same as the referring module. begin include include-ci (begin <command or definition> ...) (include <filename> ...) (include-ci <filename> ...) The begin , include , and include-ci declarations are used to specify the body of the library. They have the same syntax and semantics as the corresponding expression types. This form of begin is analogous to, but not the same as, the two types of begin expressions. include-library-declarations (include-library-declarations <filename> ...) The include-library-declarations declaration is similar to include except that the contents of the file are spliced directly into the current library definition. This can be used, for example, to share the same export declaration among multiple libraries as a simple form of library interface. cond-expand (cond-expand <cond expand features> ...) The cond-expand declaration has the same syntax and semantics as the cond-expand expression type, except that it expands to spliced-in library declarations rather than expressions enclosed in begin . Extensions to the R7RS library declarations The (namespace <namespace>) declaration allows overriding the namespace used for the library. This is mainly useful for system libraries to prevent namespace prefixing using a (namespace \"\") declaration. The remaining declarations are relevant to the C target and ignored otherwise. They provide information, in the form of strings, to be passed to the compiler options of the same name when this library is compiled: (cc-options <options> ...) (ld-options <options> ...) (ld-options-prelude <options> ...) (pkg-config <options> ...) (pkg-config-path <path> ...) For example, a library could force the C compiler to generate machine code for i386 with: (define-library (foo) (export bar) (import (scheme base)) (cc-options \"-march=i386\") ;; request compilation for i386 (begin (define (bar) 42)))","title":"R7RS compatible modules"},{"location":"manual/modules/r7rs_compatible_modules/#r7rs-compatible-modules","text":"The R7RS Scheme standard specifies a modularization approach based on the concept of library. A library is defined using the define-library form. This form is implemented as a macro that expands into the constructs used by primitive modules, in particular a ##namespace declaration with a namespace derived from the library's name so that all variables defined by the library are in that namespace. With the define-library form the angle3 module example given previously can be written like this: ;;;---------------------------------------- file: angle3.sld (define-library (angle3) (export deg->rad rad->deg) (import (scheme base) (scheme inexact)) (begin (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor)))) For this library the expansion of the define-library form will contain a ##namespace declaration that causes the definition of the global variables angle3#factor , angle3#deg->rad , and angle3#rad->deg . Meanwhile an (import (angle3)) in another library will generate a ##namespace declaration that maps uses of deg->rad and rad->deg to the global variables angle3#deg->rad and angle3#rad->deg respectively (note that the unexported global variable factor is not included in the generated ##namespace declaration). For more complex libraries whose code is split into multiple files it is convenient to put all the files in a dedicated subdirectory. This is the preferred filesystem structure for a library but the runtime system supports both styles. The previous module could be structured like this instead: ;;;---------------------------------------- file: angle3/angle3.sld (define-library (angle3) (export deg->rad rad->deg) (import (scheme base) (scheme inexact)) (include \"angle3.scm\")) ;; path is relative to angle3.sld file ;;;---------------------------------------- file: angle3/angle3.scm (define factor (/ (atan 1) 45)) (define (deg->rad x) (* x factor)) (define (rad->deg x) (/ x factor))","title":"R7RS compatible modules"},{"location":"manual/modules/r7rs_compatible_modules/#identifying-libraries","text":"Each library is given a name so that it can be referred to in various contexts, most notably in import forms and the interpreter's and compiler's command line. The R7RS defines a library name as a list whose members are identifiers and exact non-negative integers, for example (widget) , (_hamt) , (scheme base) , and (srfi 64) . The system maps these R7RS library names to module identifiers that are symbols formed by concatenating the parts of the library name separated with / . The library name and module name are interchangeable. Consequently, (import srfi/64) and (import _hamt) are respectively equivalent to (import (srfi 64)) and (import (_hamt)) . Using the module name to identify libraries on the command line is convenient as it avoids having to escape parentheses and spaces.","title":"Identifying libraries"},{"location":"manual/modules/r7rs_compatible_modules/#define-library","text":"(define-library name declaration ...) ;; special form In a library definition name specifies the name of the library and declaration is one of: (export <export spec> ...) (import <import set> ...) (begin <command or definition> ...) (include <filename> ...) (include-ci <filename> ...) (include-library-declarations <filename> ...) (cond-expand <cond expand features> ...) (namespace <namespace>) (cc-options <options> ...) (ld-options <options> ...) (ld-options-prelude <options> ...) (pkg-config <options> ...) (pkg-config-path <path> ...)","title":"define-library"},{"location":"manual/modules/r7rs_compatible_modules/#export","text":"(export <export spec> ...) An export declaration specifies a list of identifiers which can be made visible to other libraries or programs. An <export spec> takes one of the following forms: <identifier> (rename <identifier>1 <identifier>2) In an <export spec> , an <identifier> names a single binding (variable or macro) defined within or imported into the library, where the external name for the export is the same as the name of the binding within the library. A rename spec exports the binding defined within or imported into the library and named by <identifier>1 in each (<identifier>1 <identifier>2) pairing, using <identifier>2 as the external name.","title":"export"},{"location":"manual/modules/r7rs_compatible_modules/#import","text":"(import <import set> ...) A library declares a dependency to another library with the import declaration. The (import <import set> ...) form identifies the imported library or libraries. Each <import set> names a set of bindings from a library and possibly specifies local names for the imported bindings. An <import set> takes one of the following forms: <library name> (only <import set> <identifier> ...) (except <import set> <identifier> ...) (prefix <import set> <identifier>) (rename <import set> (<identifier>1 <identifier>2) ...) In the first form, all of the identifiers in the named library's export clauses are imported with the same names (or the exported names if exported with rename ). The additional <import set> forms modify this set as follows: only produces a subset of the given <import set> including only the listed identifiers (after any renaming). It is an error if any of the listed identifiers are not found in the original set. except produces a subset of the given <import set> , excluding the listed identifiers (after any renaming). It is an error if any of the listed identifiers are not found in the original set. rename modifies the given <import set> , replacing each instance of <identifier>1 with <identifier>2 . It is an error if any of the listed <identifier>1 s are not found in the original set. prefix automatically renames all identifiers in the given <import set> , prefixing each with the specified <identifier> . As an extension to the R7RS syntax it is allowed for a <library name> to contain a trailing @version when the library is hosted in a git repository. The version must match a tag of that repository and it indicates the specific library version required. For example, (import (github.com/gambit hello @1.0)) or equivalently (import github.com/gambit/hello@1.0) . Note that the version specifier is not separated with a / in the module name. Another extension to the R7RS syntax when the library is hosted in a git repository is the use of dots before the name of the library to indicate a relative reference within the repository. The number of dots indicates the number of parent hops. For example, in the library (github.com/gambit hello demo) an (import (.. hello)) will resolve to the (github.com/gambit hello) library. A relative library reference should not contain an explicit @version because the version is implicitly the same as the referring module.","title":"import"},{"location":"manual/modules/r7rs_compatible_modules/#begin","text":"","title":"begin"},{"location":"manual/modules/r7rs_compatible_modules/#include","text":"","title":"include"},{"location":"manual/modules/r7rs_compatible_modules/#include-ci","text":"(begin <command or definition> ...) (include <filename> ...) (include-ci <filename> ...) The begin , include , and include-ci declarations are used to specify the body of the library. They have the same syntax and semantics as the corresponding expression types. This form of begin is analogous to, but not the same as, the two types of begin expressions.","title":"include-ci"},{"location":"manual/modules/r7rs_compatible_modules/#include-library-declarations","text":"(include-library-declarations <filename> ...) The include-library-declarations declaration is similar to include except that the contents of the file are spliced directly into the current library definition. This can be used, for example, to share the same export declaration among multiple libraries as a simple form of library interface.","title":"include-library-declarations"},{"location":"manual/modules/r7rs_compatible_modules/#cond-expand","text":"(cond-expand <cond expand features> ...) The cond-expand declaration has the same syntax and semantics as the cond-expand expression type, except that it expands to spliced-in library declarations rather than expressions enclosed in begin .","title":"cond-expand"},{"location":"manual/modules/r7rs_compatible_modules/#extensions-to-the-r7rs-library-declarations","text":"The (namespace <namespace>) declaration allows overriding the namespace used for the library. This is mainly useful for system libraries to prevent namespace prefixing using a (namespace \"\") declaration. The remaining declarations are relevant to the C target and ignored otherwise. They provide information, in the form of strings, to be passed to the compiler options of the same name when this library is compiled: (cc-options <options> ...) (ld-options <options> ...) (ld-options-prelude <options> ...) (pkg-config <options> ...) (pkg-config-path <path> ...) For example, a library could force the C compiler to generate machine code for i386 with: (define-library (foo) (export bar) (import (scheme base)) (cc-options \"-march=i386\") ;; request compilation for i386 (begin (define (bar) 42)))","title":"Extensions to the R7RS library declarations"},{"location":"manual/records/","text":"Records (define-structure name field ...) ;; special form Record data types similar to Pascal records and C struct types can be defined using the define-structure special form. The identifier name specifies the name of the new data type. The structure name is followed by k identifiers naming each field of the record. The define-structure expands into a set of definitions of the following procedures: make-name \u2013 A k argument procedure which constructs a new record from the value of its k fields. name? \u2013 A procedure which tests if its single argument is of the given record type. name-field \u2013 For each field, a procedure taking as its single argument a value of the given record type and returning the content of the corresponding field of the record. name-field-set! \u2013 For each field, a two argument procedure taking as its first argument a value of the given record type. The second argument gets assigned to the corresponding field of the record and the void object is returned. Record data types have a printed representation that includes the name of the type and the name and value of each field. Record data types can not be read by the read procedure. For example: > (define-structure point x y color) > (define p (make-point 3 5 'red)) > p #<point #2 x: 3 y: 5 color: red> > (point-x p) 3 > (point-color p) red > (point-color-set! p 'black) > p #<point #2 x: 3 y: 5 color: black>","title":"Records"},{"location":"manual/records/#records","text":"(define-structure name field ...) ;; special form Record data types similar to Pascal records and C struct types can be defined using the define-structure special form. The identifier name specifies the name of the new data type. The structure name is followed by k identifiers naming each field of the record. The define-structure expands into a set of definitions of the following procedures: make-name \u2013 A k argument procedure which constructs a new record from the value of its k fields. name? \u2013 A procedure which tests if its single argument is of the given record type. name-field \u2013 For each field, a procedure taking as its single argument a value of the given record type and returning the content of the corresponding field of the record. name-field-set! \u2013 For each field, a two argument procedure taking as its first argument a value of the given record type. The second argument gets assigned to the corresponding field of the record and the void object is returned. Record data types have a printed representation that includes the name of the type and the name and value of each field. Record data types can not be read by the read procedure. For example: > (define-structure point x y color) > (define p (make-point 3 5 'red)) > p #<point #2 x: 3 y: 5 color: red> > (point-x p) 3 > (point-color p) red > (point-color-set! p 'black) > p #<point #2 x: 3 y: 5 color: black>","title":"Records"},{"location":"manual/runtime_options/","text":"Runtime options Both gsi and gsc as well as executable programs compiled and linked using gsc take a -: option which supplies parameters to the runtime system. This option must appear first on the command line. The colon is followed by a comma separated list of options with no intervening spaces. The available options are: min-heap=SIZE or the shorthand mSIZE : Set minimum heap size. max-heap=SIZE or the shorthand hSIZE : Set maximum heap size. live-ratio=RATIO or the shorthand lRATIO : Set the ratio of heap that is live after a garbage collection. gambit or the (deprecated) shorthand S : Select Gambit Scheme mode. This is the default mode. r5rs or the (deprecated) shorthand s : Select R5RS Scheme mode. r7rs : Select R7RS Scheme mode. debug[=[OPT...]] or the shorthand d[OPT...] : Set debugging options. ~~NAME=DIRECTORY : Override the NAME installation directory. add-arg=ARGUMENT or the shorthand +ARGUMENT : Add ARGUMENT to the command line before other arguments. io-settings=[IO...] or the shorthand i[IO...] : Set general I/O settings. file-settings=[IO...] or the shorthand f[IO...] : Set general file I/O settings. stdio-settings=[IO...] or the shorthand -[IO...] : Set general stdio settings. 0[IO...] : Set stdin settings. 1[IO...] : Set stdout settings. 2[IO...] : Set stderr settings. terminal-settings=[IO...] or the shorthand t[IO...] : Set terminal I/O settings. search=[DIR] : Set or reset module search order. whitelist=[SOURCE] : Set or reset the whitelist of trusted sources for automatic installation of hosted modules. ask-install=WHEN : Set automatic installation confirmation mode. The min-heap=SIZE and max-heap=SIZE options set limits on the size of the heap. The SIZE is an integer that may be followed by G (gigabytes), M (megabytes), or K or nothing (kilobytes). The heap will not shrink lower than the minimum heap size which defaults to 0 . The heap will not grow larger than the maximum heap size if it is set (by default the heap may grow until the virtual memory is exhausted). The live-ratio=RATIO option sets the percentage of the heap that will be occupied with live objects after the heap is resized at the end of a garbage collection. RATIO is an integer between 1 and 100 inclusively indicating the desired percentage. The garbage collector resizes the heap to reach this percentage occupation (roughly), within the limits of the min-heap and max-heap options. By default, the percentage is 50 . The gambit , r5rs and r7rs options configure the runtime system to conform to Gambit Scheme, R5RS Scheme and R7RS Scheme respectively. The reader is case-insensitive in r5rs mode, and is case-sensitive in r7rs and gambit modes. The reader supports keywords only in gambit mode, which is the default mode. The debug=OPT,... option sets various debugging options. The equal sign is followed by a sequence of letters indicating suboptions. p : Uncaught exceptions will be treated as \"errors\" in the primordial thread only. a : Uncaught exceptions will be treated as \"errors\" in all threads. r : When an \"error\" occurs a new REPL will be started. s : When an \"error\" occurs a new REPL will be started. Moreover the program starts in single-stepping mode. q : When an \"error\" occurs the program will terminate with a nonzero exit status. R When a user interrupt occurs a new REPL will be started. User interrupts are typically obtained by typing <^C> . Note that with some system configurations <^C> abruptly terminates the process. For example, under Microsoft Windows, <^C> works fine with the standard console but with the MSYS terminal window it terminates the process. D : When a user interrupt occurs it will be deferred until the parameter object current-user-interrupt-handler is set or bound. Q : When a user interrupt occurs the program will terminate with a nonzero exit status. LEVEL The verbosity level is set to LEVEL , a digit from 0 to 9 . At level 0 the runtime system will not display error messages and warnings. At level 1 and above error messages and warnings are displayed. At level 2 and above a backtrace is displayed. At level 3 and above variable bindings are displayed in the backtrace. At level 5 and above garbage collection reports are displayed during program execution. c : The REPL interaction channel will be the console. - : The REPL interaction channel will be standard input and standard output. + : The REPL interaction channel will be standard input and standard output and standard error. @[HOST][:PORT] : When a REPL is started by a thread a connection will be established with the address HOST:PORT and that will be the REPL\u2019s interaction channel. The default HOST is 127.0.0.1 and the default PORT is 44556 . $[INTF][:PORT] : The runtime system will open a socket to listen on port number PORT for incoming connections on the network interface with address INTF . The default INTF is 127.0.0.1 and the default PORT is 44555 . The default debugging options are equivalent to debug=pqQ1- (i.e. an uncaught exception in the primordial thread terminates the program after displaying an error message). When the option debug is used without suboptions it is equivalent to debug=prR1- (i.e. a new REPL is started only when an uncaught exception occurs in the primordial thread). When gsi and gsc are running the main REPL, the debugging options are changed to cause errors in the primordial thread and user interrupts to start a nested REPL. The ~~NAME=DIRECTORY option overrides the setting of the NAME installation directory. If NAME is empty, it will override the central installation directory. The add-arg=ARGUMENT option adds the text that follows to the command line before other arguments. The option io-settings=[IO...] sets the default I/O settings of all types of ports. The option file-settings=[IO...] sets the default I/O settings for ports associated to files. The option stdio-settings=[IO...] sets the default I/O settings for ports associated to stdio (but finer control is possible with 0[IO...] , 1[IO...] , and 2[IO...] that set the I/O settings of stdin , stdout , and stderr respectively). The option terminal-settings=[IO...] overrides the default I/O settings for ports associated to terminals. The default character encoding, end-of-line encoding and buffering can be set. Moreover, for terminals the line-editing feature can be enabled or disabled. Each IO is a one or two letter code as follows: A : ASCII character encoding. 1 : ISO-8859-1 character encoding. 2 : UCS-2 character encoding. 4 : UCS-4 character encoding. 6 : UTF-16 character encoding. 8 : UTF-8 character encoding. U : UTF character encoding with fallback to UTF-8 on input if no BOM is present. UA : UTF character encoding with fallback to ASCII on input if no BOM is present. U1 : UTF character encoding with fallback to ISO-8859-1 on input if no BOM is present. U6 : UTF character encoding with fallback to UTF-16 on input if no BOM is present. U8 : UTF character encoding with fallback to UTF-8 on input if no BOM is present. L : If the LC_ALL or LC_CTYPE or LANG environment variables end with .UTF-8 or .ISO-8859-1 or .LATIN-1 (or a variation) set the character encoding accordingly. c : End-of-line is encoded as CR (carriage-return). l : End-of-line is encoded as LF (linefeed) cl : End-of-line is encoded as CR-LF . u : Unbuffered I/O. n : Line buffered I/O ( n for \"at newline\"). f : Fully buffered I/O. r : Illegal character encoding is treated as an error (exception raised). R : Silently replace illegal character encodings with Unicode character #xfffd (replacement character). e : Enable line-editing (applies to terminals only). E : Disable line-editing (applies to terminals only). The search=[DIR] option adds DIR to the head of the list of module search order directories, unless DIR is empty, in which case it is set to the empty list. The initial setting of the list of module search order directories is ~~lib followed by ~~userlib . When a hosted module can't be found in the directories on the list of module search order directories it will be automatically installed if it is from a source on the whitelist of trusted sources, which initially contains only github.com/gambit . The whitelist=[SOURCE] option adds SOURCE to the whitelist, unless SOURCE is empty in which case the whitelist will be set to the empty list (no source is trusted). The ask-install=WHEN option sets the automatic installation mode confirmation mode to WHEN , which is one of always , repl , and never . When a hosted module can't be found in the directories on the list of module search order directories and it is from a source not on the whitelist the runtime system will ask for installation confirmation when WHEN is always , or when a REPL has already been started for the current thread and WHEN is repl . In the never mode the runtime system will not install the module automatically. The default mode is repl . When a program's execution starts, the runtime system obtains the runtime options by processing in turn various sources of runtime options: the defaults, the environment variable GAMBOPT , the script line of the source code, and, unless the program is an interpreted script, the first command line argument of the program. Any runtime option can be overriden by a subsequent source of runtime options. It is sometimes useful to prevent overriding the runtime options of the script line. This can be achieved by starting the script line runtime options with -:, . In this case the environment variable GAMBOPT is ignored, and the first command line argument of the program is not used for runtime options (it is treated like a normal command line argument even if it starts with -: ). For example: $ export GAMBOPT=debug=0,~~=~/my-gambit2 $ gsi -e '(pretty-print (path-expand \"~~\")) (/ 1 0)' \"/Users/feeley/my-gambit2/\" $ echo $? 70 $ gsi -:debug=1 -e '(pretty-print (path-expand \"~~\")) (/ 1 0)' \"/Users/feeley/my-gambit2/\" *** ERROR IN (string)@1.35 -- Divide by zero (/ 1 0)","title":"Runtime options"},{"location":"manual/runtime_options/#runtime-options","text":"Both gsi and gsc as well as executable programs compiled and linked using gsc take a -: option which supplies parameters to the runtime system. This option must appear first on the command line. The colon is followed by a comma separated list of options with no intervening spaces. The available options are: min-heap=SIZE or the shorthand mSIZE : Set minimum heap size. max-heap=SIZE or the shorthand hSIZE : Set maximum heap size. live-ratio=RATIO or the shorthand lRATIO : Set the ratio of heap that is live after a garbage collection. gambit or the (deprecated) shorthand S : Select Gambit Scheme mode. This is the default mode. r5rs or the (deprecated) shorthand s : Select R5RS Scheme mode. r7rs : Select R7RS Scheme mode. debug[=[OPT...]] or the shorthand d[OPT...] : Set debugging options. ~~NAME=DIRECTORY : Override the NAME installation directory. add-arg=ARGUMENT or the shorthand +ARGUMENT : Add ARGUMENT to the command line before other arguments. io-settings=[IO...] or the shorthand i[IO...] : Set general I/O settings. file-settings=[IO...] or the shorthand f[IO...] : Set general file I/O settings. stdio-settings=[IO...] or the shorthand -[IO...] : Set general stdio settings. 0[IO...] : Set stdin settings. 1[IO...] : Set stdout settings. 2[IO...] : Set stderr settings. terminal-settings=[IO...] or the shorthand t[IO...] : Set terminal I/O settings. search=[DIR] : Set or reset module search order. whitelist=[SOURCE] : Set or reset the whitelist of trusted sources for automatic installation of hosted modules. ask-install=WHEN : Set automatic installation confirmation mode. The min-heap=SIZE and max-heap=SIZE options set limits on the size of the heap. The SIZE is an integer that may be followed by G (gigabytes), M (megabytes), or K or nothing (kilobytes). The heap will not shrink lower than the minimum heap size which defaults to 0 . The heap will not grow larger than the maximum heap size if it is set (by default the heap may grow until the virtual memory is exhausted). The live-ratio=RATIO option sets the percentage of the heap that will be occupied with live objects after the heap is resized at the end of a garbage collection. RATIO is an integer between 1 and 100 inclusively indicating the desired percentage. The garbage collector resizes the heap to reach this percentage occupation (roughly), within the limits of the min-heap and max-heap options. By default, the percentage is 50 . The gambit , r5rs and r7rs options configure the runtime system to conform to Gambit Scheme, R5RS Scheme and R7RS Scheme respectively. The reader is case-insensitive in r5rs mode, and is case-sensitive in r7rs and gambit modes. The reader supports keywords only in gambit mode, which is the default mode. The debug=OPT,... option sets various debugging options. The equal sign is followed by a sequence of letters indicating suboptions. p : Uncaught exceptions will be treated as \"errors\" in the primordial thread only. a : Uncaught exceptions will be treated as \"errors\" in all threads. r : When an \"error\" occurs a new REPL will be started. s : When an \"error\" occurs a new REPL will be started. Moreover the program starts in single-stepping mode. q : When an \"error\" occurs the program will terminate with a nonzero exit status. R When a user interrupt occurs a new REPL will be started. User interrupts are typically obtained by typing <^C> . Note that with some system configurations <^C> abruptly terminates the process. For example, under Microsoft Windows, <^C> works fine with the standard console but with the MSYS terminal window it terminates the process. D : When a user interrupt occurs it will be deferred until the parameter object current-user-interrupt-handler is set or bound. Q : When a user interrupt occurs the program will terminate with a nonzero exit status. LEVEL The verbosity level is set to LEVEL , a digit from 0 to 9 . At level 0 the runtime system will not display error messages and warnings. At level 1 and above error messages and warnings are displayed. At level 2 and above a backtrace is displayed. At level 3 and above variable bindings are displayed in the backtrace. At level 5 and above garbage collection reports are displayed during program execution. c : The REPL interaction channel will be the console. - : The REPL interaction channel will be standard input and standard output. + : The REPL interaction channel will be standard input and standard output and standard error. @[HOST][:PORT] : When a REPL is started by a thread a connection will be established with the address HOST:PORT and that will be the REPL\u2019s interaction channel. The default HOST is 127.0.0.1 and the default PORT is 44556 . $[INTF][:PORT] : The runtime system will open a socket to listen on port number PORT for incoming connections on the network interface with address INTF . The default INTF is 127.0.0.1 and the default PORT is 44555 . The default debugging options are equivalent to debug=pqQ1- (i.e. an uncaught exception in the primordial thread terminates the program after displaying an error message). When the option debug is used without suboptions it is equivalent to debug=prR1- (i.e. a new REPL is started only when an uncaught exception occurs in the primordial thread). When gsi and gsc are running the main REPL, the debugging options are changed to cause errors in the primordial thread and user interrupts to start a nested REPL. The ~~NAME=DIRECTORY option overrides the setting of the NAME installation directory. If NAME is empty, it will override the central installation directory. The add-arg=ARGUMENT option adds the text that follows to the command line before other arguments. The option io-settings=[IO...] sets the default I/O settings of all types of ports. The option file-settings=[IO...] sets the default I/O settings for ports associated to files. The option stdio-settings=[IO...] sets the default I/O settings for ports associated to stdio (but finer control is possible with 0[IO...] , 1[IO...] , and 2[IO...] that set the I/O settings of stdin , stdout , and stderr respectively). The option terminal-settings=[IO...] overrides the default I/O settings for ports associated to terminals. The default character encoding, end-of-line encoding and buffering can be set. Moreover, for terminals the line-editing feature can be enabled or disabled. Each IO is a one or two letter code as follows: A : ASCII character encoding. 1 : ISO-8859-1 character encoding. 2 : UCS-2 character encoding. 4 : UCS-4 character encoding. 6 : UTF-16 character encoding. 8 : UTF-8 character encoding. U : UTF character encoding with fallback to UTF-8 on input if no BOM is present. UA : UTF character encoding with fallback to ASCII on input if no BOM is present. U1 : UTF character encoding with fallback to ISO-8859-1 on input if no BOM is present. U6 : UTF character encoding with fallback to UTF-16 on input if no BOM is present. U8 : UTF character encoding with fallback to UTF-8 on input if no BOM is present. L : If the LC_ALL or LC_CTYPE or LANG environment variables end with .UTF-8 or .ISO-8859-1 or .LATIN-1 (or a variation) set the character encoding accordingly. c : End-of-line is encoded as CR (carriage-return). l : End-of-line is encoded as LF (linefeed) cl : End-of-line is encoded as CR-LF . u : Unbuffered I/O. n : Line buffered I/O ( n for \"at newline\"). f : Fully buffered I/O. r : Illegal character encoding is treated as an error (exception raised). R : Silently replace illegal character encodings with Unicode character #xfffd (replacement character). e : Enable line-editing (applies to terminals only). E : Disable line-editing (applies to terminals only). The search=[DIR] option adds DIR to the head of the list of module search order directories, unless DIR is empty, in which case it is set to the empty list. The initial setting of the list of module search order directories is ~~lib followed by ~~userlib . When a hosted module can't be found in the directories on the list of module search order directories it will be automatically installed if it is from a source on the whitelist of trusted sources, which initially contains only github.com/gambit . The whitelist=[SOURCE] option adds SOURCE to the whitelist, unless SOURCE is empty in which case the whitelist will be set to the empty list (no source is trusted). The ask-install=WHEN option sets the automatic installation mode confirmation mode to WHEN , which is one of always , repl , and never . When a hosted module can't be found in the directories on the list of module search order directories and it is from a source not on the whitelist the runtime system will ask for installation confirmation when WHEN is always , or when a REPL has already been started for the current thread and WHEN is repl . In the never mode the runtime system will not install the module automatically. The default mode is repl . When a program's execution starts, the runtime system obtains the runtime options by processing in turn various sources of runtime options: the defaults, the environment variable GAMBOPT , the script line of the source code, and, unless the program is an interpreted script, the first command line argument of the program. Any runtime option can be overriden by a subsequent source of runtime options. It is sometimes useful to prevent overriding the runtime options of the script line. This can be achieved by starting the script line runtime options with -:, . In this case the environment variable GAMBOPT is ignored, and the first command line argument of the program is not used for runtime options (it is treated like a normal command line argument even if it starts with -: ). For example: $ export GAMBOPT=debug=0,~~=~/my-gambit2 $ gsi -e '(pretty-print (path-expand \"~~\")) (/ 1 0)' \"/Users/feeley/my-gambit2/\" $ echo $? 70 $ gsi -:debug=1 -e '(pretty-print (path-expand \"~~\")) (/ 1 0)' \"/Users/feeley/my-gambit2/\" *** ERROR IN (string)@1.35 -- Divide by zero (/ 1 0)","title":"Runtime options"},{"location":"manual/scheme_extensions/","text":"Scheme extensions This section describes the Gambit extensions to the Scheme language.","title":"Scheme extensions"},{"location":"manual/scheme_extensions/#scheme-extensions","text":"This section describes the Gambit extensions to the Scheme language.","title":"Scheme extensions"},{"location":"manual/scheme_extensions/extensions_to_standard_procedures/","text":"Extensions to standard procedures transcript-on transcript-off R5RS procedures (transcript-on file) ;; procedure (transcript-off) ;; procedure These procedures do nothing. call-with-current-continuation call/cc (call-with-current-continuation proc) ;; procedure (call/cc proc) ;; procedure The procedure call-with-current-continuation is bound to the global variables call-with-current-continuation and call/cc .","title":"Extensions to standard procedures"},{"location":"manual/scheme_extensions/extensions_to_standard_procedures/#extensions-to-standard-procedures","text":"","title":"Extensions to standard procedures"},{"location":"manual/scheme_extensions/extensions_to_standard_procedures/#transcript-on","text":"","title":"transcript-on"},{"location":"manual/scheme_extensions/extensions_to_standard_procedures/#transcript-off","text":"R5RS procedures (transcript-on file) ;; procedure (transcript-off) ;; procedure These procedures do nothing.","title":"transcript-off"},{"location":"manual/scheme_extensions/extensions_to_standard_procedures/#call-with-current-continuation","text":"","title":"call-with-current-continuation"},{"location":"manual/scheme_extensions/extensions_to_standard_procedures/#callcc","text":"(call-with-current-continuation proc) ;; procedure (call/cc proc) ;; procedure The procedure call-with-current-continuation is bound to the global variables call-with-current-continuation and call/cc .","title":"call/cc"},{"location":"manual/scheme_extensions/extensions_to_standard_special_forms/","text":"Extensions to standard special forms lambda define (lambda lambda-formals body) ;; special form (define (variable define-formals) body) ;; special form lambda-formals = ( formal-argument-list ) | r4rs-lambda-formals define-formals = formal-argument-list | r4rs-define-formals formal-argument-list = dsssl-formal-argument-list | rest-at-end-formal-argument-list dsssl-formal-argument-list = reqs opts rest keys rest-at-end-formal-argument-list = reqs opts keys rest | reqs opts keys . rest-formal-argument reqs = required-formal-argument* required-formal-argument = variable opts = #!optional optional-formal-argument* | empty optional-formal-argument = variable | ( variable initializer ) rest = #!rest rest-formal-argument | empty rest-formal-argument = variable keys = #!key keyword-formal-argument* | empty keyword-formal-argument = variable | ( variable initializer ) initializer = expression r4rs-lambda-formals = ( variable* ) | ( variable+ . variable ) | variable r4rs-define-formals = variable* | variable* . variable These forms are extended versions of the lambda and define special forms of standard Scheme. They allow the use of optional formal arguments, either positional or named, and support the syntax and semantics of the DSSSL standard. When the procedure introduced by a lambda (or define ) is applied to a list of actual arguments, the formal and actual arguments are processed as specified in the R4RS if the lambda-formals (or define-formals ) is a r4rs-lambda-formals (or r4rs-define-formals ). If the formal-argument-list matches dsssl-formal-argument-list or extended-formal-argument-list they are processed as follows: Variables in required-formal-arguments are bound to successive actual arguments starting with the first actual argument. It shall be an error if there are fewer actual arguments than required-formal-arguments . Next variables in optional-formal-arguments are bound to remaining actual arguments. If there are fewer remaining actual arguments than optional-formal-arguments , then the variables are bound to the result of evaluating initializer , if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. If #!key does not appear in the formal-argument-list and there is no rest-formal-argument then it shall be an error if there are any remaining actual arguments. If #!key does not appear in the formal-argument-list and there is a rest-formal-argument then the rest-formal-argument is bound to a list of all remaining actual arguments. If #!key appears in the formal-argument-list and there is no rest-formal-argument then there shall be an even number of remaining actual arguments. These are interpreted as a series of pairs, where the first member of each pair is a keyword specifying the argument name, and the second is the corresponding value. It shall be an error if the first member of a pair is not a keyword. It shall be an error if the argument name is not the same as a variable in a keyword-formal-argument . If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument , then the variable is bound to the result of evaluating initializer if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. If #!key appears in the formal-argument-list and there is a rest-formal-argument before the #!key then there may be an even or odd number of remaining actual arguments and the rest-formal-argument is bound to a list of all remaining actual arguments. Then, these remaining actual arguments are scanned from left to right in pairs, stopping at the first pair whose first element is not a keyword. Each pair whose first element is a keyword matching the name of a keyword-formal-argument gives the value (i.e. the second element of the pair) of the corresponding formal argument. If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument , then the variable is bound to the result of evaluating initializer if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. If #!key appears in the formal-argument-list and there is a rest-formal-argument after the #!key then there may be an even or odd number of remaining actual arguments. The remaining actual arguments are scanned from left to right in pairs, stopping at the first pair whose first element is not a keyword. Each pair shall have as its first element a keyword matching the name of a keyword-formal-argument ; the second element gives the value of the corresponding formal argument. If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument , then the variable is bound to the result of evaluating initializer if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. Finally, the rest-formal-argument is bound to the list of the actual arguments that were not scanned (i.e. after the last keyword/value pair). In all cases it is an error for a variable to appear more than once in a formal-argument-list . Note that this specification is compatible with the DSSSL language standard (i.e. a correct DSSSL program will have the same semantics when run with Gambit). It is unspecified whether variables receive their value by binding or by assignment. Currently the compiler and interpreter use different methods, which can lead to different semantics if call-with-current-continuation is used in an initializer. Note that this is irrelevant for DSSSL programs because call-with-current-continuation does not exist in DSSSL. For example: > ((lambda (#!rest x) x) 1 2 3) (1 2 3) > (define (f a #!optional b) (list a b)) > (define (g a #!optional (b a) #!key (k (* a b))) (list a b k)) > (define (h1 a #!rest r #!key k) (list a k r)) > (define (h2 a #!key k #!rest r) (list a k r)) > (f 1) (1 #f) > (f 1 2) (1 2) > (g 3) (3 3 9) > (g 3 4) (3 4 12) > (g 3 4 k: 5) (3 4 5) > (g 3 4 k: 5 k: 6) (3 4 5) > (h1 7) (7 #f ()) > (h1 7 k: 8 9) (7 8 (k: 8 9)) > (h1 7 k: 8 z: 9) (7 8 (k: 8 z: 9)) > (h2 7) (7 #f ()) > (h2 7 k: 8 9) (7 8 (9)) > (h2 7 k: 8 z: 9) *** ERROR IN (console)@17.1 -- Unknown keyword argument passed to procedure (h2 7 k: 8 z: 9)","title":"Extensions to standard special forms"},{"location":"manual/scheme_extensions/extensions_to_standard_special_forms/#extensions-to-standard-special-forms","text":"","title":"Extensions to standard special forms"},{"location":"manual/scheme_extensions/extensions_to_standard_special_forms/#lambda","text":"","title":"lambda"},{"location":"manual/scheme_extensions/extensions_to_standard_special_forms/#define","text":"(lambda lambda-formals body) ;; special form (define (variable define-formals) body) ;; special form lambda-formals = ( formal-argument-list ) | r4rs-lambda-formals define-formals = formal-argument-list | r4rs-define-formals formal-argument-list = dsssl-formal-argument-list | rest-at-end-formal-argument-list dsssl-formal-argument-list = reqs opts rest keys rest-at-end-formal-argument-list = reqs opts keys rest | reqs opts keys . rest-formal-argument reqs = required-formal-argument* required-formal-argument = variable opts = #!optional optional-formal-argument* | empty optional-formal-argument = variable | ( variable initializer ) rest = #!rest rest-formal-argument | empty rest-formal-argument = variable keys = #!key keyword-formal-argument* | empty keyword-formal-argument = variable | ( variable initializer ) initializer = expression r4rs-lambda-formals = ( variable* ) | ( variable+ . variable ) | variable r4rs-define-formals = variable* | variable* . variable These forms are extended versions of the lambda and define special forms of standard Scheme. They allow the use of optional formal arguments, either positional or named, and support the syntax and semantics of the DSSSL standard. When the procedure introduced by a lambda (or define ) is applied to a list of actual arguments, the formal and actual arguments are processed as specified in the R4RS if the lambda-formals (or define-formals ) is a r4rs-lambda-formals (or r4rs-define-formals ). If the formal-argument-list matches dsssl-formal-argument-list or extended-formal-argument-list they are processed as follows: Variables in required-formal-arguments are bound to successive actual arguments starting with the first actual argument. It shall be an error if there are fewer actual arguments than required-formal-arguments . Next variables in optional-formal-arguments are bound to remaining actual arguments. If there are fewer remaining actual arguments than optional-formal-arguments , then the variables are bound to the result of evaluating initializer , if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. If #!key does not appear in the formal-argument-list and there is no rest-formal-argument then it shall be an error if there are any remaining actual arguments. If #!key does not appear in the formal-argument-list and there is a rest-formal-argument then the rest-formal-argument is bound to a list of all remaining actual arguments. If #!key appears in the formal-argument-list and there is no rest-formal-argument then there shall be an even number of remaining actual arguments. These are interpreted as a series of pairs, where the first member of each pair is a keyword specifying the argument name, and the second is the corresponding value. It shall be an error if the first member of a pair is not a keyword. It shall be an error if the argument name is not the same as a variable in a keyword-formal-argument . If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument , then the variable is bound to the result of evaluating initializer if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. If #!key appears in the formal-argument-list and there is a rest-formal-argument before the #!key then there may be an even or odd number of remaining actual arguments and the rest-formal-argument is bound to a list of all remaining actual arguments. Then, these remaining actual arguments are scanned from left to right in pairs, stopping at the first pair whose first element is not a keyword. Each pair whose first element is a keyword matching the name of a keyword-formal-argument gives the value (i.e. the second element of the pair) of the corresponding formal argument. If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument , then the variable is bound to the result of evaluating initializer if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. If #!key appears in the formal-argument-list and there is a rest-formal-argument after the #!key then there may be an even or odd number of remaining actual arguments. The remaining actual arguments are scanned from left to right in pairs, stopping at the first pair whose first element is not a keyword. Each pair shall have as its first element a keyword matching the name of a keyword-formal-argument ; the second element gives the value of the corresponding formal argument. If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument , then the variable is bound to the result of evaluating initializer if one was specified, and otherwise to #f . The initializer is evaluated in an environment in which all previous formal arguments have been bound. Finally, the rest-formal-argument is bound to the list of the actual arguments that were not scanned (i.e. after the last keyword/value pair). In all cases it is an error for a variable to appear more than once in a formal-argument-list . Note that this specification is compatible with the DSSSL language standard (i.e. a correct DSSSL program will have the same semantics when run with Gambit). It is unspecified whether variables receive their value by binding or by assignment. Currently the compiler and interpreter use different methods, which can lead to different semantics if call-with-current-continuation is used in an initializer. Note that this is irrelevant for DSSSL programs because call-with-current-continuation does not exist in DSSSL. For example: > ((lambda (#!rest x) x) 1 2 3) (1 2 3) > (define (f a #!optional b) (list a b)) > (define (g a #!optional (b a) #!key (k (* a b))) (list a b k)) > (define (h1 a #!rest r #!key k) (list a k r)) > (define (h2 a #!key k #!rest r) (list a k r)) > (f 1) (1 #f) > (f 1 2) (1 2) > (g 3) (3 3 9) > (g 3 4) (3 4 12) > (g 3 4 k: 5) (3 4 5) > (g 3 4 k: 5 k: 6) (3 4 5) > (h1 7) (7 #f ()) > (h1 7 k: 8 9) (7 8 (k: 8 9)) > (h1 7 k: 8 z: 9) (7 8 (k: 8 z: 9)) > (h2 7) (7 #f ()) > (h2 7 k: 8 9) (7 8 (9)) > (h2 7 k: 8 z: 9) *** ERROR IN (console)@17.1 -- Unknown keyword argument passed to procedure (h2 7 k: 8 z: 9)","title":"define"},{"location":"manual/scheme_extensions/miscellaneous_extensions/","text":"Miscellaneous extensions subvector (subvector vector start end) ;; procedure This procedure is the vector analog of the substring procedure. It returns a newly allocated vector formed from the elements of the vector vector beginning with index start (inclusive) and ending with index end (exclusive). For example: > (subvector '#(a b c d e f) 3 5) #(d e) vector-copy (vector-copy vector [start [end]]) ;; procedure This procedure is like the procedure subvector except the parameter start defaults to 0 and the parameter end defaults to the length of the vector vector. Note that the elements are not recursively copied. For example: > (define v1 '#(a b c d e f)) > (define v2 (vector-copy v1)) > v2 #(a b c d e f) > (eq? v1 v2) #f > (vector-copy v1 3) #(d e f) > (vector-copy v1 3 5) #(d e) vector-copy! (vector-copy! dest-vector dest-start vector [start [end]]) ;; procedure This procedure mutates the vector dest-vector. It copies the elements of the vector vector beginning with index start (inclusive) and ending with index end (exclusive) to the vector dest-vector at index dest-start . The parameters start and end default respectively to 0 and the length of the vector vector . It is an error to copy more elements than will fit in the tail of the vector dest-vector starting at index dest-start . Note that the elements are not recursively copied. For example: > (define v1 (vector 10 11 12 13 14 15)) > (define v2 (vector 20 21 22 23)) > (vector-copy! v1 1 v2) > v1 #(10 20 21 22 23 15) > (vector-copy! v1 1 v2 3) > v1 #(10 23 21 22 23 15) > (vector-copy! v1 1 v2 1 3) > v1 #(10 21 22 22 23 15) vector-append (vector-append vector ...) ;; procedure This procedure is the vector analog of the string-append procedure. It returns a newly allocated vector whose elements form the concatenation of the given vectors. For example: > (define v '#(1 2 3)) > (vector-append v v v) #(1 2 3 1 2 3 1 2 3) vector-concatenate (vector-concatenate lst [separator]) ;; procedure This procedure returns a newly allocated vector whose elements form the concatenation of all the vectors in the list lst . If the optional vector separator argument is specified, it will be added between all the elements of lst. Without the separator argument the result is the same as (apply vector-append lst) . For example: > (define v '#(1 2 3)) > (vector-concatenate (list v v v)) #(1 2 3 1 2 3 1 2 3) > (vector-concatenate (list v v v) '#(88 99)) #(1 2 3 88 99 1 2 3 88 99 1 2 3) subvector-fill! (subvector-fill! vector start end fill) ;; procedure This procedure is like vector-fill! , but fills a selected part of the given vector. It sets the elements of the vector vector , beginning with index start (inclusive) and ending with index end (exclusive) to fill . The value returned is unspecified. For example: > (define v (vector 'a 'b 'c 'd 'e 'f)) > (subvector-fill! v 3 5 'x) > v #(a b c x x f) subvector-move! (subvector-move! src-vector src-start src-end dst-vector dst-start) ;; procedure This procedure replaces part of the contents of vector dst-vector with part of the contents of vector src-vector . It copies elements from src-vector , beginning with index src-start (inclusive) and ending with index src-end (exclusive) to dst-vector beginning with index dst-start (inclusive). The value returned is unspecified. For example: > (define v1 '#(1 2 3 4 5 6)) > (define v2 (vector 'a 'b 'c 'd 'e 'f)) > (subvector-move! v1 3 5 v2 1) > v2 #(a 4 5 d e f) vector-shrink! (vector-shrink! vector k) ;; procedure This procedure shortens the vector vector so that its new size is k . The value returned is unspecified. For example: > (define v (vector 'a 'b 'c 'd 'e 'f)) > v #(a b c d e f) > (vector-shrink! v 3) > v #(a b c) vector-cas! (vector-cas! vector k new-value old-value) ;; procedure The procedure vector-cas! performs an atomic compare-and-swap operation on the element of vector vector at index k . If the element's value is eq? to old-value then the element is changed to new-value , otherwise the value does not change. Regardless what happened, the element's value prior to any change is returned. It is thus possible to detect a change by an explicit eq? test of the result. For example: > (define v (vector 'a)) > (eq? 'foo (vector-cas! v 0 'b 'foo)) #f > v #(a) > (eq? 'a (vector-cas! v 0 'b 'a)) #t > v #(b) vector-inc! (vector-inc! vector k [step]) ;; procedure The procedure vector-inc! performs an atomic incrementation on the element of vector vector at index k , which must be a fixnum. The parameter step defaults to 1 and it is the fixnum value that is added (with wraparound) to the element. The procedure returns the value of the element prior to the incrementation. For example: > (define v (vector 100)) > (vector-inc! v 0) 100 > (vector-inc! v 0) 101 > (vector-inc! v 0 5) 102 > v #(107) vector-set (vector-set vector k obj) ;; procedure The procedure vector-set returns a new copy of the vector vector with the element at index k replaced with obj . For example: > (define v1 (vector 10 11 12 13)) > (define v2 (vector-set v1 2 99)) > v2 #(10 11 99 13) > (eq? v1 v2) #f string-set (string-set string k char) ;; procedure The procedure string-set returns a new copy of the string string with the character at index k replaced with char . For example: > (define s1 (string #\\a #\\b #\\c #\\d)) > (define s2 (string-set s1 2 #\\.)) > s2 \"ab.d\" > (eq? s1 s2) #f string-concatenate (string-concatenate lst [separator]) ;; procedure This procedure returns a newly allocated string which is the concatenation of all the strings in the list lst . If the optional string separator argument is specified, it will be added between all the elements of lst . Without the separator argument the result is the same as (apply string-append lst) . For example: > (define s \"abc\") > (string-concatenate (list s s s)) \"abcabcabc\" > (string-concatenate (list s s s) \",\") \"abc,abc,abc\" substring-fill! (substring-fill! string start end fill) ;; procedure This procedure is like string-fill! , but fills a selected part of the given string . It sets the elements of the string string , beginning with index start (inclusive) and ending with index end (exclusive) to fill . The value returned is unspecified. For example: > (define s (string #\\a #\\b #\\c #\\d #\\e #\\f)) > (substring-fill! s 3 5 #\\x) > s \"abcxxf\" substring-move! (substring-move! src-string src-start src-end dst-string dst-start) ;; procedure This procedure replaces part of the contents of string dst-string with part of the contents of string src-string . It copies elements from src-string , beginning with index src-start (inclusive) and ending with index src-end (exclusive) to dst-string beginning with index dst-start (inclusive). The value returned is unspecified. For example: > (define s1 \"123456\") > (define s2 (string #\\a #\\b #\\c #\\d #\\e #\\f)) > (substring-move! s1 3 5 s2 1) > s2 \"a45def\" string-shrink! (string-shrink! string k) ;; procedure This procedure shortens the string string so that its new size is k . The value returned is unspecified. For example: > (define s (string #\\a #\\b #\\c #\\d #\\e #\\f)) > s \"abcdef\" > (string-shrink! s 3) > s \"abc\" box box? unbox set-box! (box obj) ;; procedure (box? obj) ;; procedure (unbox box) ;; procedure (set-box! box obj) ;; procedure These procedures implement the box data type. A box is a cell containing a single mutable field. The lexical syntax of a box containing the object obj is #&obj (see section Box syntax ). The procedure box returns a new box object whose content is initialized to obj . The procedure box? returns #t if obj is a box, and otherwise returns #f . The procedure unbox returns the content of the box box . The procedure set-box! changes the content of the box box to obj . The procedure set-box! returns an unspecified value. For example: > (define b (box 0)) > b #&0 > (define (inc!) (set-box! b (+ (unbox b) 1))) > (inc!) > b #&1 > (unbox b) 1 keyword? keyword->string string->keyword (keyword? obj) ;; procedure (keyword->string keyword) ;; procedure (string->keyword string) ;; procedure These procedures implement the keyword data type. Keywords are similar to symbols but are self evaluating and distinct from the symbol data type. The lexical syntax of keywords is specified in Keyword syntax . The procedure keyword? returns #t if obj is a keyword, and otherwise returns #f . The procedure keyword->string returns the name of keyword as a string. The procedure string->keyword returns the keyword whose name is string . For example: > (keyword? 'color) #f > (keyword? color:) #t > (keyword->string color:) \"color\" > (string->keyword \"color\") color: gensym (gensym [prefix]) ;; procedure This procedure returns a new uninterned symbol. Uninterned symbols are guaranteed to be distinct from the symbols generated by the procedures read and string->symbol . The symbol prefix is the prefix used to generate the new symbol's name. If it is not specified, the prefix defaults to g . For example: > (gensym) #:g0 > (gensym) #:g1 > (gensym 'star-trek-) #:star-trek-2 string->uninterned-symbol uninterned-symbol? (string->uninterned-symbol name [hash]) ;; procedure (uninterned-symbol? obj) ;; procedure The procedure string->uninterned-symbol returns a new uninterned symbol whose name is name and hash is hash . The name must be a string and the hash must be a nonnegative fixnum. The procedure uninterned-symbol? returns #t when obj is a symbol that is uninterned and #f otherwise. For example: > (uninterned-symbol? (gensym)) #t > (string->uninterned-symbol \"foo\") #:foo: > (uninterned-symbol? (string->uninterned-symbol \"foo\")) #t > (uninterned-symbol? 'hello) #f > (uninterned-symbol? 123) #f string->uninterned-keyword uninterned-keyword? (string->uninterned-keyword name [hash]) ;; procedure (uninterned-keyword? obj) ;; procedure The procedure string->uninterned-keyword returns a new uninterned keyword whose name is name and hash is hash . The name must be a string and the hash must be a nonnegative fixnum. The procedure uninterned-keyword? returns #t when obj is a keyword that is uninterned and #f otherwise. For example: > (string->uninterned-keyword \"foo\") #:foo: > (uninterned-keyword? (string->uninterned-keyword \"foo\")) #t > (uninterned-keyword? hello:) #f > (uninterned-keyword? 123) #f identity (identity obj) ;; procedure This procedure returns obj . void (void) ;; procedure This procedure returns the void object. The read-eval-print loop prints nothing when the result is the void object. eval (eval expr [env]) ;; procedure The first parameter is a datum representing an expression. The eval procedure evaluates this expression in the global interaction environment and returns the result. If present, the second parameter is ignored (it is provided for compatibility with R5RS). For example: > (eval '(+ 1 2)) 3 > ((eval 'car) '(1 2)) 1 > (eval '(define x 5)) > x 5 define-macro (define-macro (name define-formals) body) ;; special form Define name as a macro special form which expands into body . This form can only appear where a define form is acceptable. Macros are lexically scoped. The scope of a local macro definition extends from the definition to the end of the body of the surrounding binding construct. Macros defined at the top level of a Scheme module are only visible in that module. To have access to the macro definitions contained in a file, that file must be included either directly using the include special form or indirectly with the import special form. Macros which are visible from the REPL are also visible during the compilation of Scheme source files. For example: (define-macro (unless test . body) `(if ,test #f (begin ,@body))) (define-macro (push var #!optional val) `(set! ,var (cons ,val ,var))) To examine the code into which a macro expands you can use the compiler's -expansion option or the pp procedure. For example: > (define-macro (push var #!optional val) `(set! ,var (cons ,val ,var))) > (pp (lambda () (push stack 1) (push stack) (push stack 3))) (lambda () (set! stack (cons 1 stack)) (set! stack (cons #f stack)) (set! stack (cons 3 stack))) define-syntax (define-syntax name expander) ;; special form Define name as a macro special form whose expansion is specified by expander . This form is available only when the runtime option -:s is used. This option causes the loading of the ~~lib/syntax-case support library, which is the Hieb and Dybvig portable syntax-case implementation which has been ported to the Gambit interpreter and compiler. Note that this implementation of syntax-case does not support special forms that are specific to Gambit. For example: $ gsi -:s Gambit v4.9.4 > (define-syntax unless (syntax-rules () ((unless test body ...) (if test #f (begin body ...))))) > (let ((test 111)) (unless (= 1 2) (list test test))) (111 111) > (pp (lambda () (let ((test 111)) (unless (= 1 2) (list test test))))) (lambda () ((lambda (%%test14) (if (= 1 2) #f (list %%test14 %%test14))) 111)) > (unless #f (pp xxx)) *** ERROR IN (console)@7.16 -- Unbound variable: xxx compilation-target (compilation-target) ;; procedure This procedure can only be executed during the phase of the Scheme code's processing (compilation) that corresponds to macro expansion. Calls to this procedure are typically contained in macro definitions but they can also be contained in procedures that are called from a macro definition's body directly or indirectly. The result returned by the compilation-target procedure gives an indication of the target language of the compilation. This can be used to write macros that depend on the type of compilation and the target language. When the result is the symbol T the macro expansion is in the context of compiling to the target language T , e.g. C , js , etc. When the result is a single element list (T) the macro expansion is for the interpreter which itself was compiled for the target language T, e.g. (C) , (js) , etc. For example: $ cat ct.scm (define (level-0) (string-append \"0: \" (object->string (compilation-target)))) (define-macro (test) (define (level-1) (string-append \"1: \" (object->string (compilation-target)))) (define-macro (level-2) (string-append \"2: \" (object->string (compilation-target)))) `(list ,(level-1) ,(level-2))) (pp (test)) (pp (level-0)) ;; run time exception $ gsi ct.scm (\"1: (C)\" \"2: (C)\") *** ERROR IN level-0, \"ct.scm\"@2.40 -- Not in compilation context (compilation-target) $ gsc -target js -exe ct.scm $ ./ct (\"1: js\" \"2: (C)\") *** ERROR IN level-0 -- Not in compilation context (compilation-target) Regardless of whether ct.scm is being processed by the interpreter or the compiler, the body of the level-0 procedure is not in a compilation context and in the body of the level-2 macro the compilation target is (C) indicating that the macro expansion is being done for interpretation. During the execution of the level-1 procedure, the compilation target will correspond to what is processing ct.scm (interpreter or compiler). Note that the compilation target can also be tested by the cond-expand special form. cond-expand (cond-expand ce-clause ...) ;; special form The cond-expand expression type provides a way to statically expand different expressions depending on the presence or absence of a set of features. A ce-clause takes the following form: (feature-requirement expression ...) The last clause can be an \"else clause\" which has the form (else expression) A feature-requirement takes one of the following forms: feature-identifier (library library-name) (and feature-requirement ...) (or feature-requirement ...) (not feature-requirement) (compilation-target target ...) The runtime system maintains a list of feature identifiers which are present, as well as a list of libraries which can be imported. The value of a feature-requirement is determined by replacing each feature-identifier and (library library-name) on the runtime system's lists with #t . Similarly, #t replaces each (compilation-target target ...) for which one of the target matches the expansion time value of (compilation-target) , with a target of (_) matching any single element list (i.e. the interpreter). All other feature-identifier, (library library-name) , and (compilation-target target ...) are replaced with #f . The resulting expression is then evaluated as a Scheme boolean expression under the normal interpretation of and , or , and not . A cond-expand is then expanded by evaluating the feature-requirements of successive ce-clauses in order until one of them returns #t . When a true clause is found, the corresponding expressions are expanded to a begin , and the remaining clauses are ignored. If none of the feature-requirements evaluate to #t , then if there is an else clause, its expressions are included. Otherwise, an expansion time error is raised. Unlike cond , cond-expand does not depend on the value of any variables. The feature identifier gambit is always true when the cond-expand is expanded by the Gambit interpreter or compiler. For example: > (cond-expand (foobar 111) (gambit 222) (else 333)) 222 > (cond-expand ((compilation-target js) 111) (else 222)) 222 > (cond-expand ((compilation-target (_)) 111) (else 222)) 111 define-cond-expand-feature (define-cond-expand-feature feature-identifier ...) ;; special form The define-cond-expand-feature form can be used to add the feature identifiers feature-identifier ... to the list of features maintained by the runtime system. These features are usable for the expansion of following cond-expand forms in the same file of source code, and the processing of other files and REPL interactions. For example: > (cond-expand (foobar 111) (gambit 222) (else 333)) 222 > (define-cond-expand-feature foobar) > (cond-expand (foobar 111) (gambit 222) (else 333)) 111 declare (declare declaration\u2026) ;; special form This form introduces declarations to be used by the compiler (currently the interpreter ignores the declarations). This form can only appear where a define form is acceptable. Declarations are lexically scoped in the same way as macros. The following declarations are accepted by the compiler: (dialect) : Use the given dialect's semantics. dialect can be: ieee-scheme , r4rs-scheme , r5rs-scheme or gambit-scheme . (strategy) : Select block compilation or separate compilation. In block compilation, the compiler assumes that global variables defined in the current file that are not mutated in the file will never be mutated. strategy can be: block or separate . ([not] inline) : Allow (or disallow) inlining of user procedures. ([not] inline-primitives primitive ...) : The given primitives primitive ... should (or should not) be inlined if possible (all primitives if none specified). (inlining-limit n) : Select the degree to which the compiler inlines user procedures. n is the upper-bound, in percent, on code expansion that will result from inlining. Thus, a value of 300 indicates that the size of the program will not grow by more than 300 percent (i.e. it will be at most 4 times the size of the original). A value of 0 disables inlining. The size of a program is the total number of subexpressions it contains (i.e. the size of an expression is one plus the size of its immediate subexpressions). The following conditions must hold for a procedure to be inlined: inlining the procedure must not cause the size of the call site to grow more than specified by the inlining limit, the site of definition (the define or lambda ) and the call site must be declared as (inline) , and the compiler must be able to find the definition of the procedure referred to at the call site (if the procedure is bound to a global variable, the definition site must have a (block) declaration). Note that inlining usually causes much less code expansion than specified by the inlining limit (an expansion around 10% is common for n=370 ). (allocation-limit n) : Indicate the maximum size of objects allocated with make-vector, make-string, make-u8vector, etc. Knowing the maximum size allows the compiler to inline calls to these allocators for small allocations. This is only supported by the C target and only up to a size that is allowed for movable objects (typically on the order of 1-2 KB). When n is an exact nonnegative integer it is the upper-bound on the number of elements of the allocated objects. When n is #t a dynamic test of the size is done. When n is #f the allocation operation is not inlined. ([not] lambda-lift) : Lambda-lift (or don't lambda-lift) locally defined procedures. ([not] constant-fold) : Allow (or disallow) constant-folding of primitive procedures. ([not] standard-bindings var ...) : The given global variables var ... are known (or not known) to be equal to the value defined for them in the dialect (all variables defined in the standard if none specified). ([not] extended-bindings var ...) : The given global variables var ... are known (or not known) to be equal to the value defined for them in the runtime system (all variables defined in the runtime if none specified). ([not] run-time-bindings var ...) : The given global variables var ... will be tested at run time to see if they are equal to the value defined for them in the runtime system (all variables defined in the runtime if none specified). ([not] safe) : Generate (or don't generate) code that will prevent fatal errors at run time. Note that in safe mode certain semantic errors will not be checked as long as they can't crash the system. For example the primitive char=? may disregard the type of its arguments in safe as well as not safe mode. ([not] interrupts-enabled) : Generate (or don't generate) interrupt checks. Interrupt checks are used to detect user interrupts and also to check for stack overflows. Interrupt checking should not be turned off casually. ([not] poll-on-return) : Generate (or don't generate) interrupt checks on procedure returns (when interrupt checking is enabled). This declaration has no effect on the behavior of interrupt checking on procedure calls, which is needed to guarantee that stack overflows are handled properly. ([not] debug) : Enable (or disable) the generation of debugging information. The kind of debugging information that is generated depends on the declarations debug-location , debug-source , and debug-environments . If any of the command line options -debug , -debug-location , -debug-source and -debug-environments are present, the debug declaration is initially enabled, otherwise it is initially disabled. When all kinds of debugging information are generated there is a substantial increase in the C compilation time and the size of the generated code. When compiling a 3000 line Scheme file it was observed that the total compilation time is 500% longer and the executable code is 150% bigger. ([not] debug-location) : Select (or deselect) source code location debugging information. When this declaration and the debug declaration are in effect, run time error messages indicate the location of the error in the source code file. If any of the command line options -debug-source and -debug-environments are present and -debug-location is absent, the debug-location declaration is initially disabled, otherwise it is initially enabled. When compiling a 3000 line Scheme file it was observed that the total compilation time is 200% longer and the executable code is 60% bigger. ([not] debug-source) : Select (or deselect) source code debugging information. When this declaration and the debug declaration are in effect, run time error messages indicate the source code, the backtraces are more precise, and the pp procedure will display the source code of compiled procedures. If any of the command line options -debug-location and -debug-environments are present and -debug-source is absent, the debug-source declaration is initially disabled, otherwise it is initially enabled. When compiling a 3000 line Scheme file it was observed that the total compilation time is 90% longer and the executable code is 90% bigger. ([not] debug-environments) : Select (or deselect) environment debugging information. When this declaration and the debug declaration are in effect, the debugger will have access to the environments of the continuations. In other words the local variables defined in compiled procedures (and not optimized away by the compiler) will be shown by the ,e REPL command. If any of the command line options -debug-location and -debug-source are present and -debug-environments is absent, the \u2018debug-environments\u2019 declaration is initially disabled, otherwise it is initially enabled. When compiling a 3000 line Scheme file it was observed that the total compilation time is 70% longer and the executable code is 40% bigger. ([not] proper-tail-calls) : Generate (or don't generate) proper tail calls. When proper tail calls are turned off, tail calls are handled like non-tail calls, that is a continuation frame will be created for all calls regardless of their kind. This is useful for debugging because the caller of a procedure will be visible in the backtrace produced by the REPL's ,b command even when the call is a tail call. Be advised that this does cause stack space to be consumed for tail calls which may cause the stack to overflow when performing long iterations with tail calls (whether they are expressed with a letrec , named let , do , or other form). ([not] generative-lambda) : Force (or don't force) the creation of fresh closures when evaluating lambda-expressions. A fresh closure is always created when a lambda-expression has at least one free variable (that has not been eliminated by dead-code elimination or other compiler optimization) or when the generative-lambda declaration is turned on. When a lambda-expression has no free variables and the generative-lambda declaration is turned off, the value of the lambda-expression may be the same procedure (in the sense of eq? ). ([not] optimize-dead-local-variables) : Remove (or preserve) the dead local variables in the environment. Preserving the dead local variables is useful for debugging because continuations will contain the dead variables. Thus, if the code is also compiled with the declaration debug-environments the ,e , ,ed , ,be , and ,bed REPL commands will display the dead variables. On the other hand, preserving the dead local variables may change the space complexity of the program (i.e. some of the data that would normally be reclaimed by the garbage collector will not be). Note that due to other compiler optimizations some dead local variables may be removed regardless of this declaration. ([not] optimize-dead-definitions var ...) : Remove (or preserve) the dead toplevel definitions of the given global variables var ... (all global variables if none specified). A toplevel definition is dead if it is not referenced by toplevel expressions of the program or toplevel definitions that aren't dead (regardless of the evaluation of its expression causing a side-effect). When a module is separately compiled and some of its definitions are only used by other modules, this declaration must be used with care to keep definitions that are used by other modules, for example if foo is referenced in another module the following declaration should be used: (declare (not optimize-dead-definitions foo)) . (number-type primitive ...) : Numeric arguments and result of the specified primitives primitive ... are known to be of the given type (all primitives if none specified). number-type can be: generic , fixnum , or flonum . (mostly-number-type primitive ...) : Numeric arguments and result of the specified primitives primitive ... are expected to be most often of the given type (all primitives if none specified). mostly-number-type can be: mostly-generic , mostly-fixnum , mostly-fixnum-flonum , mostly-flonum , or mostly-flonum-fixnum . The default declarations used by the compiler are equivalent to: (declare (gambit-scheme) (separate) (inline) (inline-primitives) (inlining-limit 370) (allocation-limit #t) (constant-fold) (lambda-lift) (not standard-bindings) (not extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (not poll-on-return) (not debug) ;; depends on debugging command line options (debug-location) ;; depends on debugging command line options (debug-source) ;; depends on debugging command line options (debug-environments) ;; depends on debugging command line options (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (not optimize-dead-definitions) (generic) (mostly-fixnum-flonum) ) These declarations are compatible with the semantics of R5RS Scheme and includes a few procedures from R6RS (mainly fixnum specific and flonum specific procedures). Typically used declarations that enhance performance, at the cost of violating the R5RS Scheme semantics, are: (standard-bindings) , (block) , (not safe) and (fixnum) . continuation? continuation-capture continuation-graft continuation-return (continuation? obj) ;; procedure (continuation-capture proc) ;; procedure (continuation-graft cont proc obj ...) ;; procedure (continuation-return cont obj ...) ;; procedure These procedures provide access to internal first-class continuations which are represented using continuation objects distinct from procedures. The procedure continuation? returns #t when obj is a continuation object and #f otherwise. The procedure continuation-capture is similar to the call/cc procedure but it represents the continuation with a continuation object. The proc parameter must be a procedure accepting a single argument. The procedure continuation-capture reifies its continuation and calls proc with the corresponding continuation object as its sole argument. Like for call/cc , the implicit continuation of the call to proc is the implicit continuation of the call to continuation-capture . The procedure continuation-graft performs a procedure call to the procedure proc with arguments obj ... and the implicit continuation corresponding to the continuation object cont . The current continuation of the call to procedure continuation-graft is ignored. The procedure continuation-return invokes the implicit continuation corresponding to the continuation object cont with the result(s) obj ... . This procedure can be easily defined in terms of continuation-graft : (define (continuation-return cont . objs) (continuation-graft cont apply values objs)) For example: > (define x #f) > (define p (make-parameter 11)) > (pp (parameterize ((p 22)) (cons 33 (continuation-capture (lambda (c) (set! x c) 44))))) (33 . 44) > x #<continuation #2> > (continuation-return x 55) (33 . 55) > (continuation-graft x (lambda () (expt 2 10))) (33 . 1024) > (continuation-graft x expt 2 10) (33 . 1024) > (continuation-graft x (lambda () (p))) (33 . 22) > (define (map-sqrt1 lst) (call/cc (lambda (k) (map (lambda (x) (if (< x 0) (k 'error) (sqrt x))) lst)))) > (map-sqrt1 '(1 4 9)) (1 2 3) > (map-sqrt1 '(1 -1 9)) error > (define (map-sqrt2 lst) (continuation-capture (lambda (c) (map (lambda (x) (if (< x 0) (continuation-return c 'error) (sqrt x))) lst)))) > (map-sqrt2 '(1 4 9)) (1 2 3) > (map-sqrt2 '(1 -1 9)) error display-exception display-exception-in-context display-procedure-environment display-continuation-environment display-continuation-dynamic-environment display-continuation-backtrace (display-exception exc [port]) ;; procedure (display-exception-in-context exc cont [port]) ;; procedure (display-procedure-environment proc [port]) ;; procedure (display-continuation-environment cont [port]) ;; procedure (display-continuation-dynamic-environment cont [port]) ;; procedure (display-continuation-backtrace cont [port [display-env? [all-frames? [max-head [max-tail [depth]]]]]]) ;; procedure The procedure display-continuation-backtrace displays the frames of the continuation corresponding to the continuation object cont on the port port . If it is not specified, port defaults to the current output-port. The frames are displayed in the same format as the REPL's ,b command. The parameter display-env? , which defaults to #f , controls if the frames are displayed with its environment (the variables accessible and their bindings). The parameter all-frames? , which defaults to #f , controls which frames are displayed. Some frames of ancillary importance, such as internal frames created by the interpreter, are not displayed when all-frames? is #f . Otherwise all frames are displayed. The parameters max-head and max-tail , which default to 10 and 4 respectively, control how many frames are displayed at the head and tail of the continuation. The parameter depth , which defaults to 0 , causes the frame numbers to be offset by that value. For example: > (define x #f) > (define (fib n) (if (< n 2) (continuation-capture (lambda (c) (set! x c) 1)) (+ (fib (- n 1)) (fib (- n 2))))) > (fib 10) 89 > (display-continuation-backtrace x) 0 fib (console)@7:12 (fib (- n 2)) 1 fib (console)@7:12 (fib (- n 2)) 2 fib (console)@7:12 (fib (- n 2)) 3 fib (console)@7:12 (fib (- n 2)) 4 fib (console)@7:12 (fib (- n 2)) 5 (interaction) (console)@8:1 (fib 10) #f > (display-continuation-backtrace x (current-output-port) #f #t) 0 fib (console)@7:12 (fib (- n 2)) 1 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 2 fib (console)@7:12 (fib (- n 2)) 3 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 4 fib (console)@7:12 (fib (- n 2)) 5 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 6 fib (console)@7:12 (fib (- n 2)) 7 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 8 fib (console)@7:12 (fib (- n 2)) 9 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... ... 13 ##with-no-result-expected-toplevel 14 ##repl-debug 15 ##repl-debug-main 16 ##kernel-handlers #f > (display-continuation-backtrace x (current-output-port) #t #f) 0 fib (console)@7:12 (fib (- n 2)) n = 2 1 fib (console)@7:12 (fib (- n 2)) n = 4 2 fib (console)@7:12 (fib (- n 2)) n = 6 3 fib (console)@7:12 (fib (- n 2)) n = 8 4 fib (console)@7:12 (fib (- n 2)) n = 10 5 (interaction) (console)@8:1 (fib 10) #f > (display-continuation-backtrace x (current-output-port) #f #f 2 1 100) 100 fib (console)@7:12 (fib (- n 2)) 101 fib (console)@7:12 (fib (- n 2)) ... 105 (interaction) (console)@8:1 (fib 10) #f","title":"Miscellaneous extensions"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#miscellaneous-extensions","text":"","title":"Miscellaneous extensions"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#subvector","text":"(subvector vector start end) ;; procedure This procedure is the vector analog of the substring procedure. It returns a newly allocated vector formed from the elements of the vector vector beginning with index start (inclusive) and ending with index end (exclusive). For example: > (subvector '#(a b c d e f) 3 5) #(d e)","title":"subvector"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-copy","text":"(vector-copy vector [start [end]]) ;; procedure This procedure is like the procedure subvector except the parameter start defaults to 0 and the parameter end defaults to the length of the vector vector. Note that the elements are not recursively copied. For example: > (define v1 '#(a b c d e f)) > (define v2 (vector-copy v1)) > v2 #(a b c d e f) > (eq? v1 v2) #f > (vector-copy v1 3) #(d e f) > (vector-copy v1 3 5) #(d e)","title":"vector-copy"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-copy_1","text":"(vector-copy! dest-vector dest-start vector [start [end]]) ;; procedure This procedure mutates the vector dest-vector. It copies the elements of the vector vector beginning with index start (inclusive) and ending with index end (exclusive) to the vector dest-vector at index dest-start . The parameters start and end default respectively to 0 and the length of the vector vector . It is an error to copy more elements than will fit in the tail of the vector dest-vector starting at index dest-start . Note that the elements are not recursively copied. For example: > (define v1 (vector 10 11 12 13 14 15)) > (define v2 (vector 20 21 22 23)) > (vector-copy! v1 1 v2) > v1 #(10 20 21 22 23 15) > (vector-copy! v1 1 v2 3) > v1 #(10 23 21 22 23 15) > (vector-copy! v1 1 v2 1 3) > v1 #(10 21 22 22 23 15)","title":"vector-copy!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-append","text":"(vector-append vector ...) ;; procedure This procedure is the vector analog of the string-append procedure. It returns a newly allocated vector whose elements form the concatenation of the given vectors. For example: > (define v '#(1 2 3)) > (vector-append v v v) #(1 2 3 1 2 3 1 2 3)","title":"vector-append"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-concatenate","text":"(vector-concatenate lst [separator]) ;; procedure This procedure returns a newly allocated vector whose elements form the concatenation of all the vectors in the list lst . If the optional vector separator argument is specified, it will be added between all the elements of lst. Without the separator argument the result is the same as (apply vector-append lst) . For example: > (define v '#(1 2 3)) > (vector-concatenate (list v v v)) #(1 2 3 1 2 3 1 2 3) > (vector-concatenate (list v v v) '#(88 99)) #(1 2 3 88 99 1 2 3 88 99 1 2 3)","title":"vector-concatenate"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#subvector-fill","text":"(subvector-fill! vector start end fill) ;; procedure This procedure is like vector-fill! , but fills a selected part of the given vector. It sets the elements of the vector vector , beginning with index start (inclusive) and ending with index end (exclusive) to fill . The value returned is unspecified. For example: > (define v (vector 'a 'b 'c 'd 'e 'f)) > (subvector-fill! v 3 5 'x) > v #(a b c x x f)","title":"subvector-fill!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#subvector-move","text":"(subvector-move! src-vector src-start src-end dst-vector dst-start) ;; procedure This procedure replaces part of the contents of vector dst-vector with part of the contents of vector src-vector . It copies elements from src-vector , beginning with index src-start (inclusive) and ending with index src-end (exclusive) to dst-vector beginning with index dst-start (inclusive). The value returned is unspecified. For example: > (define v1 '#(1 2 3 4 5 6)) > (define v2 (vector 'a 'b 'c 'd 'e 'f)) > (subvector-move! v1 3 5 v2 1) > v2 #(a 4 5 d e f)","title":"subvector-move!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-shrink","text":"(vector-shrink! vector k) ;; procedure This procedure shortens the vector vector so that its new size is k . The value returned is unspecified. For example: > (define v (vector 'a 'b 'c 'd 'e 'f)) > v #(a b c d e f) > (vector-shrink! v 3) > v #(a b c)","title":"vector-shrink!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-cas","text":"(vector-cas! vector k new-value old-value) ;; procedure The procedure vector-cas! performs an atomic compare-and-swap operation on the element of vector vector at index k . If the element's value is eq? to old-value then the element is changed to new-value , otherwise the value does not change. Regardless what happened, the element's value prior to any change is returned. It is thus possible to detect a change by an explicit eq? test of the result. For example: > (define v (vector 'a)) > (eq? 'foo (vector-cas! v 0 'b 'foo)) #f > v #(a) > (eq? 'a (vector-cas! v 0 'b 'a)) #t > v #(b)","title":"vector-cas!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-inc","text":"(vector-inc! vector k [step]) ;; procedure The procedure vector-inc! performs an atomic incrementation on the element of vector vector at index k , which must be a fixnum. The parameter step defaults to 1 and it is the fixnum value that is added (with wraparound) to the element. The procedure returns the value of the element prior to the incrementation. For example: > (define v (vector 100)) > (vector-inc! v 0) 100 > (vector-inc! v 0) 101 > (vector-inc! v 0 5) 102 > v #(107)","title":"vector-inc!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#vector-set","text":"(vector-set vector k obj) ;; procedure The procedure vector-set returns a new copy of the vector vector with the element at index k replaced with obj . For example: > (define v1 (vector 10 11 12 13)) > (define v2 (vector-set v1 2 99)) > v2 #(10 11 99 13) > (eq? v1 v2) #f","title":"vector-set"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#string-set","text":"(string-set string k char) ;; procedure The procedure string-set returns a new copy of the string string with the character at index k replaced with char . For example: > (define s1 (string #\\a #\\b #\\c #\\d)) > (define s2 (string-set s1 2 #\\.)) > s2 \"ab.d\" > (eq? s1 s2) #f","title":"string-set"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#string-concatenate","text":"(string-concatenate lst [separator]) ;; procedure This procedure returns a newly allocated string which is the concatenation of all the strings in the list lst . If the optional string separator argument is specified, it will be added between all the elements of lst . Without the separator argument the result is the same as (apply string-append lst) . For example: > (define s \"abc\") > (string-concatenate (list s s s)) \"abcabcabc\" > (string-concatenate (list s s s) \",\") \"abc,abc,abc\"","title":"string-concatenate"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#substring-fill","text":"(substring-fill! string start end fill) ;; procedure This procedure is like string-fill! , but fills a selected part of the given string . It sets the elements of the string string , beginning with index start (inclusive) and ending with index end (exclusive) to fill . The value returned is unspecified. For example: > (define s (string #\\a #\\b #\\c #\\d #\\e #\\f)) > (substring-fill! s 3 5 #\\x) > s \"abcxxf\"","title":"substring-fill!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#substring-move","text":"(substring-move! src-string src-start src-end dst-string dst-start) ;; procedure This procedure replaces part of the contents of string dst-string with part of the contents of string src-string . It copies elements from src-string , beginning with index src-start (inclusive) and ending with index src-end (exclusive) to dst-string beginning with index dst-start (inclusive). The value returned is unspecified. For example: > (define s1 \"123456\") > (define s2 (string #\\a #\\b #\\c #\\d #\\e #\\f)) > (substring-move! s1 3 5 s2 1) > s2 \"a45def\"","title":"substring-move!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#string-shrink","text":"(string-shrink! string k) ;; procedure This procedure shortens the string string so that its new size is k . The value returned is unspecified. For example: > (define s (string #\\a #\\b #\\c #\\d #\\e #\\f)) > s \"abcdef\" > (string-shrink! s 3) > s \"abc\"","title":"string-shrink!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#box","text":"","title":"box"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#box_1","text":"","title":"box?"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#unbox","text":"","title":"unbox"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#set-box","text":"(box obj) ;; procedure (box? obj) ;; procedure (unbox box) ;; procedure (set-box! box obj) ;; procedure These procedures implement the box data type. A box is a cell containing a single mutable field. The lexical syntax of a box containing the object obj is #&obj (see section Box syntax ). The procedure box returns a new box object whose content is initialized to obj . The procedure box? returns #t if obj is a box, and otherwise returns #f . The procedure unbox returns the content of the box box . The procedure set-box! changes the content of the box box to obj . The procedure set-box! returns an unspecified value. For example: > (define b (box 0)) > b #&0 > (define (inc!) (set-box! b (+ (unbox b) 1))) > (inc!) > b #&1 > (unbox b) 1","title":"set-box!"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#keyword","text":"","title":"keyword?"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#keyword-string","text":"","title":"keyword-&gt;string"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#string-keyword","text":"(keyword? obj) ;; procedure (keyword->string keyword) ;; procedure (string->keyword string) ;; procedure These procedures implement the keyword data type. Keywords are similar to symbols but are self evaluating and distinct from the symbol data type. The lexical syntax of keywords is specified in Keyword syntax . The procedure keyword? returns #t if obj is a keyword, and otherwise returns #f . The procedure keyword->string returns the name of keyword as a string. The procedure string->keyword returns the keyword whose name is string . For example: > (keyword? 'color) #f > (keyword? color:) #t > (keyword->string color:) \"color\" > (string->keyword \"color\") color:","title":"string-&gt;keyword"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#gensym","text":"(gensym [prefix]) ;; procedure This procedure returns a new uninterned symbol. Uninterned symbols are guaranteed to be distinct from the symbols generated by the procedures read and string->symbol . The symbol prefix is the prefix used to generate the new symbol's name. If it is not specified, the prefix defaults to g . For example: > (gensym) #:g0 > (gensym) #:g1 > (gensym 'star-trek-) #:star-trek-2","title":"gensym"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#string-uninterned-symbol","text":"","title":"string-&gt;uninterned-symbol"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#uninterned-symbol","text":"(string->uninterned-symbol name [hash]) ;; procedure (uninterned-symbol? obj) ;; procedure The procedure string->uninterned-symbol returns a new uninterned symbol whose name is name and hash is hash . The name must be a string and the hash must be a nonnegative fixnum. The procedure uninterned-symbol? returns #t when obj is a symbol that is uninterned and #f otherwise. For example: > (uninterned-symbol? (gensym)) #t > (string->uninterned-symbol \"foo\") #:foo: > (uninterned-symbol? (string->uninterned-symbol \"foo\")) #t > (uninterned-symbol? 'hello) #f > (uninterned-symbol? 123) #f","title":"uninterned-symbol?"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#string-uninterned-keyword","text":"","title":"string-&gt;uninterned-keyword"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#uninterned-keyword","text":"(string->uninterned-keyword name [hash]) ;; procedure (uninterned-keyword? obj) ;; procedure The procedure string->uninterned-keyword returns a new uninterned keyword whose name is name and hash is hash . The name must be a string and the hash must be a nonnegative fixnum. The procedure uninterned-keyword? returns #t when obj is a keyword that is uninterned and #f otherwise. For example: > (string->uninterned-keyword \"foo\") #:foo: > (uninterned-keyword? (string->uninterned-keyword \"foo\")) #t > (uninterned-keyword? hello:) #f > (uninterned-keyword? 123) #f","title":"uninterned-keyword?"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#identity","text":"(identity obj) ;; procedure This procedure returns obj .","title":"identity"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#void","text":"(void) ;; procedure This procedure returns the void object. The read-eval-print loop prints nothing when the result is the void object.","title":"void"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#eval","text":"(eval expr [env]) ;; procedure The first parameter is a datum representing an expression. The eval procedure evaluates this expression in the global interaction environment and returns the result. If present, the second parameter is ignored (it is provided for compatibility with R5RS). For example: > (eval '(+ 1 2)) 3 > ((eval 'car) '(1 2)) 1 > (eval '(define x 5)) > x 5","title":"eval"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#define-macro","text":"(define-macro (name define-formals) body) ;; special form Define name as a macro special form which expands into body . This form can only appear where a define form is acceptable. Macros are lexically scoped. The scope of a local macro definition extends from the definition to the end of the body of the surrounding binding construct. Macros defined at the top level of a Scheme module are only visible in that module. To have access to the macro definitions contained in a file, that file must be included either directly using the include special form or indirectly with the import special form. Macros which are visible from the REPL are also visible during the compilation of Scheme source files. For example: (define-macro (unless test . body) `(if ,test #f (begin ,@body))) (define-macro (push var #!optional val) `(set! ,var (cons ,val ,var))) To examine the code into which a macro expands you can use the compiler's -expansion option or the pp procedure. For example: > (define-macro (push var #!optional val) `(set! ,var (cons ,val ,var))) > (pp (lambda () (push stack 1) (push stack) (push stack 3))) (lambda () (set! stack (cons 1 stack)) (set! stack (cons #f stack)) (set! stack (cons 3 stack)))","title":"define-macro"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#define-syntax","text":"(define-syntax name expander) ;; special form Define name as a macro special form whose expansion is specified by expander . This form is available only when the runtime option -:s is used. This option causes the loading of the ~~lib/syntax-case support library, which is the Hieb and Dybvig portable syntax-case implementation which has been ported to the Gambit interpreter and compiler. Note that this implementation of syntax-case does not support special forms that are specific to Gambit. For example: $ gsi -:s Gambit v4.9.4 > (define-syntax unless (syntax-rules () ((unless test body ...) (if test #f (begin body ...))))) > (let ((test 111)) (unless (= 1 2) (list test test))) (111 111) > (pp (lambda () (let ((test 111)) (unless (= 1 2) (list test test))))) (lambda () ((lambda (%%test14) (if (= 1 2) #f (list %%test14 %%test14))) 111)) > (unless #f (pp xxx)) *** ERROR IN (console)@7.16 -- Unbound variable: xxx","title":"define-syntax"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#compilation-target","text":"(compilation-target) ;; procedure This procedure can only be executed during the phase of the Scheme code's processing (compilation) that corresponds to macro expansion. Calls to this procedure are typically contained in macro definitions but they can also be contained in procedures that are called from a macro definition's body directly or indirectly. The result returned by the compilation-target procedure gives an indication of the target language of the compilation. This can be used to write macros that depend on the type of compilation and the target language. When the result is the symbol T the macro expansion is in the context of compiling to the target language T , e.g. C , js , etc. When the result is a single element list (T) the macro expansion is for the interpreter which itself was compiled for the target language T, e.g. (C) , (js) , etc. For example: $ cat ct.scm (define (level-0) (string-append \"0: \" (object->string (compilation-target)))) (define-macro (test) (define (level-1) (string-append \"1: \" (object->string (compilation-target)))) (define-macro (level-2) (string-append \"2: \" (object->string (compilation-target)))) `(list ,(level-1) ,(level-2))) (pp (test)) (pp (level-0)) ;; run time exception $ gsi ct.scm (\"1: (C)\" \"2: (C)\") *** ERROR IN level-0, \"ct.scm\"@2.40 -- Not in compilation context (compilation-target) $ gsc -target js -exe ct.scm $ ./ct (\"1: js\" \"2: (C)\") *** ERROR IN level-0 -- Not in compilation context (compilation-target) Regardless of whether ct.scm is being processed by the interpreter or the compiler, the body of the level-0 procedure is not in a compilation context and in the body of the level-2 macro the compilation target is (C) indicating that the macro expansion is being done for interpretation. During the execution of the level-1 procedure, the compilation target will correspond to what is processing ct.scm (interpreter or compiler). Note that the compilation target can also be tested by the cond-expand special form.","title":"compilation-target"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#cond-expand","text":"(cond-expand ce-clause ...) ;; special form The cond-expand expression type provides a way to statically expand different expressions depending on the presence or absence of a set of features. A ce-clause takes the following form: (feature-requirement expression ...) The last clause can be an \"else clause\" which has the form (else expression) A feature-requirement takes one of the following forms: feature-identifier (library library-name) (and feature-requirement ...) (or feature-requirement ...) (not feature-requirement) (compilation-target target ...) The runtime system maintains a list of feature identifiers which are present, as well as a list of libraries which can be imported. The value of a feature-requirement is determined by replacing each feature-identifier and (library library-name) on the runtime system's lists with #t . Similarly, #t replaces each (compilation-target target ...) for which one of the target matches the expansion time value of (compilation-target) , with a target of (_) matching any single element list (i.e. the interpreter). All other feature-identifier, (library library-name) , and (compilation-target target ...) are replaced with #f . The resulting expression is then evaluated as a Scheme boolean expression under the normal interpretation of and , or , and not . A cond-expand is then expanded by evaluating the feature-requirements of successive ce-clauses in order until one of them returns #t . When a true clause is found, the corresponding expressions are expanded to a begin , and the remaining clauses are ignored. If none of the feature-requirements evaluate to #t , then if there is an else clause, its expressions are included. Otherwise, an expansion time error is raised. Unlike cond , cond-expand does not depend on the value of any variables. The feature identifier gambit is always true when the cond-expand is expanded by the Gambit interpreter or compiler. For example: > (cond-expand (foobar 111) (gambit 222) (else 333)) 222 > (cond-expand ((compilation-target js) 111) (else 222)) 222 > (cond-expand ((compilation-target (_)) 111) (else 222)) 111","title":"cond-expand"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#define-cond-expand-feature","text":"(define-cond-expand-feature feature-identifier ...) ;; special form The define-cond-expand-feature form can be used to add the feature identifiers feature-identifier ... to the list of features maintained by the runtime system. These features are usable for the expansion of following cond-expand forms in the same file of source code, and the processing of other files and REPL interactions. For example: > (cond-expand (foobar 111) (gambit 222) (else 333)) 222 > (define-cond-expand-feature foobar) > (cond-expand (foobar 111) (gambit 222) (else 333)) 111","title":"define-cond-expand-feature"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#declare","text":"(declare declaration\u2026) ;; special form This form introduces declarations to be used by the compiler (currently the interpreter ignores the declarations). This form can only appear where a define form is acceptable. Declarations are lexically scoped in the same way as macros. The following declarations are accepted by the compiler: (dialect) : Use the given dialect's semantics. dialect can be: ieee-scheme , r4rs-scheme , r5rs-scheme or gambit-scheme . (strategy) : Select block compilation or separate compilation. In block compilation, the compiler assumes that global variables defined in the current file that are not mutated in the file will never be mutated. strategy can be: block or separate . ([not] inline) : Allow (or disallow) inlining of user procedures. ([not] inline-primitives primitive ...) : The given primitives primitive ... should (or should not) be inlined if possible (all primitives if none specified). (inlining-limit n) : Select the degree to which the compiler inlines user procedures. n is the upper-bound, in percent, on code expansion that will result from inlining. Thus, a value of 300 indicates that the size of the program will not grow by more than 300 percent (i.e. it will be at most 4 times the size of the original). A value of 0 disables inlining. The size of a program is the total number of subexpressions it contains (i.e. the size of an expression is one plus the size of its immediate subexpressions). The following conditions must hold for a procedure to be inlined: inlining the procedure must not cause the size of the call site to grow more than specified by the inlining limit, the site of definition (the define or lambda ) and the call site must be declared as (inline) , and the compiler must be able to find the definition of the procedure referred to at the call site (if the procedure is bound to a global variable, the definition site must have a (block) declaration). Note that inlining usually causes much less code expansion than specified by the inlining limit (an expansion around 10% is common for n=370 ). (allocation-limit n) : Indicate the maximum size of objects allocated with make-vector, make-string, make-u8vector, etc. Knowing the maximum size allows the compiler to inline calls to these allocators for small allocations. This is only supported by the C target and only up to a size that is allowed for movable objects (typically on the order of 1-2 KB). When n is an exact nonnegative integer it is the upper-bound on the number of elements of the allocated objects. When n is #t a dynamic test of the size is done. When n is #f the allocation operation is not inlined. ([not] lambda-lift) : Lambda-lift (or don't lambda-lift) locally defined procedures. ([not] constant-fold) : Allow (or disallow) constant-folding of primitive procedures. ([not] standard-bindings var ...) : The given global variables var ... are known (or not known) to be equal to the value defined for them in the dialect (all variables defined in the standard if none specified). ([not] extended-bindings var ...) : The given global variables var ... are known (or not known) to be equal to the value defined for them in the runtime system (all variables defined in the runtime if none specified). ([not] run-time-bindings var ...) : The given global variables var ... will be tested at run time to see if they are equal to the value defined for them in the runtime system (all variables defined in the runtime if none specified). ([not] safe) : Generate (or don't generate) code that will prevent fatal errors at run time. Note that in safe mode certain semantic errors will not be checked as long as they can't crash the system. For example the primitive char=? may disregard the type of its arguments in safe as well as not safe mode. ([not] interrupts-enabled) : Generate (or don't generate) interrupt checks. Interrupt checks are used to detect user interrupts and also to check for stack overflows. Interrupt checking should not be turned off casually. ([not] poll-on-return) : Generate (or don't generate) interrupt checks on procedure returns (when interrupt checking is enabled). This declaration has no effect on the behavior of interrupt checking on procedure calls, which is needed to guarantee that stack overflows are handled properly. ([not] debug) : Enable (or disable) the generation of debugging information. The kind of debugging information that is generated depends on the declarations debug-location , debug-source , and debug-environments . If any of the command line options -debug , -debug-location , -debug-source and -debug-environments are present, the debug declaration is initially enabled, otherwise it is initially disabled. When all kinds of debugging information are generated there is a substantial increase in the C compilation time and the size of the generated code. When compiling a 3000 line Scheme file it was observed that the total compilation time is 500% longer and the executable code is 150% bigger. ([not] debug-location) : Select (or deselect) source code location debugging information. When this declaration and the debug declaration are in effect, run time error messages indicate the location of the error in the source code file. If any of the command line options -debug-source and -debug-environments are present and -debug-location is absent, the debug-location declaration is initially disabled, otherwise it is initially enabled. When compiling a 3000 line Scheme file it was observed that the total compilation time is 200% longer and the executable code is 60% bigger. ([not] debug-source) : Select (or deselect) source code debugging information. When this declaration and the debug declaration are in effect, run time error messages indicate the source code, the backtraces are more precise, and the pp procedure will display the source code of compiled procedures. If any of the command line options -debug-location and -debug-environments are present and -debug-source is absent, the debug-source declaration is initially disabled, otherwise it is initially enabled. When compiling a 3000 line Scheme file it was observed that the total compilation time is 90% longer and the executable code is 90% bigger. ([not] debug-environments) : Select (or deselect) environment debugging information. When this declaration and the debug declaration are in effect, the debugger will have access to the environments of the continuations. In other words the local variables defined in compiled procedures (and not optimized away by the compiler) will be shown by the ,e REPL command. If any of the command line options -debug-location and -debug-source are present and -debug-environments is absent, the \u2018debug-environments\u2019 declaration is initially disabled, otherwise it is initially enabled. When compiling a 3000 line Scheme file it was observed that the total compilation time is 70% longer and the executable code is 40% bigger. ([not] proper-tail-calls) : Generate (or don't generate) proper tail calls. When proper tail calls are turned off, tail calls are handled like non-tail calls, that is a continuation frame will be created for all calls regardless of their kind. This is useful for debugging because the caller of a procedure will be visible in the backtrace produced by the REPL's ,b command even when the call is a tail call. Be advised that this does cause stack space to be consumed for tail calls which may cause the stack to overflow when performing long iterations with tail calls (whether they are expressed with a letrec , named let , do , or other form). ([not] generative-lambda) : Force (or don't force) the creation of fresh closures when evaluating lambda-expressions. A fresh closure is always created when a lambda-expression has at least one free variable (that has not been eliminated by dead-code elimination or other compiler optimization) or when the generative-lambda declaration is turned on. When a lambda-expression has no free variables and the generative-lambda declaration is turned off, the value of the lambda-expression may be the same procedure (in the sense of eq? ). ([not] optimize-dead-local-variables) : Remove (or preserve) the dead local variables in the environment. Preserving the dead local variables is useful for debugging because continuations will contain the dead variables. Thus, if the code is also compiled with the declaration debug-environments the ,e , ,ed , ,be , and ,bed REPL commands will display the dead variables. On the other hand, preserving the dead local variables may change the space complexity of the program (i.e. some of the data that would normally be reclaimed by the garbage collector will not be). Note that due to other compiler optimizations some dead local variables may be removed regardless of this declaration. ([not] optimize-dead-definitions var ...) : Remove (or preserve) the dead toplevel definitions of the given global variables var ... (all global variables if none specified). A toplevel definition is dead if it is not referenced by toplevel expressions of the program or toplevel definitions that aren't dead (regardless of the evaluation of its expression causing a side-effect). When a module is separately compiled and some of its definitions are only used by other modules, this declaration must be used with care to keep definitions that are used by other modules, for example if foo is referenced in another module the following declaration should be used: (declare (not optimize-dead-definitions foo)) . (number-type primitive ...) : Numeric arguments and result of the specified primitives primitive ... are known to be of the given type (all primitives if none specified). number-type can be: generic , fixnum , or flonum . (mostly-number-type primitive ...) : Numeric arguments and result of the specified primitives primitive ... are expected to be most often of the given type (all primitives if none specified). mostly-number-type can be: mostly-generic , mostly-fixnum , mostly-fixnum-flonum , mostly-flonum , or mostly-flonum-fixnum . The default declarations used by the compiler are equivalent to: (declare (gambit-scheme) (separate) (inline) (inline-primitives) (inlining-limit 370) (allocation-limit #t) (constant-fold) (lambda-lift) (not standard-bindings) (not extended-bindings) (run-time-bindings) (safe) (interrupts-enabled) (not poll-on-return) (not debug) ;; depends on debugging command line options (debug-location) ;; depends on debugging command line options (debug-source) ;; depends on debugging command line options (debug-environments) ;; depends on debugging command line options (proper-tail-calls) (not generative-lambda) (optimize-dead-local-variables) (not optimize-dead-definitions) (generic) (mostly-fixnum-flonum) ) These declarations are compatible with the semantics of R5RS Scheme and includes a few procedures from R6RS (mainly fixnum specific and flonum specific procedures). Typically used declarations that enhance performance, at the cost of violating the R5RS Scheme semantics, are: (standard-bindings) , (block) , (not safe) and (fixnum) .","title":"declare"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#continuation","text":"","title":"continuation?"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#continuation-capture","text":"","title":"continuation-capture"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#continuation-graft","text":"","title":"continuation-graft"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#continuation-return","text":"(continuation? obj) ;; procedure (continuation-capture proc) ;; procedure (continuation-graft cont proc obj ...) ;; procedure (continuation-return cont obj ...) ;; procedure These procedures provide access to internal first-class continuations which are represented using continuation objects distinct from procedures. The procedure continuation? returns #t when obj is a continuation object and #f otherwise. The procedure continuation-capture is similar to the call/cc procedure but it represents the continuation with a continuation object. The proc parameter must be a procedure accepting a single argument. The procedure continuation-capture reifies its continuation and calls proc with the corresponding continuation object as its sole argument. Like for call/cc , the implicit continuation of the call to proc is the implicit continuation of the call to continuation-capture . The procedure continuation-graft performs a procedure call to the procedure proc with arguments obj ... and the implicit continuation corresponding to the continuation object cont . The current continuation of the call to procedure continuation-graft is ignored. The procedure continuation-return invokes the implicit continuation corresponding to the continuation object cont with the result(s) obj ... . This procedure can be easily defined in terms of continuation-graft : (define (continuation-return cont . objs) (continuation-graft cont apply values objs)) For example: > (define x #f) > (define p (make-parameter 11)) > (pp (parameterize ((p 22)) (cons 33 (continuation-capture (lambda (c) (set! x c) 44))))) (33 . 44) > x #<continuation #2> > (continuation-return x 55) (33 . 55) > (continuation-graft x (lambda () (expt 2 10))) (33 . 1024) > (continuation-graft x expt 2 10) (33 . 1024) > (continuation-graft x (lambda () (p))) (33 . 22) > (define (map-sqrt1 lst) (call/cc (lambda (k) (map (lambda (x) (if (< x 0) (k 'error) (sqrt x))) lst)))) > (map-sqrt1 '(1 4 9)) (1 2 3) > (map-sqrt1 '(1 -1 9)) error > (define (map-sqrt2 lst) (continuation-capture (lambda (c) (map (lambda (x) (if (< x 0) (continuation-return c 'error) (sqrt x))) lst)))) > (map-sqrt2 '(1 4 9)) (1 2 3) > (map-sqrt2 '(1 -1 9)) error","title":"continuation-return"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#display-exception","text":"","title":"display-exception"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#display-exception-in-context","text":"","title":"display-exception-in-context"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#display-procedure-environment","text":"","title":"display-procedure-environment"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#display-continuation-environment","text":"","title":"display-continuation-environment"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#display-continuation-dynamic-environment","text":"","title":"display-continuation-dynamic-environment"},{"location":"manual/scheme_extensions/miscellaneous_extensions/#display-continuation-backtrace","text":"(display-exception exc [port]) ;; procedure (display-exception-in-context exc cont [port]) ;; procedure (display-procedure-environment proc [port]) ;; procedure (display-continuation-environment cont [port]) ;; procedure (display-continuation-dynamic-environment cont [port]) ;; procedure (display-continuation-backtrace cont [port [display-env? [all-frames? [max-head [max-tail [depth]]]]]]) ;; procedure The procedure display-continuation-backtrace displays the frames of the continuation corresponding to the continuation object cont on the port port . If it is not specified, port defaults to the current output-port. The frames are displayed in the same format as the REPL's ,b command. The parameter display-env? , which defaults to #f , controls if the frames are displayed with its environment (the variables accessible and their bindings). The parameter all-frames? , which defaults to #f , controls which frames are displayed. Some frames of ancillary importance, such as internal frames created by the interpreter, are not displayed when all-frames? is #f . Otherwise all frames are displayed. The parameters max-head and max-tail , which default to 10 and 4 respectively, control how many frames are displayed at the head and tail of the continuation. The parameter depth , which defaults to 0 , causes the frame numbers to be offset by that value. For example: > (define x #f) > (define (fib n) (if (< n 2) (continuation-capture (lambda (c) (set! x c) 1)) (+ (fib (- n 1)) (fib (- n 2))))) > (fib 10) 89 > (display-continuation-backtrace x) 0 fib (console)@7:12 (fib (- n 2)) 1 fib (console)@7:12 (fib (- n 2)) 2 fib (console)@7:12 (fib (- n 2)) 3 fib (console)@7:12 (fib (- n 2)) 4 fib (console)@7:12 (fib (- n 2)) 5 (interaction) (console)@8:1 (fib 10) #f > (display-continuation-backtrace x (current-output-port) #f #t) 0 fib (console)@7:12 (fib (- n 2)) 1 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 2 fib (console)@7:12 (fib (- n 2)) 3 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 4 fib (console)@7:12 (fib (- n 2)) 5 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 6 fib (console)@7:12 (fib (- n 2)) 7 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... 8 fib (console)@7:12 (fib (- n 2)) 9 fib (console)@6:9 (+ (fib (- n 1)) (fib (- ... ... 13 ##with-no-result-expected-toplevel 14 ##repl-debug 15 ##repl-debug-main 16 ##kernel-handlers #f > (display-continuation-backtrace x (current-output-port) #t #f) 0 fib (console)@7:12 (fib (- n 2)) n = 2 1 fib (console)@7:12 (fib (- n 2)) n = 4 2 fib (console)@7:12 (fib (- n 2)) n = 6 3 fib (console)@7:12 (fib (- n 2)) n = 8 4 fib (console)@7:12 (fib (- n 2)) n = 10 5 (interaction) (console)@8:1 (fib 10) #f > (display-continuation-backtrace x (current-output-port) #f #f 2 1 100) 100 fib (console)@7:12 (fib (- n 2)) 101 fib (console)@7:12 (fib (- n 2)) ... 105 (interaction) (console)@8:1 (fib 10) #f","title":"display-continuation-backtrace"},{"location":"manual/scheme_extensions/undocumented_extensions/","text":"Undocumented extensions The procedures in this section are not yet documented. make-thread-group (make-thread-group [name [thread-group]]) ;; procedure thread-group? (thread-group? obj) ;; procedure thread-group-name (thread-group-name thread-group) ;; procedure thread-group-parent (thread-group-parent thread-group) ;; procedure thread-group-resume! (thread-group-resume! thread-group) ;; procedure thread-group-suspend! (thread-group-suspend! thread-group) ;; procedure thread-group-terminate! (thread-group-terminate! thread-group) ;; procedure thread-group->thread-group-list (thread-group->thread-group-list thread-group) ;; procedure thread-group->thread-group-vector (thread-group->thread-group-vector thread-group) ;; procedure thread-group->thread-list (thread-group->thread-list thread-group) ;; procedure thread-group->thread-vector (thread-group->thread-vector thread-group) ;; procedure thread-group-specific (thread-group-specific thread-group) ;; procedure thread-group-specific-set! (thread-group-specific-set! thread-group obj) ;; procedure thread-state (thread-state thread) ;; procedure thread-state-uninitialized? (thread-state-uninitialized? thread-state) ;; procedure thread-state-initialized? (thread-state-initialized? thread-state) ;; procedure thread-state-running? (thread-state-running? thread-state) ;; procedure thread-state-running-processor (thread-state-running-processor thread-state) ;; procedure thread-state-waiting? (thread-state-waiting? thread-state) ;; procedure thread-state-waiting-for (thread-state-waiting-for thread-state) ;; procedure thread-state-waiting-timeout (thread-state-waiting-timeout thread-state) ;; procedure thread-state-normally-terminated? (thread-state-normally-terminated? thread-state) ;; procedure thread-state-normally-terminated-result (thread-state-normally-terminated-result thread-state) ;; procedure thread-state-abnormally-terminated? (thread-state-abnormally-terminated? thread-state) ;; procedure thread-state-abnormally-terminated-reason (thread-state-abnormally-terminated-reason thread-state) ;; procedure top (top [timeout [thread-group [port]]]) ;; procedure thread-interrupt! (thread-interrupt! thread [thunk]) ;; procedure thread-suspend! (thread-suspend! thread) ;; procedure thread-resume! (thread-resume! thread) ;; procedure thread-thread-group (thread-thread-group thread) ;; procedure define-type-of-thread (define-type-of-thread name field\u2026) ;; special form thread-init! (thread-init! thread thunk [name [thread-group]]) ;; procedure initialized-thread-exception? (initialized-thread-exception? obj) ;; procedure initialized-thread-exception-procedure (initialized-thread-exception-procedure exc) ;; procedure initialized-thread-exception-arguments (initialized-thread-exception-arguments exc) ;; procedure uninitialized-thread-exception? (uninitialized-thread-exception? obj) ;; procedure uninitialized-thread-exception-procedure (uninitialized-thread-exception-procedure exc) ;; procedure uninitialized-thread-exception-arguments (uninitialized-thread-exception-arguments exc) ;; procedure inactive-thread-exception? (inactive-thread-exception? obj) ;; procedure inactive-thread-exception-procedure (inactive-thread-exception-procedure exc) ;; procedure inactive-thread-exception-arguments (inactive-thread-exception-arguments exc) ;; procedure rpc-remote-error-exception? (rpc-remote-error-exception? obj) ;; procedure rpc-remote-error-exception-procedure (rpc-remote-error-exception-procedure exc) ;; procedure rpc-remote-error-exception-arguments (rpc-remote-error-exception-arguments exc) ;; procedure rpc-remote-error-exception-message (rpc-remote-error-exception-message exc) ;; procedure invalid-utf8-encoding-exception? (invalid-utf8-encoding-exception? obj) ;; procedure invalid-utf8-encoding-exception-procedure (invalid-utf8-encoding-exception-procedure exc) ;; procedure invalid-utf8-encoding-exception-arguments (invalid-utf8-encoding-exception-arguments exc) ;; procedure module-not-found-exception? (module-not-found-exception? obj) ;; procedure module-not-found-exception-procedure (module-not-found-exception-procedure exc) ;; procedure module-not-found-exception-arguments (module-not-found-exception-arguments exc) ;; procedure processor? (processor? obj) ;; procedure current-processor (current-processor) ;; procedure processor-id (processor-id processor) ;; procedure timeout->time (timeout->time timeout) ;; procedure current-second (current-second) ;; procedure current-jiffy (current-jiffy) ;; procedure jiffies-per-second (jiffies-per-second) ;; procedure get-environment-variable (get-environment-variable name) ;; procedure get-environment-variables (get-environment-variables) ;; procedure executable-path (executable-path) ;; procedure command-name (command-name) ;; procedure command-args (command-args) ;; procedure script-file (script-file) ;; procedure script-directory (script-directory) ;; procedure open-dummy (open-dummy) ;; procedure port-settings-set! (port-settings-set! port settings) ;; procedure port-io-exception-handler-set! (port-io-exception-handler-set! port handler) ;; procedure input-port-bytes-buffered (input-port-bytes-buffered port) ;; procedure input-port-characters-buffered (input-port-characters-buffered port) ;; procedure nonempty-input-port-character-buffer-exception? (nonempty-input-port-character-buffer-exception? obj) ;; procedure nonempty-input-port-character-buffer-exception-arguments (nonempty-input-port-character-buffer-exception-arguments exc) ;; procedure nonempty-input-port-character-buffer-exception-procedure (nonempty-input-port-character-buffer-exception-procedure exc) ;; procedure repl-input-port (repl-input-port) ;; procedure repl-output-port (repl-output-port) ;; procedure repl-error-port (repl-error-port) ;; procedure console-port (console-port) ;; procedure current-user-interrupt-handler (current-user-interrupt-handler [handler]) ;; procedure default-user-interrupt-handler (default-user-interrupt-handler) ;; procedure defer-user-interrupts (defer-user-interrupts) ;; procedure primordial-exception-handler (primordial-exception-handler exc) ;; procedure err-code->string (err-code->string code) ;; procedure foreign? (foreign? obj) ;; procedure foreign-tags (foreign-tags foreign) ;; procedure foreign-address (foreign-address foreign) ;; procedure foreign-release! (foreign-release! foreign) ;; procedure foreign-released? (foreign-released? foreign) ;; procedure invalid-hash-number-exception? (invalid-hash-number-exception? obj) ;; procedure invalid-hash-number-exception-procedure (invalid-hash-number-exception-procedure exc) ;; procedure invalid-hash-number-exception-arguments (invalid-hash-number-exception-arguments exc) ;; procedure tcp-client-local-socket-info (tcp-client-local-socket-info tcp-client-port) ;; procedure tcp-client-peer-socket-info (tcp-client-peer-socket-info tcp-client-port) ;; procedure tcp-client-self-socket-info (tcp-client-self-socket-info tcp-client-port) ;; procedure tcp-server-socket-info (tcp-server-socket-info tcp-server-port) ;; procedure socket-info? (socket-info? obj) ;; procedure socket-info-address (socket-info-address socket-info) ;; procedure socket-info-family (socket-info-family socket-info) ;; procedure socket-info-port-number (socket-info-port-number socket-info) ;; procedure system-version (system-version) ;; procedure system-version-string (system-version-string) ;; procedure system-type (system-type) ;; procedure system-type-string (system-type-string) ;; procedure configure-command-string (configure-command-string) ;; procedure system-stamp (system-stamp) ;; procedure future (future expr) ;; special form touch (touch obj) ;; procedure tty? (tty? obj) ;; procedure tty-history (tty-history tty) ;; procedure tty-history-set! (tty-history-set! tty history) ;; procedure tty-history-max-length-set! (tty-history-max-length-set! tty n) ;; procedure tty-paren-balance-duration-set! (tty-paren-balance-duration-set! tty duration) ;; procedure tty-text-attributes-set! (tty-text-attributes-set! tty attributes) ;; procedure tty-mode-set! (tty-mode-set! tty mode) ;; procedure tty-type-set! (tty-type-set! tty type) ;; procedure with-input-from-port (with-input-from-port port thunk) ;; procedure with-output-to-port (with-output-to-port port thunk) ;; procedure input-port-char-position (input-port-char-position port) ;; procedure output-port-char-position (output-port-char-position port) ;; procedure open-event-queue (open-event-queue selector) ;; procedure main (main \u2026) ;; procedure dead-end (dead-end) ;; procedure poll-point (poll-point) ;; procedure define-record-type (define-record-type \u2026) ;; special form define-type (define-type \u2026) ;; special form this-source-file (this-source-file) ;; special form receive (receive \u2026) ;; special form define-values (define-values \u2026) ;; special form define-module-alias (define-module-alias \u2026) ;; special form r7rs-guard (r7rs-guard \u2026) ;; special form case-lambda (case-lambda \u2026) ;; special form syntax-case (syntax-case \u2026) ;; special form syntax (syntax \u2026) ;; special form datum->syntax (datum->syntax obj) ;; procedure syntax->datum (syntax->datum stx) ;; procedure syntax->list (syntax->list stx) ;; procedure syntax->vector (syntax->vector stx) ;; procedure length+ (length+ clist) ;; procedure car+cdr (car+cdr pair) ;; procedure first (first pair) ;; procedure second (second pair) ;; procedure third (third pair) ;; procedure fourth (fourth pair) ;; procedure fifth (fifth pair) ;; procedure sixth (sixth pair) ;; procedure seventh (seventh pair) ;; procedure eighth (eighth pair) ;; procedure ninth (ninth pair) ;; procedure tenth (tenth pair) ;; procedure not-pair? (not-pair? x) ;; procedure null-list? (null-list? list) ;; procedure proper-list? (proper-list? s) ;; procedure circular-list? (circular-list? s) ;; procedure dotted-list? (dotted-list? s) ;; procedure filter (filter pred list) ;; procedure remove (remove pred list) ;; procedure remq (remq elem list) ;; procedure concatenate (concatenate list-of-lists [separator]) ;; procedure concatenate! (concatenate! list-of-lists) ;; procedure list= (list= elt= list \u2026) ;; procedure list-set (list-set list k val) ;; procedure list-set! (list-set! list k val) ;; procedure fold (fold proc base list \u2026) ;; procedure fold-right (fold-right proc base list \u2026) ;; procedure iota (iota count [start [step]]) ;; procedure circular-list (circular-list x y\u2026) ;; procedure cons* (cons* x y\u2026) ;; procedure list-copy (list-copy list) ;; procedure list-tabulate (list-tabulate n init-proc) ;; procedure make-list (make-list n [fill]) ;; procedure reverse! (reverse! list) ;; procedure append-reverse (append-reverse list tail) ;; procedure append-reverse! (append-reverse! list tail) ;; procedure xcons (xcons d a) ;; procedure take (take x i) ;; procedure drop (drop x i) ;; procedure last (last pair) ;; procedure last-pair (last-pair pair) ;; procedure list-sort (list-sort proc list) ;; procedure list-sort! (list-sort! proc list) ;; procedure finite? (finite? x) ;; procedure infinite? (infinite? x) ;; procedure nan? (nan? x) ;; procedure acosh (acosh x) ;; procedure asinh (asinh x) ;; procedure atanh (atanh x) ;; procedure cosh (cosh x) ;; procedure sinh (sinh x) ;; procedure tanh (tanh x) ;; procedure conjugate (conjugate x) ;; procedure bits (bits bool\u2026) ;; procedure bits->list (bits->list i [len]) ;; procedure list->bits (list->bits list) ;; procedure bits->vector (bits->vector i [len]) ;; procedure vector->bits (vector->bits vector) ;; procedure six.infix (six.infix datum) ;; special form six.! (six.!) ;; undefined six.!x (six.!x x) ;; special form six.&x (six.&x x) ;; special form six.**x (six.**x x) ;; special form six.*x (six.*x x) ;; special form six.++x (six.++x x) ;; special form six.+x (six.+x x) ;; special form six.--x (six.--x x) ;; special form six.-x (six.-x x) ;; special form six.arrow (six.arrow expr ident) ;; special form six.asyncx (six.asyncx x) ;; undefined six.awaitx (six.awaitx x) ;; undefined six.break (six.break) ;; undefined six.call (six.call func arg\u2026) ;; special form six.case (six.case) ;; undefined six.clause (six.clause) ;; undefined six.compound (six.compound statement\u2026) ;; special form six.cons (six.cons x y) ;; special form six.continue (six.continue) ;; undefined six.define-procedure (six.define-procedure ident proc) ;; special form six.define-variable (six.define-variable ident type dims init) ;; special form six.do-while (six.do-while stat expr) ;; special form six.dot (six.dot expr ident) ;; special form six.for (six.for stat1 expr2 expr3 stat2) ;; special form six.goto (six.goto expr) ;; undefined six.from-import (six.from-import expr1 expr2) ;; undefined six.from-import-* (six.from-import-* expr) ;; undefined six.identifier (six.identifier ident) ;; special form six.if (six.if expr stat1 [stat2]) ;; special form six.import (six.import expr) ;; undefined six.index (six.index expr1 expr2) ;; special form six.label (six.label ident stat) ;; undefined six.list (six.list x y) ;; special form six.literal (six.literal value) ;; special form six.make-array (six.make-array init dim\u2026) ;; procedure six.new (six.new ident arg\u2026) ;; special form six.null (six.null) ;; special form six.procedure (six.procedure type params stat) ;; special form six.procedure-body (six.procedure-body stat\u2026) ;; special form six.return (six.return) ;; undefined six.switch (six.switch) ;; undefined six.typeofx (six.typeofx x) ;; undefined six.while (six.while expr stat\u2026) ;; special form six.x!==y (six.x!==y x y) ;; special form six.x!=y (six.x!=y x y) ;; special form six.x%=y (six.x%=y x y) ;; special form six.x%y (six.x%y x y) ;; special form six.x&&y (six.x&&y x y) ;; special form six.x&=y (six.x&=y x y) ;; special form six.x&y (six.x&y x y) ;; special form six.x**=y (six.x**=y x y) ;; special form six.x**y (six.x**y x y) ;; special form six.x*=y (six.x*=y x y) ;; special form six.x*y (six.x*y x y) ;; special form six.x@=y (six.x@=y x y) ;; special form six.x@y (six.x@y x y) ;; special form six.x++ (six.x++ x) ;; special form six.x+=y (six.x+=y x y) ;; special form six.x+y (six.x+y x y) ;; special form |six.x,y| (|six.x,y| x y) ;; special form six.x-- (six.x-- x) ;; special form six.x-=y (six.x-=y x y) ;; special form six.x-y (six.x-y x y) ;; special form six.x//=y (six.x//=y x y) ;; special form six.x//y (six.x//y x y) ;; special form six.x/=y (six.x/=y x y) ;; special form six.x/y (six.x/y x y) ;; special form six.x:-y (six.x:-y x y) ;; undefined six.x:=y (six.x:=y x y) ;; special form six.x:y (six.x:y x y) ;; special form six.x<<=y (six.x<<=y x y) ;; special form six.x<<y (six.x<<y x y) ;; special form six.x<=y (six.x<=y x y) ;; special form six.x<y (six.x<y x y) ;; special form six.x===y (six.x===y x y) ;; special form six.x==y (six.x==y x y) ;; special form six.x=y (six.x=y x y) ;; special form six.x>=y (six.x>=y x y) ;; special form six.x>>>=y (six.x>>>=y x y) ;; special form six.x>>>y (six.x>>>y x y) ;; special form six.x>>=y (six.x>>=y x y) ;; special form six.x>>y (six.x>>y x y) ;; special form six.x>y (six.x>y x y) ;; special form six.x?y:z (six.x?y:z x y z) ;; special form six.x^=y (six.x^=y x y) ;; special form six.x^y (six.x^y x y) ;; special form |six.x|=y| (|six.x\\|=y| x y) ;; special form |six.x|y| (|six.x\\|y| x y) ;; special form |six.x||y| (|six.x\\|\\|y| x y) ;; special form six.xandy (six.xandy x y) ;; special form six.xinstanceofy (six.xinstanceofy x y) ;; undefined six.xiny (six.xiny x y) ;; special form six.xisy (six.xisy x y) ;; special form six.notx (six.notx x y) ;; special form six.xory (six.xory x y) ;; special form six.~x (six.~x x) ;; special form six.yieldx (six.yieldx x) ;; undefined readtable-comment-handler (readtable-comment-handler readtable) ;; procedure readtable-comment-handler-set (readtable-comment-handler-set readtable new-value) ;; procedure open-output-bytevector (open-output-bytevector [u8vector-or-settings]) ;; procedure","title":"Undocumented extensions"},{"location":"manual/scheme_extensions/undocumented_extensions/#undocumented-extensions","text":"The procedures in this section are not yet documented.","title":"Undocumented extensions"},{"location":"manual/scheme_extensions/undocumented_extensions/#make-thread-group","text":"(make-thread-group [name [thread-group]]) ;; procedure","title":"make-thread-group"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group","text":"(thread-group? obj) ;; procedure","title":"thread-group?"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-name","text":"(thread-group-name thread-group) ;; procedure","title":"thread-group-name"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-parent","text":"(thread-group-parent thread-group) ;; procedure","title":"thread-group-parent"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-resume","text":"(thread-group-resume! thread-group) ;; procedure","title":"thread-group-resume!"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-suspend","text":"(thread-group-suspend! thread-group) ;; procedure","title":"thread-group-suspend!"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-terminate","text":"(thread-group-terminate! thread-group) ;; procedure","title":"thread-group-terminate!"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-thread-group-list","text":"(thread-group->thread-group-list thread-group) ;; procedure","title":"thread-group-&gt;thread-group-list"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-thread-group-vector","text":"(thread-group->thread-group-vector thread-group) ;; procedure","title":"thread-group-&gt;thread-group-vector"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-thread-list","text":"(thread-group->thread-list thread-group) ;; procedure","title":"thread-group-&gt;thread-list"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-thread-vector","text":"(thread-group->thread-vector thread-group) ;; procedure","title":"thread-group-&gt;thread-vector"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-specific","text":"(thread-group-specific thread-group) ;; procedure","title":"thread-group-specific"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-group-specific-set","text":"(thread-group-specific-set! thread-group obj) ;; procedure","title":"thread-group-specific-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state","text":"(thread-state thread) ;; procedure","title":"thread-state"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-uninitialized","text":"(thread-state-uninitialized? thread-state) ;; procedure","title":"thread-state-uninitialized?"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-initialized","text":"(thread-state-initialized? thread-state) ;; procedure","title":"thread-state-initialized?"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-running","text":"(thread-state-running? thread-state) ;; procedure","title":"thread-state-running?"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-running-processor","text":"(thread-state-running-processor thread-state) ;; procedure","title":"thread-state-running-processor"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-waiting","text":"(thread-state-waiting? thread-state) ;; procedure","title":"thread-state-waiting?"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-waiting-for","text":"(thread-state-waiting-for thread-state) ;; procedure","title":"thread-state-waiting-for"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-waiting-timeout","text":"(thread-state-waiting-timeout thread-state) ;; procedure","title":"thread-state-waiting-timeout"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-normally-terminated","text":"(thread-state-normally-terminated? thread-state) ;; procedure","title":"thread-state-normally-terminated?"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-normally-terminated-result","text":"(thread-state-normally-terminated-result thread-state) ;; procedure","title":"thread-state-normally-terminated-result"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-abnormally-terminated","text":"(thread-state-abnormally-terminated? thread-state) ;; procedure","title":"thread-state-abnormally-terminated?"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-state-abnormally-terminated-reason","text":"(thread-state-abnormally-terminated-reason thread-state) ;; procedure","title":"thread-state-abnormally-terminated-reason"},{"location":"manual/scheme_extensions/undocumented_extensions/#top","text":"(top [timeout [thread-group [port]]]) ;; procedure","title":"top"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-interrupt","text":"(thread-interrupt! thread [thunk]) ;; procedure","title":"thread-interrupt!"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-suspend","text":"(thread-suspend! thread) ;; procedure","title":"thread-suspend!"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-resume","text":"(thread-resume! thread) ;; procedure","title":"thread-resume!"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-thread-group","text":"(thread-thread-group thread) ;; procedure","title":"thread-thread-group"},{"location":"manual/scheme_extensions/undocumented_extensions/#define-type-of-thread","text":"(define-type-of-thread name field\u2026) ;; special form","title":"define-type-of-thread"},{"location":"manual/scheme_extensions/undocumented_extensions/#thread-init","text":"(thread-init! thread thunk [name [thread-group]]) ;; procedure","title":"thread-init!"},{"location":"manual/scheme_extensions/undocumented_extensions/#initialized-thread-exception","text":"(initialized-thread-exception? obj) ;; procedure","title":"initialized-thread-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#initialized-thread-exception-procedure","text":"(initialized-thread-exception-procedure exc) ;; procedure","title":"initialized-thread-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#initialized-thread-exception-arguments","text":"(initialized-thread-exception-arguments exc) ;; procedure","title":"initialized-thread-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#uninitialized-thread-exception","text":"(uninitialized-thread-exception? obj) ;; procedure","title":"uninitialized-thread-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#uninitialized-thread-exception-procedure","text":"(uninitialized-thread-exception-procedure exc) ;; procedure","title":"uninitialized-thread-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#uninitialized-thread-exception-arguments","text":"(uninitialized-thread-exception-arguments exc) ;; procedure","title":"uninitialized-thread-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#inactive-thread-exception","text":"(inactive-thread-exception? obj) ;; procedure","title":"inactive-thread-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#inactive-thread-exception-procedure","text":"(inactive-thread-exception-procedure exc) ;; procedure","title":"inactive-thread-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#inactive-thread-exception-arguments","text":"(inactive-thread-exception-arguments exc) ;; procedure","title":"inactive-thread-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#rpc-remote-error-exception","text":"(rpc-remote-error-exception? obj) ;; procedure","title":"rpc-remote-error-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#rpc-remote-error-exception-procedure","text":"(rpc-remote-error-exception-procedure exc) ;; procedure","title":"rpc-remote-error-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#rpc-remote-error-exception-arguments","text":"(rpc-remote-error-exception-arguments exc) ;; procedure","title":"rpc-remote-error-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#rpc-remote-error-exception-message","text":"(rpc-remote-error-exception-message exc) ;; procedure","title":"rpc-remote-error-exception-message"},{"location":"manual/scheme_extensions/undocumented_extensions/#invalid-utf8-encoding-exception","text":"(invalid-utf8-encoding-exception? obj) ;; procedure","title":"invalid-utf8-encoding-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#invalid-utf8-encoding-exception-procedure","text":"(invalid-utf8-encoding-exception-procedure exc) ;; procedure","title":"invalid-utf8-encoding-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#invalid-utf8-encoding-exception-arguments","text":"(invalid-utf8-encoding-exception-arguments exc) ;; procedure","title":"invalid-utf8-encoding-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#module-not-found-exception","text":"(module-not-found-exception? obj) ;; procedure","title":"module-not-found-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#module-not-found-exception-procedure","text":"(module-not-found-exception-procedure exc) ;; procedure","title":"module-not-found-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#module-not-found-exception-arguments","text":"(module-not-found-exception-arguments exc) ;; procedure","title":"module-not-found-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#processor","text":"(processor? obj) ;; procedure","title":"processor?"},{"location":"manual/scheme_extensions/undocumented_extensions/#current-processor","text":"(current-processor) ;; procedure","title":"current-processor"},{"location":"manual/scheme_extensions/undocumented_extensions/#processor-id","text":"(processor-id processor) ;; procedure","title":"processor-id"},{"location":"manual/scheme_extensions/undocumented_extensions/#timeout-time","text":"(timeout->time timeout) ;; procedure","title":"timeout-&gt;time"},{"location":"manual/scheme_extensions/undocumented_extensions/#current-second","text":"(current-second) ;; procedure","title":"current-second"},{"location":"manual/scheme_extensions/undocumented_extensions/#current-jiffy","text":"(current-jiffy) ;; procedure","title":"current-jiffy"},{"location":"manual/scheme_extensions/undocumented_extensions/#jiffies-per-second","text":"(jiffies-per-second) ;; procedure","title":"jiffies-per-second"},{"location":"manual/scheme_extensions/undocumented_extensions/#get-environment-variable","text":"(get-environment-variable name) ;; procedure","title":"get-environment-variable"},{"location":"manual/scheme_extensions/undocumented_extensions/#get-environment-variables","text":"(get-environment-variables) ;; procedure","title":"get-environment-variables"},{"location":"manual/scheme_extensions/undocumented_extensions/#executable-path","text":"(executable-path) ;; procedure","title":"executable-path"},{"location":"manual/scheme_extensions/undocumented_extensions/#command-name","text":"(command-name) ;; procedure","title":"command-name"},{"location":"manual/scheme_extensions/undocumented_extensions/#command-args","text":"(command-args) ;; procedure","title":"command-args"},{"location":"manual/scheme_extensions/undocumented_extensions/#script-file","text":"(script-file) ;; procedure","title":"script-file"},{"location":"manual/scheme_extensions/undocumented_extensions/#script-directory","text":"(script-directory) ;; procedure","title":"script-directory"},{"location":"manual/scheme_extensions/undocumented_extensions/#open-dummy","text":"(open-dummy) ;; procedure","title":"open-dummy"},{"location":"manual/scheme_extensions/undocumented_extensions/#port-settings-set","text":"(port-settings-set! port settings) ;; procedure","title":"port-settings-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#port-io-exception-handler-set","text":"(port-io-exception-handler-set! port handler) ;; procedure","title":"port-io-exception-handler-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#input-port-bytes-buffered","text":"(input-port-bytes-buffered port) ;; procedure","title":"input-port-bytes-buffered"},{"location":"manual/scheme_extensions/undocumented_extensions/#input-port-characters-buffered","text":"(input-port-characters-buffered port) ;; procedure","title":"input-port-characters-buffered"},{"location":"manual/scheme_extensions/undocumented_extensions/#nonempty-input-port-character-buffer-exception","text":"(nonempty-input-port-character-buffer-exception? obj) ;; procedure","title":"nonempty-input-port-character-buffer-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#nonempty-input-port-character-buffer-exception-arguments","text":"(nonempty-input-port-character-buffer-exception-arguments exc) ;; procedure","title":"nonempty-input-port-character-buffer-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#nonempty-input-port-character-buffer-exception-procedure","text":"(nonempty-input-port-character-buffer-exception-procedure exc) ;; procedure","title":"nonempty-input-port-character-buffer-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#repl-input-port","text":"(repl-input-port) ;; procedure","title":"repl-input-port"},{"location":"manual/scheme_extensions/undocumented_extensions/#repl-output-port","text":"(repl-output-port) ;; procedure","title":"repl-output-port"},{"location":"manual/scheme_extensions/undocumented_extensions/#repl-error-port","text":"(repl-error-port) ;; procedure","title":"repl-error-port"},{"location":"manual/scheme_extensions/undocumented_extensions/#console-port","text":"(console-port) ;; procedure","title":"console-port"},{"location":"manual/scheme_extensions/undocumented_extensions/#current-user-interrupt-handler","text":"(current-user-interrupt-handler [handler]) ;; procedure","title":"current-user-interrupt-handler"},{"location":"manual/scheme_extensions/undocumented_extensions/#default-user-interrupt-handler","text":"(default-user-interrupt-handler) ;; procedure","title":"default-user-interrupt-handler"},{"location":"manual/scheme_extensions/undocumented_extensions/#defer-user-interrupts","text":"(defer-user-interrupts) ;; procedure","title":"defer-user-interrupts"},{"location":"manual/scheme_extensions/undocumented_extensions/#primordial-exception-handler","text":"(primordial-exception-handler exc) ;; procedure","title":"primordial-exception-handler"},{"location":"manual/scheme_extensions/undocumented_extensions/#err-code-string","text":"(err-code->string code) ;; procedure","title":"err-code-&gt;string"},{"location":"manual/scheme_extensions/undocumented_extensions/#foreign","text":"(foreign? obj) ;; procedure","title":"foreign?"},{"location":"manual/scheme_extensions/undocumented_extensions/#foreign-tags","text":"(foreign-tags foreign) ;; procedure","title":"foreign-tags"},{"location":"manual/scheme_extensions/undocumented_extensions/#foreign-address","text":"(foreign-address foreign) ;; procedure","title":"foreign-address"},{"location":"manual/scheme_extensions/undocumented_extensions/#foreign-release","text":"(foreign-release! foreign) ;; procedure","title":"foreign-release!"},{"location":"manual/scheme_extensions/undocumented_extensions/#foreign-released","text":"(foreign-released? foreign) ;; procedure","title":"foreign-released?"},{"location":"manual/scheme_extensions/undocumented_extensions/#invalid-hash-number-exception","text":"(invalid-hash-number-exception? obj) ;; procedure","title":"invalid-hash-number-exception?"},{"location":"manual/scheme_extensions/undocumented_extensions/#invalid-hash-number-exception-procedure","text":"(invalid-hash-number-exception-procedure exc) ;; procedure","title":"invalid-hash-number-exception-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#invalid-hash-number-exception-arguments","text":"(invalid-hash-number-exception-arguments exc) ;; procedure","title":"invalid-hash-number-exception-arguments"},{"location":"manual/scheme_extensions/undocumented_extensions/#tcp-client-local-socket-info","text":"(tcp-client-local-socket-info tcp-client-port) ;; procedure","title":"tcp-client-local-socket-info"},{"location":"manual/scheme_extensions/undocumented_extensions/#tcp-client-peer-socket-info","text":"(tcp-client-peer-socket-info tcp-client-port) ;; procedure","title":"tcp-client-peer-socket-info"},{"location":"manual/scheme_extensions/undocumented_extensions/#tcp-client-self-socket-info","text":"(tcp-client-self-socket-info tcp-client-port) ;; procedure","title":"tcp-client-self-socket-info"},{"location":"manual/scheme_extensions/undocumented_extensions/#tcp-server-socket-info","text":"(tcp-server-socket-info tcp-server-port) ;; procedure","title":"tcp-server-socket-info"},{"location":"manual/scheme_extensions/undocumented_extensions/#socket-info","text":"(socket-info? obj) ;; procedure","title":"socket-info?"},{"location":"manual/scheme_extensions/undocumented_extensions/#socket-info-address","text":"(socket-info-address socket-info) ;; procedure","title":"socket-info-address"},{"location":"manual/scheme_extensions/undocumented_extensions/#socket-info-family","text":"(socket-info-family socket-info) ;; procedure","title":"socket-info-family"},{"location":"manual/scheme_extensions/undocumented_extensions/#socket-info-port-number","text":"(socket-info-port-number socket-info) ;; procedure","title":"socket-info-port-number"},{"location":"manual/scheme_extensions/undocumented_extensions/#system-version","text":"(system-version) ;; procedure","title":"system-version"},{"location":"manual/scheme_extensions/undocumented_extensions/#system-version-string","text":"(system-version-string) ;; procedure","title":"system-version-string"},{"location":"manual/scheme_extensions/undocumented_extensions/#system-type","text":"(system-type) ;; procedure","title":"system-type"},{"location":"manual/scheme_extensions/undocumented_extensions/#system-type-string","text":"(system-type-string) ;; procedure","title":"system-type-string"},{"location":"manual/scheme_extensions/undocumented_extensions/#configure-command-string","text":"(configure-command-string) ;; procedure","title":"configure-command-string"},{"location":"manual/scheme_extensions/undocumented_extensions/#system-stamp","text":"(system-stamp) ;; procedure","title":"system-stamp"},{"location":"manual/scheme_extensions/undocumented_extensions/#future","text":"(future expr) ;; special form","title":"future"},{"location":"manual/scheme_extensions/undocumented_extensions/#touch","text":"(touch obj) ;; procedure","title":"touch"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty","text":"(tty? obj) ;; procedure","title":"tty?"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty-history","text":"(tty-history tty) ;; procedure","title":"tty-history"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty-history-set","text":"(tty-history-set! tty history) ;; procedure","title":"tty-history-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty-history-max-length-set","text":"(tty-history-max-length-set! tty n) ;; procedure","title":"tty-history-max-length-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty-paren-balance-duration-set","text":"(tty-paren-balance-duration-set! tty duration) ;; procedure","title":"tty-paren-balance-duration-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty-text-attributes-set","text":"(tty-text-attributes-set! tty attributes) ;; procedure","title":"tty-text-attributes-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty-mode-set","text":"(tty-mode-set! tty mode) ;; procedure","title":"tty-mode-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#tty-type-set","text":"(tty-type-set! tty type) ;; procedure","title":"tty-type-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#with-input-from-port","text":"(with-input-from-port port thunk) ;; procedure","title":"with-input-from-port"},{"location":"manual/scheme_extensions/undocumented_extensions/#with-output-to-port","text":"(with-output-to-port port thunk) ;; procedure","title":"with-output-to-port"},{"location":"manual/scheme_extensions/undocumented_extensions/#input-port-char-position","text":"(input-port-char-position port) ;; procedure","title":"input-port-char-position"},{"location":"manual/scheme_extensions/undocumented_extensions/#output-port-char-position","text":"(output-port-char-position port) ;; procedure","title":"output-port-char-position"},{"location":"manual/scheme_extensions/undocumented_extensions/#open-event-queue","text":"(open-event-queue selector) ;; procedure","title":"open-event-queue"},{"location":"manual/scheme_extensions/undocumented_extensions/#main","text":"(main \u2026) ;; procedure","title":"main"},{"location":"manual/scheme_extensions/undocumented_extensions/#dead-end","text":"(dead-end) ;; procedure","title":"dead-end"},{"location":"manual/scheme_extensions/undocumented_extensions/#poll-point","text":"(poll-point) ;; procedure","title":"poll-point"},{"location":"manual/scheme_extensions/undocumented_extensions/#define-record-type","text":"(define-record-type \u2026) ;; special form","title":"define-record-type"},{"location":"manual/scheme_extensions/undocumented_extensions/#define-type","text":"(define-type \u2026) ;; special form","title":"define-type"},{"location":"manual/scheme_extensions/undocumented_extensions/#this-source-file","text":"(this-source-file) ;; special form","title":"this-source-file"},{"location":"manual/scheme_extensions/undocumented_extensions/#receive","text":"(receive \u2026) ;; special form","title":"receive"},{"location":"manual/scheme_extensions/undocumented_extensions/#define-values","text":"(define-values \u2026) ;; special form","title":"define-values"},{"location":"manual/scheme_extensions/undocumented_extensions/#define-module-alias","text":"(define-module-alias \u2026) ;; special form","title":"define-module-alias"},{"location":"manual/scheme_extensions/undocumented_extensions/#r7rs-guard","text":"(r7rs-guard \u2026) ;; special form","title":"r7rs-guard"},{"location":"manual/scheme_extensions/undocumented_extensions/#case-lambda","text":"(case-lambda \u2026) ;; special form","title":"case-lambda"},{"location":"manual/scheme_extensions/undocumented_extensions/#syntax-case","text":"(syntax-case \u2026) ;; special form","title":"syntax-case"},{"location":"manual/scheme_extensions/undocumented_extensions/#syntax","text":"(syntax \u2026) ;; special form","title":"syntax"},{"location":"manual/scheme_extensions/undocumented_extensions/#datum-syntax","text":"(datum->syntax obj) ;; procedure","title":"datum-&gt;syntax"},{"location":"manual/scheme_extensions/undocumented_extensions/#syntax-datum","text":"(syntax->datum stx) ;; procedure","title":"syntax-&gt;datum"},{"location":"manual/scheme_extensions/undocumented_extensions/#syntax-list","text":"(syntax->list stx) ;; procedure","title":"syntax-&gt;list"},{"location":"manual/scheme_extensions/undocumented_extensions/#syntax-vector","text":"(syntax->vector stx) ;; procedure","title":"syntax-&gt;vector"},{"location":"manual/scheme_extensions/undocumented_extensions/#length","text":"(length+ clist) ;; procedure","title":"length+"},{"location":"manual/scheme_extensions/undocumented_extensions/#carcdr","text":"(car+cdr pair) ;; procedure","title":"car+cdr"},{"location":"manual/scheme_extensions/undocumented_extensions/#first","text":"(first pair) ;; procedure","title":"first"},{"location":"manual/scheme_extensions/undocumented_extensions/#second","text":"(second pair) ;; procedure","title":"second"},{"location":"manual/scheme_extensions/undocumented_extensions/#third","text":"(third pair) ;; procedure","title":"third"},{"location":"manual/scheme_extensions/undocumented_extensions/#fourth","text":"(fourth pair) ;; procedure","title":"fourth"},{"location":"manual/scheme_extensions/undocumented_extensions/#fifth","text":"(fifth pair) ;; procedure","title":"fifth"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixth","text":"(sixth pair) ;; procedure","title":"sixth"},{"location":"manual/scheme_extensions/undocumented_extensions/#seventh","text":"(seventh pair) ;; procedure","title":"seventh"},{"location":"manual/scheme_extensions/undocumented_extensions/#eighth","text":"(eighth pair) ;; procedure","title":"eighth"},{"location":"manual/scheme_extensions/undocumented_extensions/#ninth","text":"(ninth pair) ;; procedure","title":"ninth"},{"location":"manual/scheme_extensions/undocumented_extensions/#tenth","text":"(tenth pair) ;; procedure","title":"tenth"},{"location":"manual/scheme_extensions/undocumented_extensions/#not-pair","text":"(not-pair? x) ;; procedure","title":"not-pair?"},{"location":"manual/scheme_extensions/undocumented_extensions/#null-list","text":"(null-list? list) ;; procedure","title":"null-list?"},{"location":"manual/scheme_extensions/undocumented_extensions/#proper-list","text":"(proper-list? s) ;; procedure","title":"proper-list?"},{"location":"manual/scheme_extensions/undocumented_extensions/#circular-list","text":"(circular-list? s) ;; procedure","title":"circular-list?"},{"location":"manual/scheme_extensions/undocumented_extensions/#dotted-list","text":"(dotted-list? s) ;; procedure","title":"dotted-list?"},{"location":"manual/scheme_extensions/undocumented_extensions/#filter","text":"(filter pred list) ;; procedure","title":"filter"},{"location":"manual/scheme_extensions/undocumented_extensions/#remove","text":"(remove pred list) ;; procedure","title":"remove"},{"location":"manual/scheme_extensions/undocumented_extensions/#remq","text":"(remq elem list) ;; procedure","title":"remq"},{"location":"manual/scheme_extensions/undocumented_extensions/#concatenate","text":"(concatenate list-of-lists [separator]) ;; procedure","title":"concatenate"},{"location":"manual/scheme_extensions/undocumented_extensions/#concatenate_1","text":"(concatenate! list-of-lists) ;; procedure","title":"concatenate!"},{"location":"manual/scheme_extensions/undocumented_extensions/#list","text":"(list= elt= list \u2026) ;; procedure","title":"list="},{"location":"manual/scheme_extensions/undocumented_extensions/#list-set","text":"(list-set list k val) ;; procedure","title":"list-set"},{"location":"manual/scheme_extensions/undocumented_extensions/#list-set_1","text":"(list-set! list k val) ;; procedure","title":"list-set!"},{"location":"manual/scheme_extensions/undocumented_extensions/#fold","text":"(fold proc base list \u2026) ;; procedure","title":"fold"},{"location":"manual/scheme_extensions/undocumented_extensions/#fold-right","text":"(fold-right proc base list \u2026) ;; procedure","title":"fold-right"},{"location":"manual/scheme_extensions/undocumented_extensions/#iota","text":"(iota count [start [step]]) ;; procedure","title":"iota"},{"location":"manual/scheme_extensions/undocumented_extensions/#circular-list_1","text":"(circular-list x y\u2026) ;; procedure","title":"circular-list"},{"location":"manual/scheme_extensions/undocumented_extensions/#cons","text":"(cons* x y\u2026) ;; procedure","title":"cons*"},{"location":"manual/scheme_extensions/undocumented_extensions/#list-copy","text":"(list-copy list) ;; procedure","title":"list-copy"},{"location":"manual/scheme_extensions/undocumented_extensions/#list-tabulate","text":"(list-tabulate n init-proc) ;; procedure","title":"list-tabulate"},{"location":"manual/scheme_extensions/undocumented_extensions/#make-list","text":"(make-list n [fill]) ;; procedure","title":"make-list"},{"location":"manual/scheme_extensions/undocumented_extensions/#reverse","text":"(reverse! list) ;; procedure","title":"reverse!"},{"location":"manual/scheme_extensions/undocumented_extensions/#append-reverse","text":"(append-reverse list tail) ;; procedure","title":"append-reverse"},{"location":"manual/scheme_extensions/undocumented_extensions/#append-reverse_1","text":"(append-reverse! list tail) ;; procedure","title":"append-reverse!"},{"location":"manual/scheme_extensions/undocumented_extensions/#xcons","text":"(xcons d a) ;; procedure","title":"xcons"},{"location":"manual/scheme_extensions/undocumented_extensions/#take","text":"(take x i) ;; procedure","title":"take"},{"location":"manual/scheme_extensions/undocumented_extensions/#drop","text":"(drop x i) ;; procedure","title":"drop"},{"location":"manual/scheme_extensions/undocumented_extensions/#last","text":"(last pair) ;; procedure","title":"last"},{"location":"manual/scheme_extensions/undocumented_extensions/#last-pair","text":"(last-pair pair) ;; procedure","title":"last-pair"},{"location":"manual/scheme_extensions/undocumented_extensions/#list-sort","text":"(list-sort proc list) ;; procedure","title":"list-sort"},{"location":"manual/scheme_extensions/undocumented_extensions/#list-sort_1","text":"(list-sort! proc list) ;; procedure","title":"list-sort!"},{"location":"manual/scheme_extensions/undocumented_extensions/#finite","text":"(finite? x) ;; procedure","title":"finite?"},{"location":"manual/scheme_extensions/undocumented_extensions/#infinite","text":"(infinite? x) ;; procedure","title":"infinite?"},{"location":"manual/scheme_extensions/undocumented_extensions/#nan","text":"(nan? x) ;; procedure","title":"nan?"},{"location":"manual/scheme_extensions/undocumented_extensions/#acosh","text":"(acosh x) ;; procedure","title":"acosh"},{"location":"manual/scheme_extensions/undocumented_extensions/#asinh","text":"(asinh x) ;; procedure","title":"asinh"},{"location":"manual/scheme_extensions/undocumented_extensions/#atanh","text":"(atanh x) ;; procedure","title":"atanh"},{"location":"manual/scheme_extensions/undocumented_extensions/#cosh","text":"(cosh x) ;; procedure","title":"cosh"},{"location":"manual/scheme_extensions/undocumented_extensions/#sinh","text":"(sinh x) ;; procedure","title":"sinh"},{"location":"manual/scheme_extensions/undocumented_extensions/#tanh","text":"(tanh x) ;; procedure","title":"tanh"},{"location":"manual/scheme_extensions/undocumented_extensions/#conjugate","text":"(conjugate x) ;; procedure","title":"conjugate"},{"location":"manual/scheme_extensions/undocumented_extensions/#bits","text":"(bits bool\u2026) ;; procedure","title":"bits"},{"location":"manual/scheme_extensions/undocumented_extensions/#bits-list","text":"(bits->list i [len]) ;; procedure","title":"bits-&gt;list"},{"location":"manual/scheme_extensions/undocumented_extensions/#list-bits","text":"(list->bits list) ;; procedure","title":"list-&gt;bits"},{"location":"manual/scheme_extensions/undocumented_extensions/#bits-vector","text":"(bits->vector i [len]) ;; procedure","title":"bits-&gt;vector"},{"location":"manual/scheme_extensions/undocumented_extensions/#vector-bits","text":"(vector->bits vector) ;; procedure","title":"vector-&gt;bits"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixinfix","text":"(six.infix datum) ;; special form","title":"six.infix"},{"location":"manual/scheme_extensions/undocumented_extensions/#six","text":"(six.!) ;; undefined","title":"six.!"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx","text":"(six.!x x) ;; special form","title":"six.!x"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx_1","text":"(six.&x x) ;; special form","title":"six.&amp;x"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx_2","text":"(six.**x x) ;; special form","title":"six.**x"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx_3","text":"(six.*x x) ;; special form","title":"six.*x"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx_4","text":"(six.++x x) ;; special form","title":"six.++x"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx_5","text":"(six.+x x) ;; special form","title":"six.+x"},{"location":"manual/scheme_extensions/undocumented_extensions/#six-x","text":"(six.--x x) ;; special form","title":"six.--x"},{"location":"manual/scheme_extensions/undocumented_extensions/#six-x_1","text":"(six.-x x) ;; special form","title":"six.-x"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixarrow","text":"(six.arrow expr ident) ;; special form","title":"six.arrow"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixasyncx","text":"(six.asyncx x) ;; undefined","title":"six.asyncx"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixawaitx","text":"(six.awaitx x) ;; undefined","title":"six.awaitx"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixbreak","text":"(six.break) ;; undefined","title":"six.break"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixcall","text":"(six.call func arg\u2026) ;; special form","title":"six.call"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixcase","text":"(six.case) ;; undefined","title":"six.case"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixclause","text":"(six.clause) ;; undefined","title":"six.clause"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixcompound","text":"(six.compound statement\u2026) ;; special form","title":"six.compound"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixcons","text":"(six.cons x y) ;; special form","title":"six.cons"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixcontinue","text":"(six.continue) ;; undefined","title":"six.continue"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixdefine-procedure","text":"(six.define-procedure ident proc) ;; special form","title":"six.define-procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixdefine-variable","text":"(six.define-variable ident type dims init) ;; special form","title":"six.define-variable"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixdo-while","text":"(six.do-while stat expr) ;; special form","title":"six.do-while"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixdot","text":"(six.dot expr ident) ;; special form","title":"six.dot"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixfor","text":"(six.for stat1 expr2 expr3 stat2) ;; special form","title":"six.for"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixgoto","text":"(six.goto expr) ;; undefined","title":"six.goto"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixfrom-import","text":"(six.from-import expr1 expr2) ;; undefined","title":"six.from-import"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixfrom-import-","text":"(six.from-import-* expr) ;; undefined","title":"six.from-import-*"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixidentifier","text":"(six.identifier ident) ;; special form","title":"six.identifier"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixif","text":"(six.if expr stat1 [stat2]) ;; special form","title":"six.if"},{"location":"manual/scheme_extensions/undocumented_extensions/#siximport","text":"(six.import expr) ;; undefined","title":"six.import"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixindex","text":"(six.index expr1 expr2) ;; special form","title":"six.index"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixlabel","text":"(six.label ident stat) ;; undefined","title":"six.label"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixlist","text":"(six.list x y) ;; special form","title":"six.list"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixliteral","text":"(six.literal value) ;; special form","title":"six.literal"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixmake-array","text":"(six.make-array init dim\u2026) ;; procedure","title":"six.make-array"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixnew","text":"(six.new ident arg\u2026) ;; special form","title":"six.new"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixnull","text":"(six.null) ;; special form","title":"six.null"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixprocedure","text":"(six.procedure type params stat) ;; special form","title":"six.procedure"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixprocedure-body","text":"(six.procedure-body stat\u2026) ;; special form","title":"six.procedure-body"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixreturn","text":"(six.return) ;; undefined","title":"six.return"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixswitch","text":"(six.switch) ;; undefined","title":"six.switch"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixtypeofx","text":"(six.typeofx x) ;; undefined","title":"six.typeofx"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixwhile","text":"(six.while expr stat\u2026) ;; special form","title":"six.while"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy","text":"(six.x!==y x y) ;; special form","title":"six.x!==y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_1","text":"(six.x!=y x y) ;; special form","title":"six.x!=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_2","text":"(six.x%=y x y) ;; special form","title":"six.x%=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_3","text":"(six.x%y x y) ;; special form","title":"six.x%y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_4","text":"(six.x&&y x y) ;; special form","title":"six.x&amp;&amp;y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_5","text":"(six.x&=y x y) ;; special form","title":"six.x&amp;=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_6","text":"(six.x&y x y) ;; special form","title":"six.x&amp;y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_7","text":"(six.x**=y x y) ;; special form","title":"six.x**=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_8","text":"(six.x**y x y) ;; special form","title":"six.x**y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_9","text":"(six.x*=y x y) ;; special form","title":"six.x*=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_10","text":"(six.x*y x y) ;; special form","title":"six.x*y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_11","text":"(six.x@=y x y) ;; special form","title":"six.x@=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_12","text":"(six.x@y x y) ;; special form","title":"six.x@y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx_6","text":"(six.x++ x) ;; special form","title":"six.x++"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_13","text":"(six.x+=y x y) ;; special form","title":"six.x+=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_14","text":"(six.x+y x y) ;; special form","title":"six.x+y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_15","text":"(|six.x,y| x y) ;; special form","title":"|six.x,y|"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx-","text":"(six.x-- x) ;; special form","title":"six.x--"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx-y","text":"(six.x-=y x y) ;; special form","title":"six.x-=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx-y_1","text":"(six.x-y x y) ;; special form","title":"six.x-y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_16","text":"(six.x//=y x y) ;; special form","title":"six.x//=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_17","text":"(six.x//y x y) ;; special form","title":"six.x//y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_18","text":"(six.x/=y x y) ;; special form","title":"six.x/=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_19","text":"(six.x/y x y) ;; special form","title":"six.x/y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx-y_2","text":"(six.x:-y x y) ;; undefined","title":"six.x:-y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_20","text":"(six.x:=y x y) ;; special form","title":"six.x:=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_21","text":"(six.x:y x y) ;; special form","title":"six.x:y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_22","text":"(six.x<<=y x y) ;; special form","title":"six.x&lt;&lt;=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_23","text":"(six.x<<y x y) ;; special form","title":"six.x&lt;&lt;y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_24","text":"(six.x<=y x y) ;; special form","title":"six.x&lt;=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_25","text":"(six.x<y x y) ;; special form","title":"six.x&lt;y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_26","text":"(six.x===y x y) ;; special form","title":"six.x===y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_27","text":"(six.x==y x y) ;; special form","title":"six.x==y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_28","text":"(six.x=y x y) ;; special form","title":"six.x=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_29","text":"(six.x>=y x y) ;; special form","title":"six.x&gt;=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_30","text":"(six.x>>>=y x y) ;; special form","title":"six.x&gt;&gt;&gt;=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_31","text":"(six.x>>>y x y) ;; special form","title":"six.x&gt;&gt;&gt;y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_32","text":"(six.x>>=y x y) ;; special form","title":"six.x&gt;&gt;=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_33","text":"(six.x>>y x y) ;; special form","title":"six.x&gt;&gt;y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_34","text":"(six.x>y x y) ;; special form","title":"six.x&gt;y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxyz","text":"(six.x?y:z x y z) ;; special form","title":"six.x?y:z"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_35","text":"(six.x^=y x y) ;; special form","title":"six.x^=y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_36","text":"(six.x^y x y) ;; special form","title":"six.x^y"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_37","text":"(|six.x\\|=y| x y) ;; special form","title":"|six.x|=y|"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_38","text":"(|six.x\\|y| x y) ;; special form","title":"|six.x|y|"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxy_39","text":"(|six.x\\|\\|y| x y) ;; special form","title":"|six.x||y|"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxandy","text":"(six.xandy x y) ;; special form","title":"six.xandy"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxinstanceofy","text":"(six.xinstanceofy x y) ;; undefined","title":"six.xinstanceofy"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxiny","text":"(six.xiny x y) ;; special form","title":"six.xiny"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxisy","text":"(six.xisy x y) ;; special form","title":"six.xisy"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixnotx","text":"(six.notx x y) ;; special form","title":"six.notx"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixxory","text":"(six.xory x y) ;; special form","title":"six.xory"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixx_7","text":"(six.~x x) ;; special form","title":"six.~x"},{"location":"manual/scheme_extensions/undocumented_extensions/#sixyieldx","text":"(six.yieldx x) ;; undefined","title":"six.yieldx"},{"location":"manual/scheme_extensions/undocumented_extensions/#readtable-comment-handler","text":"(readtable-comment-handler readtable) ;; procedure","title":"readtable-comment-handler"},{"location":"manual/scheme_extensions/undocumented_extensions/#readtable-comment-handler-set","text":"(readtable-comment-handler-set readtable new-value) ;; procedure","title":"readtable-comment-handler-set"},{"location":"manual/scheme_extensions/undocumented_extensions/#open-output-bytevector","text":"(open-output-bytevector [u8vector-or-settings]) ;; procedure","title":"open-output-bytevector"},{"location":"manual/system_limitations/","text":"System limitations On some systems floating point overflows will cause the program to terminate with a floating point exception. On some systems floating point operations involving +nan.0 +inf.0 , -inf.0 , or -0. do not return the value required by the IEEE 754 floating point standard. The maximum number of arguments that can be passed to a procedure by the apply procedure is 8192.","title":"System limitations"},{"location":"manual/system_limitations/#system-limitations","text":"On some systems floating point overflows will cause the program to terminate with a floating point exception. On some systems floating point operations involving +nan.0 +inf.0 , -inf.0 , or -0. do not return the value required by the IEEE 754 floating point standard. The maximum number of arguments that can be passed to a procedure by the apply procedure is 8192.","title":"System limitations"},{"location":"manual/the_gambit_system/","text":"The Gambit System The Gambit programming system is a full implementation of the Scheme language which conforms to the R4RS, R5RS, R7RS and IEEE Scheme standards. It consists of two main programs: gsi , the Gambit Scheme interpreter, and gsc , the Gambit Scheme compiler. The Gambit Scheme compiler translates Scheme code to another target language, currently C or JavaScript. The C target is the most mature and it offers portability and fast execution. The JavaScript target allows writing web apps in Scheme. Most of the Gambit system, including the interpreter and compiler, is written in Scheme and compiled to portable C code using the compiler. The high portability of the generated C code allows the interpreter, compiler and user programs to be easily compiled and executed on any platform for which a C compiler is available. With appropriate declarations in the source code the compiled Scheme programs run roughly as fast as equivalent C programs. For the most up to date information on Gambit and related resources please visit the Gambit web page at https://gambitscheme.org . Issues should be reported on the github source code repository https://github.com/gambit/gambit .","title":"The Gambit System"},{"location":"manual/the_gambit_system/#the-gambit-system","text":"The Gambit programming system is a full implementation of the Scheme language which conforms to the R4RS, R5RS, R7RS and IEEE Scheme standards. It consists of two main programs: gsi , the Gambit Scheme interpreter, and gsc , the Gambit Scheme compiler. The Gambit Scheme compiler translates Scheme code to another target language, currently C or JavaScript. The C target is the most mature and it offers portability and fast execution. The JavaScript target allows writing web apps in Scheme. Most of the Gambit system, including the interpreter and compiler, is written in Scheme and compiled to portable C code using the compiler. The high portability of the generated C code allows the interpreter, compiler and user programs to be easily compiled and executed on any platform for which a C compiler is available. With appropriate declarations in the source code the compiled Scheme programs run roughly as fast as equivalent C programs. For the most up to date information on Gambit and related resources please visit the Gambit web page at https://gambitscheme.org . Issues should be reported on the github source code repository https://github.com/gambit/gambit .","title":"The Gambit System"},{"location":"manual/the_gambit_system/accessing_the_system_files/","text":"Accessing the system files Files related to Gambit, such as executables, libraries and header files, are stored in multiple Gambit installation directories. Gambit may be installed on a system according to two different installation models. In the first model there is a single directory where all the Gambit installation directories are stored. This central installation directory is typically /usr/local/Gambit under UNIX, /Library/Gambit under macOS and C:/Program Files/Gambit under Microsoft Windows. This may have been overridden when the system was built with the command configure --prefix=/my/Gambit . If the system was built with the command configure --enable-multiple-versions then the central installation directory is prefix/version, where version is the system version string (e.g. v4.9.4 for Gambit v4.9.4). Moreover, prefix/current will be a symbolic link which points to the central installation directory. In this model, the Gambit installation directory named X is simply the subdirectory X of the central installation directory. In the second model some or all of the Gambit installation directories are stored in installation specific directories. The location of these directories is assigned when the system is built using the command configure --bindir=/my/bin --includedir=/my/include --libdir=/my/lib . The advantage of the first model is that it is easy to have multiple versions of Gambit coexist and to remove all the files of a given version. However, the second model may be necessary to conform to the package installation conventions of some operating systems. Executable programs such as the interpreter gsi and compiler gsc can be found in the bin installation directory. Adding this directory to the PATH environment variable allows these programs to be started by simply entering their name. This is done automatically by the macOS and Microsoft Windows installers. The runtime library is located in the lib installation directory. When the system\u2019s runtime library is built as a shared-library (with the command configure --enable-shared ) all programs built with Gambit, including the interpreter and compiler, need to find this library when they are executed and consequently this directory must be in the path searched by the system for shared-libraries. This path is normally specified through an environment variable which is LD_LIBRARY_PATH on most versions of UNIX, LIBPATH on AIX, SHLIB_PATH on HPUX, DYLD_LIBRARY_PATH on macOS, and PATH on Microsoft Windows. If the shell is sh , the setting of the path can be made for a single execution by prefixing the program name with the environment variable assignment, as in: $ LD_LIBRARY_PATH=/usr/local/Gambit/lib gsi A similar problem exists with the Gambit header file gambit.h , located in the include installation directory. This header file is needed for compiling Scheme programs with the Gambit compiler. When the C compiler is being called explicitly it may be necessary to use a -I<dir> command line option to indicate where to find header files and a -L<dir> command line option to indicate where to find libraries. Access to both of these files can be simplified by creating a link to them in the appropriate system directories (special privileges may however be required): $ ln -s /usr/local/Gambit/lib/libgambit.a /usr/lib # name may vary $ ln -s /usr/local/Gambit/include/gambit.h /usr/include Alternatively these files can be copied or linked in the directory where the C compiler is invoked (this requires no special privileges). Another approach is to set some environment variables which are used to tell the C compiler where to find header files and libraries. For example, the following settings can be used for the gcc C compiler: $ export LIBRARY_PATH=/usr/local/Gambit/lib $ export CPATH=/usr/local/Gambit/include Note that this may have been done by the installation process. In particular, the macOS and Microsoft Windows prebuilt installers set up the environment so that the gcc compiler finds these files automatically.","title":"Accessing the system files"},{"location":"manual/the_gambit_system/accessing_the_system_files/#accessing-the-system-files","text":"Files related to Gambit, such as executables, libraries and header files, are stored in multiple Gambit installation directories. Gambit may be installed on a system according to two different installation models. In the first model there is a single directory where all the Gambit installation directories are stored. This central installation directory is typically /usr/local/Gambit under UNIX, /Library/Gambit under macOS and C:/Program Files/Gambit under Microsoft Windows. This may have been overridden when the system was built with the command configure --prefix=/my/Gambit . If the system was built with the command configure --enable-multiple-versions then the central installation directory is prefix/version, where version is the system version string (e.g. v4.9.4 for Gambit v4.9.4). Moreover, prefix/current will be a symbolic link which points to the central installation directory. In this model, the Gambit installation directory named X is simply the subdirectory X of the central installation directory. In the second model some or all of the Gambit installation directories are stored in installation specific directories. The location of these directories is assigned when the system is built using the command configure --bindir=/my/bin --includedir=/my/include --libdir=/my/lib . The advantage of the first model is that it is easy to have multiple versions of Gambit coexist and to remove all the files of a given version. However, the second model may be necessary to conform to the package installation conventions of some operating systems. Executable programs such as the interpreter gsi and compiler gsc can be found in the bin installation directory. Adding this directory to the PATH environment variable allows these programs to be started by simply entering their name. This is done automatically by the macOS and Microsoft Windows installers. The runtime library is located in the lib installation directory. When the system\u2019s runtime library is built as a shared-library (with the command configure --enable-shared ) all programs built with Gambit, including the interpreter and compiler, need to find this library when they are executed and consequently this directory must be in the path searched by the system for shared-libraries. This path is normally specified through an environment variable which is LD_LIBRARY_PATH on most versions of UNIX, LIBPATH on AIX, SHLIB_PATH on HPUX, DYLD_LIBRARY_PATH on macOS, and PATH on Microsoft Windows. If the shell is sh , the setting of the path can be made for a single execution by prefixing the program name with the environment variable assignment, as in: $ LD_LIBRARY_PATH=/usr/local/Gambit/lib gsi A similar problem exists with the Gambit header file gambit.h , located in the include installation directory. This header file is needed for compiling Scheme programs with the Gambit compiler. When the C compiler is being called explicitly it may be necessary to use a -I<dir> command line option to indicate where to find header files and a -L<dir> command line option to indicate where to find libraries. Access to both of these files can be simplified by creating a link to them in the appropriate system directories (special privileges may however be required): $ ln -s /usr/local/Gambit/lib/libgambit.a /usr/lib # name may vary $ ln -s /usr/local/Gambit/include/gambit.h /usr/include Alternatively these files can be copied or linked in the directory where the C compiler is invoked (this requires no special privileges). Another approach is to set some environment variables which are used to tell the C compiler where to find header files and libraries. For example, the following settings can be used for the gcc C compiler: $ export LIBRARY_PATH=/usr/local/Gambit/lib $ export CPATH=/usr/local/Gambit/include Note that this may have been done by the installation process. In particular, the macOS and Microsoft Windows prebuilt installers set up the environment so that the gcc compiler finds these files automatically.","title":"Accessing the system files"},{"location":"manual/threads/","text":"Threads Gambit supports the execution of multiple Scheme threads. These threads are managed entirely by Gambit's runtime and are not related to the host operating system's threads. Gambit's runtime does not currently take advantage of multiprocessors (i.e. at most one thread is running).","title":"Threads"},{"location":"manual/threads/#threads","text":"Gambit supports the execution of multiple Scheme threads. These threads are managed entirely by Gambit's runtime and are not related to the host operating system's threads. Gambit's runtime does not currently take advantage of multiprocessors (i.e. at most one thread is running).","title":"Threads"},{"location":"manual/threads/condvar_objects/","text":"Condition variable objects A condition variable represents a set of blocked threads. These blocked threads are waiting for a certain condition to become true. When a thread modifies some program state that might make the condition true, the thread unblocks some number of threads (one or all depending on the primitive used) so they can check if the condition is now true. This allows complex forms of interthread synchronization to be expressed more conveniently than with mutexes alone. Each condition variable has a specific field which can be used in an application specific way to associate data with the condition variable.","title":"Condition variable objects"},{"location":"manual/threads/condvar_objects/#condition-variable-objects","text":"A condition variable represents a set of blocked threads. These blocked threads are waiting for a certain condition to become true. When a thread modifies some program state that might make the condition true, the thread unblocks some number of threads (one or all depending on the primitive used) so they can check if the condition is now true. This allows complex forms of interthread synchronization to be expressed more conveniently than with mutexes alone. Each condition variable has a specific field which can be used in an application specific way to associate data with the condition variable.","title":"Condition variable objects"},{"location":"manual/threads/fairness/","text":"Fairness In various situations the scheduler must select one thread from a set of threads (e.g. which thread to run when a running thread blocks or expires its quantum, which thread to unblock when a mutex becomes unlocked or a condition variable is signaled). The constraints on the selection process determine the scheduler\u2019s fairness . The selection depends on the order in which threads become runnable or blocked and on the priority attached to the threads. The definition of fairness requires the notion of time ordering, i.e. \"event A occured before event B\". For the purpose of establishing time ordering, the scheduler uses a clock with a discrete, usually variable, resolution (a \"tick\"). Events occuring in a given tick can be considered to be simultaneous (i.e. if event A occured before event B in real time, then the scheduler will claim that event A occured before event B unless both events fall within the same tick, in which case the scheduler arbitrarily chooses a time ordering). Each thread T has three priorities which affect fairness; the base priority , the boosted priority , and the effective priority . The base priority is the value contained in T 's base priority field (which is set with the thread-base-priority-set! primitive). T's boosted flag field contains a boolean that affects T 's boosted priority . When the boosted flag field is false, the boosted priority is equal to the base priority, otherwise the boosted priority is equal to the base priority plus the value contained in T 's priority boost field (which is set with the thread-priority-boost-set! primitive). The boosted flag field is set to false when a thread is created, when its quantum expires, and when thread-yield! is called. The boosted flag field is set to true when a thread blocks. By carefully choosing the base priority and priority boost, relatively to the other threads, it is possible to set up an interactive thread so that it has good I/O response time without being a CPU hog when it performs long computations. The effective priority is equal to the maximum of T 's boosted priority and the effective priority of all the threads that are blocked on a mutex owned by T . This priority inheritance avoids priority inversion problems that would prevent a high priority thread blocked at the entry of a critical section to progress because a low priority thread inside the critical section is preempted for an arbitrary long time by a medium priority thread. Let P(T) be the effective priority of thread T and let R(T) be the most recent time when one of the following events occurred for thread T , thus making it runnable: T was started by calling thread-start! , T called thread-yield! , T expired its quantum, or T became unblocked. Let the relation NL(T1,T2) , \"T1 no later than T2\", be true if P(T1) R(T2) , and false otherwise. The scheduler will schedule the execution of threads in such a way that whenever there is at least one runnable thread within a finite time at least one thread will be running and there is never a pair of runnable threads T1 and T2 for which NL(T1,T2) is true and T1 is not running and T2 is running. A thread T expires its quantum when an amount of time equal to T 's quantum has elapsed since T entered the running state and T did not block, terminate or call thread-yield! . At that point T exits the running state to allow other threads to run. A thread's quantum is thus an indication of the rate of progress of the thread relative to the other threads of the same priority. Moreover, the resolution of the timer measuring the running time may cause a certain deviation from the quantum, so a thread's quantum should only be viewed as an approximation of the time it can run before yielding to another thread. Threads blocked on a given mutex or condition variable will unblock in an order which is consistent with decreasing priority and increasing blocking time (i.e. the highest priority thread unblocks first, and among equal priority threads the one that blocked first unblocks first).","title":"Fairness"},{"location":"manual/threads/fairness/#fairness","text":"In various situations the scheduler must select one thread from a set of threads (e.g. which thread to run when a running thread blocks or expires its quantum, which thread to unblock when a mutex becomes unlocked or a condition variable is signaled). The constraints on the selection process determine the scheduler\u2019s fairness . The selection depends on the order in which threads become runnable or blocked and on the priority attached to the threads. The definition of fairness requires the notion of time ordering, i.e. \"event A occured before event B\". For the purpose of establishing time ordering, the scheduler uses a clock with a discrete, usually variable, resolution (a \"tick\"). Events occuring in a given tick can be considered to be simultaneous (i.e. if event A occured before event B in real time, then the scheduler will claim that event A occured before event B unless both events fall within the same tick, in which case the scheduler arbitrarily chooses a time ordering). Each thread T has three priorities which affect fairness; the base priority , the boosted priority , and the effective priority . The base priority is the value contained in T 's base priority field (which is set with the thread-base-priority-set! primitive). T's boosted flag field contains a boolean that affects T 's boosted priority . When the boosted flag field is false, the boosted priority is equal to the base priority, otherwise the boosted priority is equal to the base priority plus the value contained in T 's priority boost field (which is set with the thread-priority-boost-set! primitive). The boosted flag field is set to false when a thread is created, when its quantum expires, and when thread-yield! is called. The boosted flag field is set to true when a thread blocks. By carefully choosing the base priority and priority boost, relatively to the other threads, it is possible to set up an interactive thread so that it has good I/O response time without being a CPU hog when it performs long computations. The effective priority is equal to the maximum of T 's boosted priority and the effective priority of all the threads that are blocked on a mutex owned by T . This priority inheritance avoids priority inversion problems that would prevent a high priority thread blocked at the entry of a critical section to progress because a low priority thread inside the critical section is preempted for an arbitrary long time by a medium priority thread. Let P(T) be the effective priority of thread T and let R(T) be the most recent time when one of the following events occurred for thread T , thus making it runnable: T was started by calling thread-start! , T called thread-yield! , T expired its quantum, or T became unblocked. Let the relation NL(T1,T2) , \"T1 no later than T2\", be true if P(T1) R(T2) , and false otherwise. The scheduler will schedule the execution of threads in such a way that whenever there is at least one runnable thread within a finite time at least one thread will be running and there is never a pair of runnable threads T1 and T2 for which NL(T1,T2) is true and T1 is not running and T2 is running. A thread T expires its quantum when an amount of time equal to T 's quantum has elapsed since T entered the running state and T did not block, terminate or call thread-yield! . At that point T exits the running state to allow other threads to run. A thread's quantum is thus an indication of the rate of progress of the thread relative to the other threads of the same priority. Moreover, the resolution of the timer measuring the running time may cause a certain deviation from the quantum, so a thread's quantum should only be viewed as an approximation of the time it can run before yielding to another thread. Threads blocked on a given mutex or condition variable will unblock in an order which is consistent with decreasing priority and increasing blocking time (i.e. the highest priority thread unblocks first, and among equal priority threads the one that blocked first unblocks first).","title":"Fairness"},{"location":"manual/threads/introduction/","text":"Introduction Multithreading is a paradigm that is well suited for building complex systems such as: servers, GUIs, and high-level operating systems. Gambit's thread system offers mechanisms for creating threads of execution and for synchronizing them. The thread system also supports features which are useful in a real-time context, such as priorities, priority inheritance and timeouts. The thread system provides the following data types: Thread (a virtual processor which shares object space with all other threads) Mutex (a mutual exclusion device, also known as a lock and binary semaphore) Condition variable (a set of blocked threads)","title":"Introduction"},{"location":"manual/threads/introduction/#introduction","text":"Multithreading is a paradigm that is well suited for building complex systems such as: servers, GUIs, and high-level operating systems. Gambit's thread system offers mechanisms for creating threads of execution and for synchronizing them. The thread system also supports features which are useful in a real-time context, such as priorities, priority inheritance and timeouts. The thread system provides the following data types: Thread (a virtual processor which shares object space with all other threads) Mutex (a mutual exclusion device, also known as a lock and binary semaphore) Condition variable (a set of blocked threads)","title":"Introduction"},{"location":"manual/threads/memory_coherency/","text":"Memory coherency Read and write operations on the store (such as reading and writing a variable, an element of a vector or a string) are not atomic. It is an error for a thread to write a location in the store while some other thread reads or writes that same location. It is the responsibility of the application to avoid write/read and write/write races through appropriate uses of the synchronization primitives. Concurrent reads and writes to ports are allowed. It is the responsibility of the implementation to serialize accesses to a given port using the appropriate synchronization primitives.","title":"Memory coherency"},{"location":"manual/threads/memory_coherency/#memory-coherency","text":"Read and write operations on the store (such as reading and writing a variable, an element of a vector or a string) are not atomic. It is an error for a thread to write a location in the store while some other thread reads or writes that same location. It is the responsibility of the application to avoid write/read and write/write races through appropriate uses of the synchronization primitives. Concurrent reads and writes to ports are allowed. It is the responsibility of the implementation to serialize accesses to a given port using the appropriate synchronization primitives.","title":"Memory coherency"},{"location":"manual/threads/mutex_objects/","text":"Mutex objects A mutex can be in one of four states: locked (either owned or not owned ) and unlocked (either abandoned or not abandoned ). An attempt to lock a mutex only succeeds if the mutex is in an unlocked state, otherwise the current thread will wait. A mutex in the locked/owned state has an associated owner thread , which by convention is the thread that is responsible for unlocking the mutex (this case is typical of critical sections implemented as \"lock mutex, perform operation, unlock mutex\"). A mutex in the locked/not-owned state is not linked to a particular thread. A mutex becomes locked when a thread locks it using the mutex-lock! primitive. A mutex becomes unlocked/abandoned when the owner of a locked/owned mutex terminates. A mutex becomes unlocked/not-abandoned when a thread unlocks it using the mutex-unlock! primitive. The mutex primitives do not implement recursive mutex semantics. An attempt to lock a mutex that is locked implies that the current thread waits even if the mutex is owned by the current thread (this can lead to a deadlock if no other thread unlocks the mutex). Each mutex has a specific field which can be used in an application specific way to associate data with the mutex.","title":"Mutex objects"},{"location":"manual/threads/mutex_objects/#mutex-objects","text":"A mutex can be in one of four states: locked (either owned or not owned ) and unlocked (either abandoned or not abandoned ). An attempt to lock a mutex only succeeds if the mutex is in an unlocked state, otherwise the current thread will wait. A mutex in the locked/owned state has an associated owner thread , which by convention is the thread that is responsible for unlocking the mutex (this case is typical of critical sections implemented as \"lock mutex, perform operation, unlock mutex\"). A mutex in the locked/not-owned state is not linked to a particular thread. A mutex becomes locked when a thread locks it using the mutex-lock! primitive. A mutex becomes unlocked/abandoned when the owner of a locked/owned mutex terminates. A mutex becomes unlocked/not-abandoned when a thread unlocks it using the mutex-unlock! primitive. The mutex primitives do not implement recursive mutex semantics. An attempt to lock a mutex that is locked implies that the current thread waits even if the mutex is owned by the current thread (this can lead to a deadlock if no other thread unlocks the mutex). Each mutex has a specific field which can be used in an application specific way to associate data with the mutex.","title":"Mutex objects"},{"location":"manual/threads/primordial_thread/","text":"Primordial thread The execution of a program is initially under the control of a single thread known as the primordial thread . The primordial thread has an unspecified base priority, priority boost, boosted flag, quantum, name, specific field, dynamic environment, dynamic-wind stack, and exception-handler . All threads are terminated when the primordial thread terminates (normally or not).","title":"Primordial thread"},{"location":"manual/threads/primordial_thread/#primordial-thread","text":"The execution of a program is initially under the control of a single thread known as the primordial thread . The primordial thread has an unspecified base priority, priority boost, boosted flag, quantum, name, specific field, dynamic environment, dynamic-wind stack, and exception-handler . All threads are terminated when the primordial thread terminates (normally or not).","title":"Primordial thread"},{"location":"manual/threads/procedures/","text":"Procedures current-thread (current-thread) ;; procedure This procedure returns the current thread. For example: > (current-thread) #<thread #1 primordial> > (eq? (current-thread) (current-thread)) #t thread? (thread? obj) ;; procedure This procedure returns #t when obj is a thread object and #f otherwise. For example: > (thread? (current-thread)) #t > (thread? 'foo) #f make-thread make-root-thread (make-thread thunk [name [thread-group]]) ;; procedure (make-root-thread thunk [name [thread-group [input-port [output-port]]]]) ;; procedure The make-thread procedure creates and returns an initialized thread. This thread is not automatically made runnable (the procedure thread-start! must be used for this). A thread has the following fields: base priority, priority boost, boosted flag, quantum, name, specific, end-result, end-exception, and a list of locked/owned mutexes it owns. The thread's execution consists of a call to thunk with the initial continuation. This continuation causes the (then) current thread to store the result in its end-result field, abandon all mutexes it owns, and finally terminate. The dynamic-wind stack of the initial continuation is empty. The optional name is an arbitrary Scheme object which identifies the thread (useful for debugging); it defaults to an unspecified value. The specific field is set to an unspecified value. The optional thread-group indicates which thread group this thread belongs to; it defaults to the thread group of the current thread. The base priority, priority boost, and quantum of the thread are set to the same value as the current thread and the boosted flag is set to false. The thread's mailbox is initially empty. The thread inherits the dynamic environment from the current thread. Moreover, in this dynamic environment the exception-handler is bound to the initial exception-handler which is a unary procedure which causes the (then) current thread to store in its end-exception field an uncaught-exception object whose \"reason\" is the argument of the handler, abandon all mutexes it owns, and finally terminate. The make-root-thread procedure behaves like the make-thread procedure except the created thread does not inherit the dynamic environment from the current thread and the base priority is set to 0 , the priority boost is set to 1.0e-6 , and the quantum is set to 0.02 . The dynamic environment of the thread has the global bindings of the parameter objects, except current-input-port which is bound to input-port , current-output-port which is bound to output-port , and current-directory which is bound to the initial current working directory of the current process. If input-port is not specified it defaults to a port corresponding to the standard input ( stdin ). If output-port is not specified it defaults to a port corresponding to the standard output ( stdout ). For example: > (make-thread (lambda () (write 'hello))) #<thread #2> > (make-root-thread (lambda () (write 'world)) 'a-name) #<thread #3 a-name> thread (thread thunk) ;; procedure The thread procedure creates, starts and returns a new thread. The call (thread thunk) is equivalent to (thread-start! (make-thread thunk)) . For example: > (define a (thread (lambda () (expt 2 1005)))) > (define b (thread (lambda () (expt 2 1000)))) > (/ (thread-join! a) (thread-join! b)) 32 thread-name (thread-name thread) ;; procedure This procedure returns the name of the thread. For example: > (thread-name (make-thread (lambda () #f) 'foo)) foo thread-specific thread-specific-set! (thread-specific thread) ;; procedure (thread-specific-set! thread obj) ;; procedure The thread-specific procedure returns the content of the thread's specific field. The thread-specific-set! procedure stores obj into the thread's specific field and returns an unspecified value. For example: > (thread-specific-set! (current-thread) \"hello\") > (thread-specific (current-thread)) \"hello\" thread-base-priority thread-base-priority-set! (thread-base-priority thread) ;; procedure (thread-base-priority-set! thread priority) ;; procedure The procedure thread-base-priority returns a real number which corresponds to the base priority of the thread. The procedure thread-base-priority-set! changes the base priority of the thread to priority and returns an unspecified value. The priority must be a real number. For example: > (thread-base-priority-set! (current-thread) 12.3) > (thread-base-priority (current-thread)) 12.3 thread-priority-boost thread-priority-boost-set! (thread-priority-boost thread) ;; procedure (thread-priority-boost-set! thread priority-boost) ;; procedure The procedure thread-priority-boost returns a real number which corresponds to the priority boost of the thread. The procedure thread-priority-boost-set! changes the priority boost of the thread to priority-boost and returns an unspecified value. The priority-boost must be a nonnegative real. For example: > (thread-priority-boost-set! (current-thread) 2.5) > (thread-priority-boost (current-thread)) 2.5 thread-quantum thread-quantum-set! (thread-quantum thread) ;; procedure (thread-quantum-set! thread quantum) ;; procedure The procedure thread-quantum returns a real number which corresponds to the quantum of the thread. The procedure thread-quantum-set! changes the quantum of the thread to quantum and returns an unspecified value. The quantum must be a nonnegative real. A value of zero selects the smallest quantum supported by the implementation. For example: > (thread-quantum-set! (current-thread) 1.5) > (thread-quantum (current-thread)) 1.5 > (thread-quantum-set! (current-thread) 0) > (thread-quantum (current-thread)) 0. thread-start! (thread-start! thread) ;; procedure This procedure makes thread runnable and returns the thread. The thread must be an initialized thread. For example: > (let ((t (thread-start! (make-thread (lambda () (write 'a)))))) (write 'b) (thread-join! t)) ab> or ba> Note It is useful to separate thread creation and thread activation to avoid the race condition that would occur if the created thread tries to examine a table in which the current thread stores the created thread. See the last example of the thread-terminate! procedure which contains mutually recursive threads. thread-yield! (thread-yield!) ;; procedure This procedure causes the current thread to exit the running state as if its quantum had expired and returns an unspecified value. For example: ; a busy loop that avoids being too wasteful of the CPU (let loop () (if (mutex-lock! m 0) ; try to lock m but don't block (begin (display \"locked mutex m\") (mutex-unlock! m)) (begin (do-something-else) (thread-yield!) ; relinquish rest of quantum (loop)))) thread-sleep! (thread-sleep! timeout) ;; procedure This procedure causes the current thread to wait until the timeout is reached and returns an unspecified value. This blocks the thread only if timeout represents a point in the future. It is an error for timeout to be #f . For example: ; a clock with a gradual drift: (let loop ((x 1)) (thread-sleep! 1) (write x) (loop (+ x 1))) ; a clock with no drift: (let ((start (time->seconds (current-time))) (let loop ((x 1)) (thread-sleep! (seconds->time (+ x start))) (write x) (loop (+ x 1)))) thread-terminate! (thread-terminate! thread) ;; procedure This procedure causes an abnormal termination of the thread . If the thread is not already terminated, all mutexes owned by the thread become unlocked/abandoned and a terminated-thread-exception object is stored in the thread's end-exception field. If thread is the current thread, thread-terminate! does not return. Otherwise thread-terminate! returns an unspecified value; the termination of the thread will occur at some point between the calling of thread-terminate! and a finite time in the future (an explicit thread synchronization is needed to detect termination, see thread-join! ). For example: (define (amb thunk1 thunk2) (let ((result #f) (result-mutex (make-mutex)) (done-mutex (make-mutex))) (letrec ((child1 (make-thread (lambda () (let ((x (thunk1))) (mutex-lock! result-mutex #f #f) (set! result x) (thread-terminate! child2) (mutex-unlock! done-mutex))))) (child2 (make-thread (lambda () (let ((x (thunk2))) (mutex-lock! result-mutex #f #f) (set! result x) (thread-terminate! child1) (mutex-unlock! done-mutex)))))) (mutex-lock! done-mutex #f #f) (thread-start! child1) (thread-start! child2) (mutex-lock! done-mutex #f #f) result))) Note This operation must be used carefully because it terminates a thread abruptly and it is impossible for that thread to perform any kind of cleanup. This may be a problem if the thread is in the middle of a critical section where some structure has been put in an inconsistent state. However, another thread attempting to enter this critical section will raise an abandoned-mutex-exception object because the mutex is unlocked/abandoned. This helps avoid observing an inconsistent state. Clean termination can be obtained by polling, as shown in the example below. For example: (define (spawn thunk) (let ((t (make-thread thunk))) (thread-specific-set! t #t) (thread-start! t) t)) (define (stop! thread) (thread-specific-set! thread #f) (thread-join! thread)) (define (keep-going?) (thread-specific (current-thread))) (define count! (let ((m (make-mutex)) (i 0)) (lambda () (mutex-lock! m) (let ((x (+ i 1))) (set! i x) (mutex-unlock! m) x)))) (define (increment-forever!) (let loop () (count!) (if (keep-going?) (loop)))) (let ((t1 (spawn increment-forever!)) (t2 (spawn increment-forever!))) (thread-sleep! 1) (stop! t1) (stop! t2) (count!)) ==> 377290 thread-join! (thread-join! thread [timeout [timeout-val]]) procedure This procedure causes the current thread to wait until the thread terminates (normally or not) or until the timeout is reached if timeout is supplied. If the timeout is reached, thread-join! returns timeout-val if it is supplied, otherwise a join-timeout-exception object is raised. If the thread terminated normally, the content of the end-result field is returned, otherwise the content of the end-exception field is raised. For example: (let ((t (thread-start! (make-thread (lambda () (expt 2 100)))))) (do-something-else) (thread-join! t)) ==> 1267650600228229401496703205376 (let ((t (thread-start! (make-thread (lambda () (raise 123)))))) (do-something-else) (with-exception-handler (lambda (exc) (if (uncaught-exception? exc) (* 10 (uncaught-exception-reason exc)) 99999)) (lambda () (+ 1 (thread-join! t))))) ==> 1231 (define thread-alive? (let ((unique (list 'unique))) (lambda (thread) ; Note: this procedure raises an exception if ; the thread terminated abnormally. (eq? (thread-join! thread 0 unique) unique)))) (define (wait-for-termination! thread) (let ((eh (current-exception-handler))) (with-exception-handler (lambda (exc) (if (not (or (terminated-thread-exception? exc) (uncaught-exception? exc))) (eh exc))) ; unexpected exceptions are handled by eh (lambda () ; The following call to thread-join! will wait until the ; thread terminates. If the thread terminated normally ; thread-join! will return normally. If the thread ; terminated abnormally then one of these two exception ; objects is raised by thread-join!: ; - terminated-thread-exception object ; - uncaught-exception object (thread-join! thread) #f)))) ; ignore result of thread-join! thread-send (thread-send thread msg) ;; procedure Each thread has a mailbox which stores messages delivered to the thread in the order delivered. The procedure thread-send adds the message msg at the end of the mailbox of thread thread and returns an unspecified value. For example: > (thread-send (current-thread) 111) > (thread-send (current-thread) 222) > (thread-receive) 111 > (thread-receive) 222 thread-receive thread-mailbox-next thread-mailbox-rewind thread-mailbox-extract-and-rewind (thread-receive [timeout [default]]) ;; procedure (thread-mailbox-next [timeout [default]]) ;; procedure (thread-mailbox-rewind) ;; procedure (thread-mailbox-extract-and-rewind) ;; procedure To allow a thread to examine the messages in its mailbox without removing them from the mailbox, each thread has a mailbox cursor which normally points to the last message accessed in the mailbox. When a mailbox cursor is rewound using the procedure thread-mailbox-rewind or thread-mailbox-extract-and-rewind or thread-receive , the cursor does not point to a message, but the next call to thread-receive and thread-mailbox-next will set the cursor to the oldest message in the mailbox. The procedure thread-receive advances the mailbox cursor of the current thread to the next message, removes that message from the mailbox, rewinds the mailbox cursor, and returns the message. When timeout is not specified, the current thread will wait until a message is available in the mailbox. When timeout is specified and default is not specified, a mailbox-receive-timeout-exception object is raised if the timeout is reached before a message is available. When timeout is specified and default is specified, default is returned if the timeout is reached before a message is available. The procedure thread-mailbox-next behaves like thread-receive except that the message remains in the mailbox and the mailbox cursor is not rewound. The procedures thread-mailbox-rewind or thread-mailbox-extract-and-rewind rewind the mailbox cursor of the current thread so that the next call to thread-mailbox-next and thread-receive will access the oldest message in the mailbox. Additionally the procedure thread-mailbox-extract-and-rewind will remove from the mailbox the message most recently accessed by a call to thread-mailbox-next . When thread-mailbox-next has not been called since the last call to thread-receive or thread-mailbox-rewind or thread-mailbox-extract-and-rewind , a call to thread-mailbox-extract-and-rewind only resets the mailbox cursor (no message is removed). For example: > (thread-send (current-thread) 111) > (thread-receive 1 999) 111 > (thread-send (current-thread) 222) > (thread-send (current-thread) 333) > (thread-mailbox-next 1 999) 222 > (thread-mailbox-next 1 999) 333 > (thread-mailbox-next 1 999) 999 > (thread-mailbox-extract-and-rewind) > (thread-receive 1 999) 222 > (thread-receive 1 999) 999 mailbox-receive-timeout-exception? mailbox-receive-timeout-exception-procedure mailbox-receive-timeout-exception-arguments (mailbox-receive-timeout-exception? obj) procedure (mailbox-receive-timeout-exception-procedure exc) procedure (mailbox-receive-timeout-exception-arguments exc) procedure Mailbox-receive-timeout-exception objects are raised by the procedures thread-receive and thread-mailbox-next when a timeout expires before a message is available and no default value is specified. The parameter exc must be a mailbox-receive-timeout-exception object. The procedure mailbox-receive-timeout-exception? returns #t when obj is a mailbox-receive-timeout-exception object and #f otherwise. The procedure mailbox-receive-timeout-exception-procedure returns the procedure that raised exc . The procedure mailbox-receive-timeout-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define (handler exc) (if (mailbox-receive-timeout-exception? exc) (list (mailbox-receive-timeout-exception-procedure exc) (mailbox-receive-timeout-exception-arguments exc)) 'not-mailbox-receive-timeout-exception)) > (with-exception-catcher handler (lambda () (thread-receive 1))) (#<procedure #2 thread-receive> (1)) mutex? (mutex? obj) ;; procedure This procedure returns #t when obj is a mutex object and #f otherwise. For example: > (mutex? (make-mutex)) #t > (mutex? 'foo) #f make-mutex (make-mutex [name]) ;; procedure This procedure returns a new mutex in the unlocked/not-abandoned state. The optional name is an arbitrary Scheme object which identifies the mutex (useful for debugging); it defaults to an unspecified value. The mutex's specific field is set to an unspecified value. For example: > (make-mutex) #<mutex #2> > (make-mutex 'foo) #<mutex #3 foo> mutex-name (mutex-name mutex) ;; procedure Returns the name of the mutex. For example: > (mutex-name (make-mutex 'foo)) foo mutex-specific mutex-specific-set! (mutex-specific mutex) ;; procedure (mutex-specific-set! mutex obj) ;; procedure The mutex-specific procedure returns the content of the mutex's specific field. The mutex-specific-set! procedure stores obj into the mutex's specific field and returns an unspecified value. For example: > (define m (make-mutex)) > (mutex-specific-set! m \"hello\") > (mutex-specific m) \"hello\" > (define (mutex-lock-recursively! mutex) (if (eq? (mutex-state mutex) (current-thread)) (let ((n (mutex-specific mutex))) (mutex-specific-set! mutex (+ n 1))) (begin (mutex-lock! mutex) (mutex-specific-set! mutex 0)))) > (define (mutex-unlock-recursively! mutex) (let ((n (mutex-specific mutex))) (if (= n 0) (mutex-unlock! mutex) (mutex-specific-set! mutex (- n 1))))) > (mutex-lock-recursively! m) > (mutex-lock-recursively! m) > (mutex-lock-recursively! m) > (mutex-specific m) 2 mutex-state (mutex-state mutex) ;; procedure This procedure returns information about the state of the mutex. The possible results are: thread T : the mutex is in the locked/owned state and thread T is the owner of the mutex symbol not-owned : the mutex is in the locked/not-owned state symbol abandoned : the mutex is in the unlocked/abandoned state symbol not-abandoned : the mutex is in the unlocked/not-abandoned state For example: (mutex-state (make-mutex)) ==> not-abandoned (define (thread-alive? thread) (let ((mutex (make-mutex))) (mutex-lock! mutex #f thread) (let ((state (mutex-state mutex))) (mutex-unlock! mutex) ; avoid space leak (eq? state thread)))) mutex-lock! (mutex-lock! mutex [timeout [thread]]) ;; procedure This procedure locks mutex. If the mutex is currently locked, the current thread waits until the mutex is unlocked, or until the timeout is reached if timeout is supplied. If the timeout is reached, mutex-lock! returns \u2018#f\u2019. Otherwise, the state of the mutex is changed as follows: if thread is #f the mutex becomes locked/not-owned, otherwise, let T be thread (or the current thread if thread is not supplied), if T is terminated the mutex becomes unlocked/abandoned, otherwise mutex becomes locked/owned with T as the owner. After changing the state of the mutex, an abandoned-mutex-exception object is raised if the mutex was unlocked/abandoned before the state change, otherwise mutex-lock! returns #t . It is not an error if the mutex is owned by the current thread (but the current thread will have to wait). For example: ; an implementation of a mailbox object of depth one; this ; implementation does not behave well in the presence of forced ; thread terminations using thread-terminate! (deadlock can occur ; if a thread is terminated in the middle of a put! or get! operation) (define (make-empty-mailbox) (let ((put-mutex (make-mutex)) ; allow put! operation (get-mutex (make-mutex)) (cell #f)) (define (put! obj) (mutex-lock! put-mutex #f #f) ; prevent put! operation (set! cell obj) (mutex-unlock! get-mutex)) ; allow get! operation (define (get!) (mutex-lock! get-mutex #f #f) ; wait until object in mailbox (let ((result cell)) (set! cell #f) ; prevent space leaks (mutex-unlock! put-mutex) ; allow put! operation result)) (mutex-lock! get-mutex #f #f) ; prevent get! operation (lambda (msg) (case msg ((put!) put!) ((get!) get!) (else (error \"unknown message\")))))) (define (mailbox-put! m obj) ((m 'put!) obj)) (define (mailbox-get! m) ((m 'get!))) ; an alternate implementation of thread-sleep! (define (sleep! timeout) (let ((m (make-mutex))) (mutex-lock! m #f #f) (mutex-lock! m timeout #f))) ; a procedure that waits for one of two mutexes to unlock (define (lock-one-of! mutex1 mutex2) ; this procedure assumes that neither mutex1 or mutex2 ; are owned by the current thread (let ((ct (current-thread)) (done-mutex (make-mutex))) (mutex-lock! done-mutex #f #f) (let ((t1 (thread-start! (make-thread (lambda () (mutex-lock! mutex1 #f ct) (mutex-unlock! done-mutex))))) (t2 (thread-start! (make-thread (lambda () (mutex-lock! mutex2 #f ct) (mutex-unlock! done-mutex)))))) (mutex-lock! done-mutex #f #f) (thread-terminate! t1) (thread-terminate! t2) (if (eq? (mutex-state mutex1) ct) (begin (if (eq? (mutex-state mutex2) ct) (mutex-unlock! mutex2)) ; don't lock both mutex1) mutex2)))) mutex-unlock! (mutex-unlock! mutex [condition-variable [timeout]]) ;; procedure This procedure unlocks the mutex by making it unlocked/not-abandoned. It is not an error to unlock an unlocked mutex and a mutex that is owned by any thread. If condition-variable is supplied, the current thread is blocked and added to the condition-variable before unlocking mutex ; the thread can unblock at any time but no later than when an appropriate call to condition-variable-signal! or condition-variable-broadcast! is performed (see below), and no later than the timeout (if timeout is supplied). If there are threads waiting to lock this mutex, the scheduler selects a thread, the mutex becomes locked/owned or locked/not-owned, and the thread is unblocked. mutex-unlock! returns #f when the timeout is reached, otherwise it returns #t . Note The reason the thread can unblock at any time (when condition-variable is supplied) is that the scheduler, when it detects a serious problem such as a deadlock, must interrupt one of the blocked threads (such as the primordial thread) so that it can perform some appropriate action. After a thread blocked on a condition-variable has handled such an interrupt it would be wrong for the scheduler to return the thread to the blocked state, because any calls to condition-variable-broadcast! during the interrupt will have gone unnoticed. It is necessary for the thread to remain runnable and return from the call to mutex-unlock! with a result of #t . Note mutex-unlock! is related to the \"wait\" operation on condition variables available in other thread systems. The main difference is that \"wait\" automatically locks mutex just after the thread is unblocked. This operation is not performed by mutex-unlock! and so must be done by an explicit call to mutex-lock! . This has the advantages that a different timeout and exception-handler can be specified on the mutex-lock! and mutex-unlock! and the location of all the mutex operations is clearly apparent. For example: (let loop () (mutex-lock! m) (if (condition-is-true?) (begin (do-something-when-condition-is-true) (mutex-unlock! m)) (begin (mutex-unlock! m cv) (loop)))) condition-variable? (condition-variable? obj) ;; procedure This procedure returns #t when obj is a condition-variable object and #f otherwise. For example: > (condition-variable? (make-condition-variable)) #t > (condition-variable? 'foo) #f make-condition-variable (make-condition-variable [name]) ;; procedure This procedure returns a new empty condition variable. The optional name is an arbitrary Scheme object which identifies the condition variable (useful for debugging); it defaults to an unspecified value. The condition variable's specific field is set to an unspecified value. For example: > (make-condition-variable) #<condition-variable #2> condition-variable-name (condition-variable-name condition-variable) ;; procedure This procedure returns the name of the condition-variable . For example: > (condition-variable-name (make-condition-variable 'foo)) foo condition-variable-specific condition-variable-specific-set! (condition-variable-specific condition-variable) ;; procedure (condition-variable-specific-set! condition-variable obj) ;; procedure The condition-variable-specific procedure returns the content of the condition-variable \u2019s specific field. The condition-variable-specific-set! procedure stores obj into the condition-variable \u2019s specific field and returns an unspecified value. For example: > (define cv (make-condition-variable)) > (condition-variable-specific-set! cv \"hello\") > (condition-variable-specific cv) \"hello\" condition-variable-signal! (condition-variable-signal! condition-variable) ;; procedure This procedure unblocks a thread blocked on the condition-variable (if there is at least one) and returns an unspecified value. For example: ; an implementation of a mailbox object of depth one; this ; implementation behaves gracefully when threads are forcibly ; terminated using thread-terminate! (an abandoned-mutex-exception ; object will be raised when a put! or get! operation is attempted ; after a thread is terminated in the middle of a put! or get! ; operation) (define (make-empty-mailbox) (let ((mutex (make-mutex)) (put-condvar (make-condition-variable)) (get-condvar (make-condition-variable)) (full? #f) (cell #f)) (define (put! obj) (mutex-lock! mutex) (if full? (begin (mutex-unlock! mutex put-condvar) (put! obj)) (begin (set! cell obj) (set! full? #t) (condition-variable-signal! get-condvar) (mutex-unlock! mutex)))) (define (get!) (mutex-lock! mutex) (if (not full?) (begin (mutex-unlock! mutex get-condvar) (get!)) (let ((result cell)) (set! cell #f) ; avoid space leaks (set! full? #f) (condition-variable-signal! put-condvar) (mutex-unlock! mutex) result))) (lambda (msg) (case msg ((put!) put!) ((get!) get!) (else (error \"unknown message\")))))) (define (mailbox-put! m obj) ((m 'put!) obj)) (define (mailbox-get! m) ((m 'get!))) condition-variable-broadcast! (condition-variable-broadcast! condition-variable) ;; procedure This procedure unblocks all the thread blocked on the condition-variable and returns an unspecified value. For example: (define (make-semaphore n) (vector n (make-mutex) (make-condition-variable))) (define (semaphore-wait! sema) (mutex-lock! (vector-ref sema 1)) (let ((n (vector-ref sema 0))) (if (> n 0) (begin (vector-set! sema 0 (- n 1)) (mutex-unlock! (vector-ref sema 1))) (begin (mutex-unlock! (vector-ref sema 1) (vector-ref sema 2)) (semaphore-wait! sema)))) (define (semaphore-signal-by! sema increment) (mutex-lock! (vector-ref sema 1)) (let ((n (+ (vector-ref sema 0) increment))) (vector-set! sema 0 n) (if (> n 0) (condition-variable-broadcast! (vector-ref sema 2))) (mutex-unlock! (vector-ref sema 1))))","title":"Procedures"},{"location":"manual/threads/procedures/#procedures","text":"","title":"Procedures"},{"location":"manual/threads/procedures/#current-thread","text":"(current-thread) ;; procedure This procedure returns the current thread. For example: > (current-thread) #<thread #1 primordial> > (eq? (current-thread) (current-thread)) #t","title":"current-thread"},{"location":"manual/threads/procedures/#thread","text":"(thread? obj) ;; procedure This procedure returns #t when obj is a thread object and #f otherwise. For example: > (thread? (current-thread)) #t > (thread? 'foo) #f","title":"thread?"},{"location":"manual/threads/procedures/#make-thread","text":"","title":"make-thread"},{"location":"manual/threads/procedures/#make-root-thread","text":"(make-thread thunk [name [thread-group]]) ;; procedure (make-root-thread thunk [name [thread-group [input-port [output-port]]]]) ;; procedure The make-thread procedure creates and returns an initialized thread. This thread is not automatically made runnable (the procedure thread-start! must be used for this). A thread has the following fields: base priority, priority boost, boosted flag, quantum, name, specific, end-result, end-exception, and a list of locked/owned mutexes it owns. The thread's execution consists of a call to thunk with the initial continuation. This continuation causes the (then) current thread to store the result in its end-result field, abandon all mutexes it owns, and finally terminate. The dynamic-wind stack of the initial continuation is empty. The optional name is an arbitrary Scheme object which identifies the thread (useful for debugging); it defaults to an unspecified value. The specific field is set to an unspecified value. The optional thread-group indicates which thread group this thread belongs to; it defaults to the thread group of the current thread. The base priority, priority boost, and quantum of the thread are set to the same value as the current thread and the boosted flag is set to false. The thread's mailbox is initially empty. The thread inherits the dynamic environment from the current thread. Moreover, in this dynamic environment the exception-handler is bound to the initial exception-handler which is a unary procedure which causes the (then) current thread to store in its end-exception field an uncaught-exception object whose \"reason\" is the argument of the handler, abandon all mutexes it owns, and finally terminate. The make-root-thread procedure behaves like the make-thread procedure except the created thread does not inherit the dynamic environment from the current thread and the base priority is set to 0 , the priority boost is set to 1.0e-6 , and the quantum is set to 0.02 . The dynamic environment of the thread has the global bindings of the parameter objects, except current-input-port which is bound to input-port , current-output-port which is bound to output-port , and current-directory which is bound to the initial current working directory of the current process. If input-port is not specified it defaults to a port corresponding to the standard input ( stdin ). If output-port is not specified it defaults to a port corresponding to the standard output ( stdout ). For example: > (make-thread (lambda () (write 'hello))) #<thread #2> > (make-root-thread (lambda () (write 'world)) 'a-name) #<thread #3 a-name>","title":"make-root-thread"},{"location":"manual/threads/procedures/#thread_1","text":"(thread thunk) ;; procedure The thread procedure creates, starts and returns a new thread. The call (thread thunk) is equivalent to (thread-start! (make-thread thunk)) . For example: > (define a (thread (lambda () (expt 2 1005)))) > (define b (thread (lambda () (expt 2 1000)))) > (/ (thread-join! a) (thread-join! b)) 32","title":"thread"},{"location":"manual/threads/procedures/#thread-name","text":"(thread-name thread) ;; procedure This procedure returns the name of the thread. For example: > (thread-name (make-thread (lambda () #f) 'foo)) foo","title":"thread-name"},{"location":"manual/threads/procedures/#thread-specific","text":"","title":"thread-specific"},{"location":"manual/threads/procedures/#thread-specific-set","text":"(thread-specific thread) ;; procedure (thread-specific-set! thread obj) ;; procedure The thread-specific procedure returns the content of the thread's specific field. The thread-specific-set! procedure stores obj into the thread's specific field and returns an unspecified value. For example: > (thread-specific-set! (current-thread) \"hello\") > (thread-specific (current-thread)) \"hello\"","title":"thread-specific-set!"},{"location":"manual/threads/procedures/#thread-base-priority","text":"","title":"thread-base-priority"},{"location":"manual/threads/procedures/#thread-base-priority-set","text":"(thread-base-priority thread) ;; procedure (thread-base-priority-set! thread priority) ;; procedure The procedure thread-base-priority returns a real number which corresponds to the base priority of the thread. The procedure thread-base-priority-set! changes the base priority of the thread to priority and returns an unspecified value. The priority must be a real number. For example: > (thread-base-priority-set! (current-thread) 12.3) > (thread-base-priority (current-thread)) 12.3","title":"thread-base-priority-set!"},{"location":"manual/threads/procedures/#thread-priority-boost","text":"","title":"thread-priority-boost"},{"location":"manual/threads/procedures/#thread-priority-boost-set","text":"(thread-priority-boost thread) ;; procedure (thread-priority-boost-set! thread priority-boost) ;; procedure The procedure thread-priority-boost returns a real number which corresponds to the priority boost of the thread. The procedure thread-priority-boost-set! changes the priority boost of the thread to priority-boost and returns an unspecified value. The priority-boost must be a nonnegative real. For example: > (thread-priority-boost-set! (current-thread) 2.5) > (thread-priority-boost (current-thread)) 2.5","title":"thread-priority-boost-set!"},{"location":"manual/threads/procedures/#thread-quantum","text":"","title":"thread-quantum"},{"location":"manual/threads/procedures/#thread-quantum-set","text":"(thread-quantum thread) ;; procedure (thread-quantum-set! thread quantum) ;; procedure The procedure thread-quantum returns a real number which corresponds to the quantum of the thread. The procedure thread-quantum-set! changes the quantum of the thread to quantum and returns an unspecified value. The quantum must be a nonnegative real. A value of zero selects the smallest quantum supported by the implementation. For example: > (thread-quantum-set! (current-thread) 1.5) > (thread-quantum (current-thread)) 1.5 > (thread-quantum-set! (current-thread) 0) > (thread-quantum (current-thread)) 0.","title":"thread-quantum-set!"},{"location":"manual/threads/procedures/#thread-start","text":"(thread-start! thread) ;; procedure This procedure makes thread runnable and returns the thread. The thread must be an initialized thread. For example: > (let ((t (thread-start! (make-thread (lambda () (write 'a)))))) (write 'b) (thread-join! t)) ab> or ba> Note It is useful to separate thread creation and thread activation to avoid the race condition that would occur if the created thread tries to examine a table in which the current thread stores the created thread. See the last example of the thread-terminate! procedure which contains mutually recursive threads.","title":"thread-start!"},{"location":"manual/threads/procedures/#thread-yield","text":"(thread-yield!) ;; procedure This procedure causes the current thread to exit the running state as if its quantum had expired and returns an unspecified value. For example: ; a busy loop that avoids being too wasteful of the CPU (let loop () (if (mutex-lock! m 0) ; try to lock m but don't block (begin (display \"locked mutex m\") (mutex-unlock! m)) (begin (do-something-else) (thread-yield!) ; relinquish rest of quantum (loop))))","title":"thread-yield!"},{"location":"manual/threads/procedures/#thread-sleep","text":"(thread-sleep! timeout) ;; procedure This procedure causes the current thread to wait until the timeout is reached and returns an unspecified value. This blocks the thread only if timeout represents a point in the future. It is an error for timeout to be #f . For example: ; a clock with a gradual drift: (let loop ((x 1)) (thread-sleep! 1) (write x) (loop (+ x 1))) ; a clock with no drift: (let ((start (time->seconds (current-time))) (let loop ((x 1)) (thread-sleep! (seconds->time (+ x start))) (write x) (loop (+ x 1))))","title":"thread-sleep!"},{"location":"manual/threads/procedures/#thread-terminate","text":"(thread-terminate! thread) ;; procedure This procedure causes an abnormal termination of the thread . If the thread is not already terminated, all mutexes owned by the thread become unlocked/abandoned and a terminated-thread-exception object is stored in the thread's end-exception field. If thread is the current thread, thread-terminate! does not return. Otherwise thread-terminate! returns an unspecified value; the termination of the thread will occur at some point between the calling of thread-terminate! and a finite time in the future (an explicit thread synchronization is needed to detect termination, see thread-join! ). For example: (define (amb thunk1 thunk2) (let ((result #f) (result-mutex (make-mutex)) (done-mutex (make-mutex))) (letrec ((child1 (make-thread (lambda () (let ((x (thunk1))) (mutex-lock! result-mutex #f #f) (set! result x) (thread-terminate! child2) (mutex-unlock! done-mutex))))) (child2 (make-thread (lambda () (let ((x (thunk2))) (mutex-lock! result-mutex #f #f) (set! result x) (thread-terminate! child1) (mutex-unlock! done-mutex)))))) (mutex-lock! done-mutex #f #f) (thread-start! child1) (thread-start! child2) (mutex-lock! done-mutex #f #f) result))) Note This operation must be used carefully because it terminates a thread abruptly and it is impossible for that thread to perform any kind of cleanup. This may be a problem if the thread is in the middle of a critical section where some structure has been put in an inconsistent state. However, another thread attempting to enter this critical section will raise an abandoned-mutex-exception object because the mutex is unlocked/abandoned. This helps avoid observing an inconsistent state. Clean termination can be obtained by polling, as shown in the example below. For example: (define (spawn thunk) (let ((t (make-thread thunk))) (thread-specific-set! t #t) (thread-start! t) t)) (define (stop! thread) (thread-specific-set! thread #f) (thread-join! thread)) (define (keep-going?) (thread-specific (current-thread))) (define count! (let ((m (make-mutex)) (i 0)) (lambda () (mutex-lock! m) (let ((x (+ i 1))) (set! i x) (mutex-unlock! m) x)))) (define (increment-forever!) (let loop () (count!) (if (keep-going?) (loop)))) (let ((t1 (spawn increment-forever!)) (t2 (spawn increment-forever!))) (thread-sleep! 1) (stop! t1) (stop! t2) (count!)) ==> 377290","title":"thread-terminate!"},{"location":"manual/threads/procedures/#thread-join","text":"(thread-join! thread [timeout [timeout-val]]) procedure This procedure causes the current thread to wait until the thread terminates (normally or not) or until the timeout is reached if timeout is supplied. If the timeout is reached, thread-join! returns timeout-val if it is supplied, otherwise a join-timeout-exception object is raised. If the thread terminated normally, the content of the end-result field is returned, otherwise the content of the end-exception field is raised. For example: (let ((t (thread-start! (make-thread (lambda () (expt 2 100)))))) (do-something-else) (thread-join! t)) ==> 1267650600228229401496703205376 (let ((t (thread-start! (make-thread (lambda () (raise 123)))))) (do-something-else) (with-exception-handler (lambda (exc) (if (uncaught-exception? exc) (* 10 (uncaught-exception-reason exc)) 99999)) (lambda () (+ 1 (thread-join! t))))) ==> 1231 (define thread-alive? (let ((unique (list 'unique))) (lambda (thread) ; Note: this procedure raises an exception if ; the thread terminated abnormally. (eq? (thread-join! thread 0 unique) unique)))) (define (wait-for-termination! thread) (let ((eh (current-exception-handler))) (with-exception-handler (lambda (exc) (if (not (or (terminated-thread-exception? exc) (uncaught-exception? exc))) (eh exc))) ; unexpected exceptions are handled by eh (lambda () ; The following call to thread-join! will wait until the ; thread terminates. If the thread terminated normally ; thread-join! will return normally. If the thread ; terminated abnormally then one of these two exception ; objects is raised by thread-join!: ; - terminated-thread-exception object ; - uncaught-exception object (thread-join! thread) #f)))) ; ignore result of thread-join!","title":"thread-join!"},{"location":"manual/threads/procedures/#thread-send","text":"(thread-send thread msg) ;; procedure Each thread has a mailbox which stores messages delivered to the thread in the order delivered. The procedure thread-send adds the message msg at the end of the mailbox of thread thread and returns an unspecified value. For example: > (thread-send (current-thread) 111) > (thread-send (current-thread) 222) > (thread-receive) 111 > (thread-receive) 222","title":"thread-send"},{"location":"manual/threads/procedures/#thread-receive","text":"","title":"thread-receive"},{"location":"manual/threads/procedures/#thread-mailbox-next","text":"","title":"thread-mailbox-next"},{"location":"manual/threads/procedures/#thread-mailbox-rewind","text":"","title":"thread-mailbox-rewind"},{"location":"manual/threads/procedures/#thread-mailbox-extract-and-rewind","text":"(thread-receive [timeout [default]]) ;; procedure (thread-mailbox-next [timeout [default]]) ;; procedure (thread-mailbox-rewind) ;; procedure (thread-mailbox-extract-and-rewind) ;; procedure To allow a thread to examine the messages in its mailbox without removing them from the mailbox, each thread has a mailbox cursor which normally points to the last message accessed in the mailbox. When a mailbox cursor is rewound using the procedure thread-mailbox-rewind or thread-mailbox-extract-and-rewind or thread-receive , the cursor does not point to a message, but the next call to thread-receive and thread-mailbox-next will set the cursor to the oldest message in the mailbox. The procedure thread-receive advances the mailbox cursor of the current thread to the next message, removes that message from the mailbox, rewinds the mailbox cursor, and returns the message. When timeout is not specified, the current thread will wait until a message is available in the mailbox. When timeout is specified and default is not specified, a mailbox-receive-timeout-exception object is raised if the timeout is reached before a message is available. When timeout is specified and default is specified, default is returned if the timeout is reached before a message is available. The procedure thread-mailbox-next behaves like thread-receive except that the message remains in the mailbox and the mailbox cursor is not rewound. The procedures thread-mailbox-rewind or thread-mailbox-extract-and-rewind rewind the mailbox cursor of the current thread so that the next call to thread-mailbox-next and thread-receive will access the oldest message in the mailbox. Additionally the procedure thread-mailbox-extract-and-rewind will remove from the mailbox the message most recently accessed by a call to thread-mailbox-next . When thread-mailbox-next has not been called since the last call to thread-receive or thread-mailbox-rewind or thread-mailbox-extract-and-rewind , a call to thread-mailbox-extract-and-rewind only resets the mailbox cursor (no message is removed). For example: > (thread-send (current-thread) 111) > (thread-receive 1 999) 111 > (thread-send (current-thread) 222) > (thread-send (current-thread) 333) > (thread-mailbox-next 1 999) 222 > (thread-mailbox-next 1 999) 333 > (thread-mailbox-next 1 999) 999 > (thread-mailbox-extract-and-rewind) > (thread-receive 1 999) 222 > (thread-receive 1 999) 999","title":"thread-mailbox-extract-and-rewind"},{"location":"manual/threads/procedures/#mailbox-receive-timeout-exception","text":"","title":"mailbox-receive-timeout-exception?"},{"location":"manual/threads/procedures/#mailbox-receive-timeout-exception-procedure","text":"","title":"mailbox-receive-timeout-exception-procedure"},{"location":"manual/threads/procedures/#mailbox-receive-timeout-exception-arguments","text":"(mailbox-receive-timeout-exception? obj) procedure (mailbox-receive-timeout-exception-procedure exc) procedure (mailbox-receive-timeout-exception-arguments exc) procedure Mailbox-receive-timeout-exception objects are raised by the procedures thread-receive and thread-mailbox-next when a timeout expires before a message is available and no default value is specified. The parameter exc must be a mailbox-receive-timeout-exception object. The procedure mailbox-receive-timeout-exception? returns #t when obj is a mailbox-receive-timeout-exception object and #f otherwise. The procedure mailbox-receive-timeout-exception-procedure returns the procedure that raised exc . The procedure mailbox-receive-timeout-exception-arguments returns the list of arguments of the procedure that raised exc . For example: > (define (handler exc) (if (mailbox-receive-timeout-exception? exc) (list (mailbox-receive-timeout-exception-procedure exc) (mailbox-receive-timeout-exception-arguments exc)) 'not-mailbox-receive-timeout-exception)) > (with-exception-catcher handler (lambda () (thread-receive 1))) (#<procedure #2 thread-receive> (1))","title":"mailbox-receive-timeout-exception-arguments"},{"location":"manual/threads/procedures/#mutex","text":"(mutex? obj) ;; procedure This procedure returns #t when obj is a mutex object and #f otherwise. For example: > (mutex? (make-mutex)) #t > (mutex? 'foo) #f","title":"mutex?"},{"location":"manual/threads/procedures/#make-mutex","text":"(make-mutex [name]) ;; procedure This procedure returns a new mutex in the unlocked/not-abandoned state. The optional name is an arbitrary Scheme object which identifies the mutex (useful for debugging); it defaults to an unspecified value. The mutex's specific field is set to an unspecified value. For example: > (make-mutex) #<mutex #2> > (make-mutex 'foo) #<mutex #3 foo>","title":"make-mutex"},{"location":"manual/threads/procedures/#mutex-name","text":"(mutex-name mutex) ;; procedure Returns the name of the mutex. For example: > (mutex-name (make-mutex 'foo)) foo","title":"mutex-name"},{"location":"manual/threads/procedures/#mutex-specific","text":"","title":"mutex-specific"},{"location":"manual/threads/procedures/#mutex-specific-set","text":"(mutex-specific mutex) ;; procedure (mutex-specific-set! mutex obj) ;; procedure The mutex-specific procedure returns the content of the mutex's specific field. The mutex-specific-set! procedure stores obj into the mutex's specific field and returns an unspecified value. For example: > (define m (make-mutex)) > (mutex-specific-set! m \"hello\") > (mutex-specific m) \"hello\" > (define (mutex-lock-recursively! mutex) (if (eq? (mutex-state mutex) (current-thread)) (let ((n (mutex-specific mutex))) (mutex-specific-set! mutex (+ n 1))) (begin (mutex-lock! mutex) (mutex-specific-set! mutex 0)))) > (define (mutex-unlock-recursively! mutex) (let ((n (mutex-specific mutex))) (if (= n 0) (mutex-unlock! mutex) (mutex-specific-set! mutex (- n 1))))) > (mutex-lock-recursively! m) > (mutex-lock-recursively! m) > (mutex-lock-recursively! m) > (mutex-specific m) 2","title":"mutex-specific-set!"},{"location":"manual/threads/procedures/#mutex-state","text":"(mutex-state mutex) ;; procedure This procedure returns information about the state of the mutex. The possible results are: thread T : the mutex is in the locked/owned state and thread T is the owner of the mutex symbol not-owned : the mutex is in the locked/not-owned state symbol abandoned : the mutex is in the unlocked/abandoned state symbol not-abandoned : the mutex is in the unlocked/not-abandoned state For example: (mutex-state (make-mutex)) ==> not-abandoned (define (thread-alive? thread) (let ((mutex (make-mutex))) (mutex-lock! mutex #f thread) (let ((state (mutex-state mutex))) (mutex-unlock! mutex) ; avoid space leak (eq? state thread))))","title":"mutex-state"},{"location":"manual/threads/procedures/#mutex-lock","text":"(mutex-lock! mutex [timeout [thread]]) ;; procedure This procedure locks mutex. If the mutex is currently locked, the current thread waits until the mutex is unlocked, or until the timeout is reached if timeout is supplied. If the timeout is reached, mutex-lock! returns \u2018#f\u2019. Otherwise, the state of the mutex is changed as follows: if thread is #f the mutex becomes locked/not-owned, otherwise, let T be thread (or the current thread if thread is not supplied), if T is terminated the mutex becomes unlocked/abandoned, otherwise mutex becomes locked/owned with T as the owner. After changing the state of the mutex, an abandoned-mutex-exception object is raised if the mutex was unlocked/abandoned before the state change, otherwise mutex-lock! returns #t . It is not an error if the mutex is owned by the current thread (but the current thread will have to wait). For example: ; an implementation of a mailbox object of depth one; this ; implementation does not behave well in the presence of forced ; thread terminations using thread-terminate! (deadlock can occur ; if a thread is terminated in the middle of a put! or get! operation) (define (make-empty-mailbox) (let ((put-mutex (make-mutex)) ; allow put! operation (get-mutex (make-mutex)) (cell #f)) (define (put! obj) (mutex-lock! put-mutex #f #f) ; prevent put! operation (set! cell obj) (mutex-unlock! get-mutex)) ; allow get! operation (define (get!) (mutex-lock! get-mutex #f #f) ; wait until object in mailbox (let ((result cell)) (set! cell #f) ; prevent space leaks (mutex-unlock! put-mutex) ; allow put! operation result)) (mutex-lock! get-mutex #f #f) ; prevent get! operation (lambda (msg) (case msg ((put!) put!) ((get!) get!) (else (error \"unknown message\")))))) (define (mailbox-put! m obj) ((m 'put!) obj)) (define (mailbox-get! m) ((m 'get!))) ; an alternate implementation of thread-sleep! (define (sleep! timeout) (let ((m (make-mutex))) (mutex-lock! m #f #f) (mutex-lock! m timeout #f))) ; a procedure that waits for one of two mutexes to unlock (define (lock-one-of! mutex1 mutex2) ; this procedure assumes that neither mutex1 or mutex2 ; are owned by the current thread (let ((ct (current-thread)) (done-mutex (make-mutex))) (mutex-lock! done-mutex #f #f) (let ((t1 (thread-start! (make-thread (lambda () (mutex-lock! mutex1 #f ct) (mutex-unlock! done-mutex))))) (t2 (thread-start! (make-thread (lambda () (mutex-lock! mutex2 #f ct) (mutex-unlock! done-mutex)))))) (mutex-lock! done-mutex #f #f) (thread-terminate! t1) (thread-terminate! t2) (if (eq? (mutex-state mutex1) ct) (begin (if (eq? (mutex-state mutex2) ct) (mutex-unlock! mutex2)) ; don't lock both mutex1) mutex2))))","title":"mutex-lock!"},{"location":"manual/threads/procedures/#mutex-unlock","text":"(mutex-unlock! mutex [condition-variable [timeout]]) ;; procedure This procedure unlocks the mutex by making it unlocked/not-abandoned. It is not an error to unlock an unlocked mutex and a mutex that is owned by any thread. If condition-variable is supplied, the current thread is blocked and added to the condition-variable before unlocking mutex ; the thread can unblock at any time but no later than when an appropriate call to condition-variable-signal! or condition-variable-broadcast! is performed (see below), and no later than the timeout (if timeout is supplied). If there are threads waiting to lock this mutex, the scheduler selects a thread, the mutex becomes locked/owned or locked/not-owned, and the thread is unblocked. mutex-unlock! returns #f when the timeout is reached, otherwise it returns #t . Note The reason the thread can unblock at any time (when condition-variable is supplied) is that the scheduler, when it detects a serious problem such as a deadlock, must interrupt one of the blocked threads (such as the primordial thread) so that it can perform some appropriate action. After a thread blocked on a condition-variable has handled such an interrupt it would be wrong for the scheduler to return the thread to the blocked state, because any calls to condition-variable-broadcast! during the interrupt will have gone unnoticed. It is necessary for the thread to remain runnable and return from the call to mutex-unlock! with a result of #t . Note mutex-unlock! is related to the \"wait\" operation on condition variables available in other thread systems. The main difference is that \"wait\" automatically locks mutex just after the thread is unblocked. This operation is not performed by mutex-unlock! and so must be done by an explicit call to mutex-lock! . This has the advantages that a different timeout and exception-handler can be specified on the mutex-lock! and mutex-unlock! and the location of all the mutex operations is clearly apparent. For example: (let loop () (mutex-lock! m) (if (condition-is-true?) (begin (do-something-when-condition-is-true) (mutex-unlock! m)) (begin (mutex-unlock! m cv) (loop))))","title":"mutex-unlock!"},{"location":"manual/threads/procedures/#condition-variable","text":"(condition-variable? obj) ;; procedure This procedure returns #t when obj is a condition-variable object and #f otherwise. For example: > (condition-variable? (make-condition-variable)) #t > (condition-variable? 'foo) #f","title":"condition-variable?"},{"location":"manual/threads/procedures/#make-condition-variable","text":"(make-condition-variable [name]) ;; procedure This procedure returns a new empty condition variable. The optional name is an arbitrary Scheme object which identifies the condition variable (useful for debugging); it defaults to an unspecified value. The condition variable's specific field is set to an unspecified value. For example: > (make-condition-variable) #<condition-variable #2>","title":"make-condition-variable"},{"location":"manual/threads/procedures/#condition-variable-name","text":"(condition-variable-name condition-variable) ;; procedure This procedure returns the name of the condition-variable . For example: > (condition-variable-name (make-condition-variable 'foo)) foo","title":"condition-variable-name"},{"location":"manual/threads/procedures/#condition-variable-specific","text":"","title":"condition-variable-specific"},{"location":"manual/threads/procedures/#condition-variable-specific-set","text":"(condition-variable-specific condition-variable) ;; procedure (condition-variable-specific-set! condition-variable obj) ;; procedure The condition-variable-specific procedure returns the content of the condition-variable \u2019s specific field. The condition-variable-specific-set! procedure stores obj into the condition-variable \u2019s specific field and returns an unspecified value. For example: > (define cv (make-condition-variable)) > (condition-variable-specific-set! cv \"hello\") > (condition-variable-specific cv) \"hello\"","title":"condition-variable-specific-set!"},{"location":"manual/threads/procedures/#condition-variable-signal","text":"(condition-variable-signal! condition-variable) ;; procedure This procedure unblocks a thread blocked on the condition-variable (if there is at least one) and returns an unspecified value. For example: ; an implementation of a mailbox object of depth one; this ; implementation behaves gracefully when threads are forcibly ; terminated using thread-terminate! (an abandoned-mutex-exception ; object will be raised when a put! or get! operation is attempted ; after a thread is terminated in the middle of a put! or get! ; operation) (define (make-empty-mailbox) (let ((mutex (make-mutex)) (put-condvar (make-condition-variable)) (get-condvar (make-condition-variable)) (full? #f) (cell #f)) (define (put! obj) (mutex-lock! mutex) (if full? (begin (mutex-unlock! mutex put-condvar) (put! obj)) (begin (set! cell obj) (set! full? #t) (condition-variable-signal! get-condvar) (mutex-unlock! mutex)))) (define (get!) (mutex-lock! mutex) (if (not full?) (begin (mutex-unlock! mutex get-condvar) (get!)) (let ((result cell)) (set! cell #f) ; avoid space leaks (set! full? #f) (condition-variable-signal! put-condvar) (mutex-unlock! mutex) result))) (lambda (msg) (case msg ((put!) put!) ((get!) get!) (else (error \"unknown message\")))))) (define (mailbox-put! m obj) ((m 'put!) obj)) (define (mailbox-get! m) ((m 'get!)))","title":"condition-variable-signal!"},{"location":"manual/threads/procedures/#condition-variable-broadcast","text":"(condition-variable-broadcast! condition-variable) ;; procedure This procedure unblocks all the thread blocked on the condition-variable and returns an unspecified value. For example: (define (make-semaphore n) (vector n (make-mutex) (make-condition-variable))) (define (semaphore-wait! sema) (mutex-lock! (vector-ref sema 1)) (let ((n (vector-ref sema 0))) (if (> n 0) (begin (vector-set! sema 0 (- n 1)) (mutex-unlock! (vector-ref sema 1))) (begin (mutex-unlock! (vector-ref sema 1) (vector-ref sema 2)) (semaphore-wait! sema)))) (define (semaphore-signal-by! sema increment) (mutex-lock! (vector-ref sema 1)) (let ((n (+ (vector-ref sema 0) increment))) (vector-set! sema 0 n) (if (> n 0) (condition-variable-broadcast! (vector-ref sema 2))) (mutex-unlock! (vector-ref sema 1))))","title":"condition-variable-broadcast!"},{"location":"manual/threads/thread_objects/","text":"Thread objects A running thread is a thread that is currently executing. A runnable thread is a thread that is ready to execute or running. A thread is blocked if it is waiting for a mutex to become unlocked, an I/O operation to become possible, the end of a \"sleep\" period, etc. A new thread is a thread that has been allocated but has not yet been initialized. An initialized thread is a thread that can be made runnable. A new thread becomes runnable when it is started by calling thread-start! . A terminated thread is a thread that can no longer become runnable (but deadlocked threads are not considered terminated). The only valid transitions between the thread states are from new to initialized, from initialized to runnable, between runnable and blocked, and from any state except new to terminated as indicated in the following diagram: unblock start <------- NEW -------> INITIALIZED -------> RUNNABLE -------> BLOCKED \\ | block / \\ v / +-----> TERMINATED <----+ Each thread has a base priority, which is a real number (where a higher numerical value means a higher priority), a priority boost, which is a nonnegative real number representing the priority increase applied to a thread when it blocks, and a quantum, which is a nonnegative real number representing a duration in seconds. Each thread has a specific field which can be used in an application specific way to associate data with the thread (some thread systems call this \"thread local storage\"). Each thread has a mailbox which is used for inter-thread communication.","title":"Thread objects"},{"location":"manual/threads/thread_objects/#thread-objects","text":"A running thread is a thread that is currently executing. A runnable thread is a thread that is ready to execute or running. A thread is blocked if it is waiting for a mutex to become unlocked, an I/O operation to become possible, the end of a \"sleep\" period, etc. A new thread is a thread that has been allocated but has not yet been initialized. An initialized thread is a thread that can be made runnable. A new thread becomes runnable when it is started by calling thread-start! . A terminated thread is a thread that can no longer become runnable (but deadlocked threads are not considered terminated). The only valid transitions between the thread states are from new to initialized, from initialized to runnable, between runnable and blocked, and from any state except new to terminated as indicated in the following diagram: unblock start <------- NEW -------> INITIALIZED -------> RUNNABLE -------> BLOCKED \\ | block / \\ v / +-----> TERMINATED <----+ Each thread has a base priority, which is a real number (where a higher numerical value means a higher priority), a priority boost, which is a nonnegative real number representing the priority increase applied to a thread when it blocks, and a quantum, which is a nonnegative real number representing a duration in seconds. Each thread has a specific field which can be used in an application specific way to associate data with the thread (some thread systems call this \"thread local storage\"). Each thread has a mailbox which is used for inter-thread communication.","title":"Thread objects"},{"location":"manual/threads/timeouts/","text":"Timeouts All synchronization primitives which take a timeout parameter accept three types of values as a timeout, with the following meaning: a time object represents an absolute point in time an exact or inexact real number represents a relative time in seconds from the moment the primitive was called #f means that there is no timeout When a timeout denotes the current time or a time in the past, the synchronization primitive claims that the timeout has been reached only after the other synchronization conditions have been checked. Moreover the thread remains running (it does not enter the blocked state). For example, (mutex-lock! m 0) will lock mutex m and return #t if m is currently unlocked, otherwise #f is returned because the timeout is reached.","title":"Timeouts"},{"location":"manual/threads/timeouts/#timeouts","text":"All synchronization primitives which take a timeout parameter accept three types of values as a timeout, with the following meaning: a time object represents an absolute point in time an exact or inexact real number represents a relative time in seconds from the moment the primitive was called #f means that there is no timeout When a timeout denotes the current time or a time in the past, the synchronization primitive claims that the timeout has been reached only after the other synchronization conditions have been checked. Moreover the thread remains running (it does not enter the blocked state). For example, (mutex-lock! m 0) will lock mutex m and return #t if m is currently unlocked, otherwise #f is returned because the timeout is reached.","title":"Timeouts"}]}