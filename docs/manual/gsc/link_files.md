---
title: Link files
---

Gambit can be used to create programs and libraries of Scheme modules. This
section explains the steps required to do so and the role played by the link
files.

In general, a program is composed of a set of Scheme modules and modules in the
target language. Some of the modules are part of the Gambit runtime library and
the other modules are supplied by the user. When the program is started it must
setup various global tables (including the symbol table and the global variable
table) and then sequentially execute the Scheme modules (more or less as though
they were being loaded one after another). The information required for this is
contained in one or more link files generated by the Gambit linker from the
target files produced by the Gambit compiler.

The order of execution of the Scheme modules corresponds to the order of the
modules on the command line which produced the link file. The order is usually
important because most modules define variables and procedures which are used by
other modules (for this reason the program's main computation is normally
started by the last module).

When a single link file is used to contain the linking information of all the
Scheme modules it is called a flat link file. Thus a program built with a flat
link file contains in its link file both information on the user modules and on
the runtime library. This is fine if the program is to be statically linked but
is wasteful in a shared-library context because the linking information of the
runtime library can’t be shared and will be duplicated in all programs (this
linking information typically takes hundreds of kilobytes).

Flat link files are mainly useful to bundle multiple Scheme modules to make a
runtime library (such as the Gambit runtime library) or to make a single file
that can be loaded with the `load` procedure.

An incremental link file contains only the linking information that is not
already contained in a second link file (the "base" link file). Assuming that a
flat link file was produced when the runtime library was linked, a program can
be built by linking the user modules with the runtime library's link file,
producing an incremental link file. This allows the creation of a shared-library
which contains the modules of the runtime library and its flat link file. The
program is dynamically linked with this shared-library and only contains the
user modules and the incremental link file. For small programs this approach
greatly reduces the size of the program because the incremental link file is
small. A "hello world" program built this way can be as small as 5 Kbytes. Note
that it is perfectly fine to use an incremental link file for statically linked
programs (there is very little loss compared to a single flat link file).

Incremental link files may be built from other incremental link files. This
allows the creation of shared-libraries which extend the functionality of the
Gambit runtime library.

### Building an executable program

The simplest way to create an executable program is to invoke `gsc` with the
`-exe` option. The compiler will transparently perform all the steps necessary,
including compiling Scheme source files to target files, generating the link
file, and (when the `C` target is selected) compiling the C files generated to
object files and creating the final executable file using the C linker. The
following example shows how to use the C target to build the executable program
`hello.exe` which contains the two Scheme modules `h.scm` and `w.six`.

```shell
$ cat h.scm
(display "hello") (newline)
$ cat w.six
display("world"); newline();
$ gsc -o hello.exe -exe h.scm w.six
h.scm:
/Users/feeley/gambit/doc/h.c:
w.six:
/Users/feeley/gambit/doc/w.c:
/Users/feeley/gambit/doc/w_.c:
$ ./hello.exe
hello
world
```

The detailed steps which are performed can be viewed by setting the
`GAMBUILD_VERBOSE` environment variable to a nonnull value. Alternatively, `gsc`’s
`-verbose` option can be used (it implicitly sets the `GAMBUILD_VERBOSE`
environment variable). For example:

```shell
$ export GAMBUILD_VERBOSE=yes
$ gsc -o hello.exe -exe h.scm w.six
h.scm:
/Users/feeley/gambit/doc/h.c:
gcc  -O1    -Wno-unused -Wno-write-strings -Wdisabled-optimization
fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno
-fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC
-fno-common -mpc64   -D___SINGLE_HOST  -I"/usr/local/Gambit/include"
-c -o 'h.o'  'h.c'
w.six:
/Users/feeley/gambit/doc/w.c:
gcc  -O1    -Wno-unused -Wno-write-strings -Wdisabled-optimization
-fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno
-fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC
-fno-common -mpc64   -D___SINGLE_HOST  -I"/usr/local/Gambit/include"
-c -o 'w.o'  'w.c'
/Users/feeley/gambit/doc/w_.c:
gcc  -O1    -Wno-unused -Wno-write-strings -Wdisabled-optimization
-fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno
-fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC
-fno-common -mpc64   -D___SINGLE_HOST  -I"/usr/local/Gambit/include"
-c -o 'w_.o'  'w_.c'
gcc     -Wno-unused -Wno-write-strings -Wdisabled-optimization
-fwrapv -fno-strict-aliasing -fno-trapping-math -fno-math-errno
-fschedule-insns2 -foptimize-sibling-calls -fomit-frame-pointer -fPIC
-fno-common -mpc64    -D___SINGLE_HOST  -I"/usr/local/Gambit/include"
-o 'hello.exe'   'w_.o' 'h.o' 'w.o' "/usr/local/Gambit/lib/libgambit.a"
```

Here is the same example using the js target showing the creation of a shell
script invoking `nodejs`:

```shell
$ export GAMBUILD_VERBOSE=yes
$ gsc -target js -o hello.exe -exe h.scm w.six
h.scm:
/Users/feeley/gambit/doc/h.js:
cat h.js > "h.o"
w.six:
/Users/feeley/gambit/doc/w.js:
cat w.js > "w.o"
/Users/feeley/gambit/doc/w_.js:
cat w_.js > "w_.o"
echo "#! /usr/bin/env node" > "hello.exe"
cat w_.o h.o w.o "/usr/local/Gambit/lib/_gambit.js" >> "hello.exe"
chmod +x "hello.exe"
```

Using a single invocation of gsc with the `-exe` option is sometimes
inappropriate when the build process is more complex, for example when the
program is composed of several separately compiled modules. In such a case it is
useful to decompose the build process into smaller compilation steps. The
`hello.exe` executable program could have been built with the `C` target by
separating the generation of C files from the C compilation and linking:

```shell
$ gsc -c h.scm
$ gsc -c w.six
$ gsc -o hello.exe -exe h.c w.c
```

When even finer control is desired the C target's build process can be
decomposed into smaller steps that invoke the C compiler and linker explicitly.
This is described in the rest of this section.

The `gsc` compiler can be invoked to compile each Scheme module into a C file and
to create an incremental link file. The C files and the link file must then be
compiled with a C compiler and linked (at the object file level) with the Gambit
runtime library and possibly other libraries (such as the math library and the
dynamic loading library).

Here is for example how a program with three modules (one in C and two in
Scheme) can be built. The content of the three source files (`m1.c`, `m2.scm`
and `m3.scm`) is:

```shell
/* File: "m1.c" */
int power_of_2 (int x) { return 1<<x; }

; File: "m2.scm"
(c-declare "extern int power_of_2 ();")
(define pow2 (c-lambda (int) int "power_of_2"))
(define (twice x) (cons x x))

; File: "m3.scm"
(write (map twice (map pow2 '(1 2 3 4)))) (newline)
```

The compilation of the two Scheme source files can be done with three
invocations of `gsc`:

```shell
$ gsc -c m2.scm        # create m2.c (note: .scm is optional)
$ gsc -c m3.scm        # create m3.c (note: .scm is optional)
$ gsc -link m2.c m3.c  # create the incremental link file m3_.c
```

Alternatively, the three invocations of `gsc` can be replaced by a single
invocation:

```shell
$ gsc -link m2 m3
m2:
m3:
```

At this point there will be 4 C files: `m1.c`, `m2.c`, `m3.c`, and `m3_.c`. To
produce an executable program these files must be compiled with a C compiler and
linked with the Gambit runtime library. The C compiler options needed will
depend on the C compiler and the operating system (in particular it may be
necessary to add the options `-I/usr/local/Gambit/include
-L/usr/local/Gambit/lib` to access the `gambit.h` header file and the Gambit
runtime library).

Here is an example under macOS:

```shell
$ uname -srmp
Darwin 20.6.0 x86_64 i386
$ gsc -obj m1.c m2.c m3.c m3_.c
m1.c:
m2.c:
m3.c:
m3_.c:
$ gcc m1.o m2.o m3.o m3_.o -lgambit
$ ./a.out
((2 . 2) (4 . 4) (8 . 8) (16 . 16))
```

Here is an example under Linux:

```shell
$ uname -srmp
Linux 5.10.0-9-amd64 x86_64 unknown
$ gsc -obj m1.c m2.c m3.c m3_.c
m1.c:
m2.c:
m3.c:
m3_.c:
$ gcc m1.o m2.o m3.o m3_.o -lgambit -lm -ldl -lutil
$ ./a.out
((2 . 2) (4 . 4) (8 . 8) (16 . 16))
```

### Building a loadable library

To bundle multiple modules into a single object file that can be dynamically
loaded with the load procedure, a flat link file is needed. The compiler’s `-o`
option must be used to name the C file generated as follows. If the dynamically
loadable object file is to be named `myfile.on` then the `-o` option must set
the name of the link file generated to `myfile.on.c` (note that the `.c`
extension could also be `.cc`, `.cpp` or whatever extension is appropriate for
C/C++ source files). The three modules of the previous example can be bundled by
generating a link file in this way:

```shell
$ gsc -link -flat -o foo.o1.c m2 m3
m2:
m3:
*** WARNING -- "cons" is not defined,
***            referenced in: ("m2.c")
*** WARNING -- "map" is not defined,
***            referenced in: ("m3.c")
*** WARNING -- "newline" is not defined,
***            referenced in: ("m3.c")
*** WARNING -- "write" is not defined,
***            referenced in: ("m3.c")
```

The warnings indicate that there are no definitions (`define`s or `set!`s) of the
variables `cons`, `map`, `newline` and `write` in the set of modules being linked.
Before `foo.o1` is loaded, these variables will have to be bound; either
implicitly (by the runtime library) or explicitly.

When compiling the C files and link file generated, the flag `-D___DYNAMIC` must
be passed to the C compiler and the C compiler and linker must be told to
generate a dynamically loadable shared library.

Here is an example under macOS:

```shell
$ uname -srmp
Darwin 20.6.0 x86_64 i386
$ gsc -link -flat -o foo.o1.c m2 m3 > /dev/null
m2:
m3:
$ gsc -cc-options "-D___DYNAMIC" -obj m1.c m2.c m3.c foo.o1.c
m1.c:
m2.c:
m3.c:
foo.o1.c:
$ gcc -bundle m1.o m2.o m3.o foo.o1.o -o foo.o1
$ gsi foo.o1
((2 . 2) (4 . 4) (8 . 8) (16 . 16))
```

Here is an example under Linux:

```shell
$ uname -srmp
Linux 5.10.0-9-amd64 x86_64 unknown
$ gsc -link -flat -o foo.o1.c m2 m3 > /dev/null
m2:
m3:
$ gsc -cc-options "-D___DYNAMIC" -obj m1.c m2.c m3.c foo.o1.c
m1.c:
m2.c:
m3.c:
foo.o1.c:
$ gcc -shared m1.o m2.o m3.o foo.o1.o -o foo.o1
$ gsi foo.o1
((2 . 2) (4 . 4) (8 . 8) (16 . 16))
```

Here is a more complex example, under Solaris, which shows how to build a
loadable library `mymod.o1` composed of the files `m4.scm`, `m5.scm` and `x.c`
that links to system shared libraries (for X-windows):

```shell
$ uname -srmp
SunOS ungava 5.6 Generic_105181-05 sun4m sparc SUNW,SPARCstation-20
$ gsc -link -flat -o mymod.o1.c m4 m5
m4:
m5:
*** WARNING -- "*" is not defined,
***            referenced in: ("m4.c")
*** WARNING -- "+" is not defined,
***            referenced in: ("m5.c")
*** WARNING -- "display" is not defined,
***            referenced in: ("m5.c" "m4.c")
*** WARNING -- "newline" is not defined,
***            referenced in: ("m5.c" "m4.c")
*** WARNING -- "write" is not defined,
***            referenced in: ("m5.c")
$ gsc -cc-options "-D___DYNAMIC" -obj m4.c m5.c x.c mymod.o1.c
m4.c:
m5.c:
x.c:
mymod.o1.c:
$ /usr/ccs/bin/ld -G -o mymod.o1 mymod.o1.o m4.o m5.o x.o -lX11 -lsocket
$ gsi mymod.o1
hello from m4
hello from m5
(f1 10) = 22
$ cat m4.scm
(define (f1 x) (* 2 (f2 x)))
(display "hello from m4")
(newline)

(c-declare #<<c-declare-end
#include "x.h"
c-declare-end
)
(define x-initialize (c-lambda (char-string) bool "x_initialize"))
(define x-display-name (c-lambda () char-string "x_display_name"))
(define x-bell (c-lambda (int) void "x_bell"))
$ cat m5.scm
(define (f2 x) (+ x 1))
(display "hello from m5")
(newline)

(display "(f1 10) = ")
(write (f1 10))
(newline)

(x-initialize (x-display-name))
(x-bell 50) ; sound the bell at 50%
$ cat x.c
#include <X11/Xlib.h>

static Display *display;

int x_initialize (char *display_name)
{
  display = XOpenDisplay (display_name);
  return display != NULL;
}

char *x_display_name (void)
{
  return XDisplayName (NULL);
}

void x_bell (int volume)
{
  XBell (display, volume);
  XFlush (display);
}
$ cat x.h
int x_initialize (char *display_name);
char *x_display_name (void);
void x_bell (int);
```

### Building a shared library

A shared-library can be built using an incremental link file or a flat link
file. An incremental link file is normally used when the Gambit runtime library
(or some other library) is to be extended with new procedures. A flat link file
is mainly useful when building a "primal" runtime library, which is a library
(such as the Gambit runtime library) that does not extend another library. When
compiling the C files and link file generated, the flags `-D___LIBRARY` and
`-D___SHARED` must be passed to the C compiler. The flag `-D___PRIMAL` must also
be passed to the C compiler when a primal library is being built.

A shared-library `mylib.so` containing the two first modules of the previous
example can be built this way:

```shell
$ uname -srmp
Linux 5.10.0-9-amd64 x86_64 unknown
$ gsc -link -o mylib.c m2
$ gsc -obj -cc-options "-D___SHARED" m1.c m2.c mylib.c
m1.c:
m2.c:
mylib.c:
$ gcc -shared  m1.o m2.o mylib.o -o mylib.so
```

Note that this shared-library is built using an incremental link file (it
extends the Gambit runtime library with the procedures `pow2` and `twice`). This
shared-library can in turn be used to build an executable program from the third
module of the previous example:

```shell
$ gsc -link -l mylib m3
$ gsc -obj m3.c m3_.c
m3.c:
m3_.c:
$ gcc m3.o m3_.o mylib.so -lgambit
$ LD_LIBRARY_PATH=.:/usr/local/lib ./a.out
((2 . 2) (4 . 4) (8 . 8) (16 . 16))
```

### Other compilation options

The performance of the code can be increased by passing the `-D___SINGLE_HOST`
flag to the C compiler. This will merge all the procedures of a module into a
single C procedure, which reduces the cost of intra-module procedure calls. In
addition the `-O2` option can be passed to the C compiler. For large modules, it
will not be practical to specify both `-O2` and `-D___SINGLE_HOST` for typical C
compilers because the compile time will be high and the C compiler might even
fail to compile the program for lack of memory. It has been observed that lower
levels of optimization (e.g. `-O1`) often give faster compilation and also
generate faster code. It is a good idea to experiment.

Normally C compilers will not automatically search `/usr/local/Gambit/include`
for header files so the flag `-I/usr/local/Gambit/include` should be passed to
the C compiler. Similarly, C compilers/linkers will not automatically search
`/usr/local/Gambit/lib` for libraries so the flag `-L/usr/local/Gambit/lib`
should be passed to the C compiler/linker. Alternatives are given in [Accessing
the system files](/manual/the_gambit_system/accessing_the_system_files).

A variety of flags are needed by some C compilers when compiling a
shared-library or a dynamically loadable library. Some of these flags are:
`-shared`, `-call_shared`, `-rdynamic`, `-fpic`, `-fPIC`, `-Kpic`, `-KPIC`,
`-pic`, `+z`, `-G`. Check your compiler's documentation to see which flag you
need.

